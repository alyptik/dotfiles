{
  "_args": [
    [
      {
        "raw": "jscodeshift@0.3.20",
        "scope": null,
        "escapedName": "jscodeshift",
        "name": "jscodeshift",
        "rawSpec": "0.3.20",
        "spec": "0.3.20",
        "type": "version"
      },
      "/tmp/d-11752-1697-1neh3y8.msdj603sor/package.tgz"
    ]
  ],
  "_from": "jscodeshift@0.3.20",
  "_id": "jscodeshift@0.3.20",
  "_inCache": true,
  "_location": "/nuclide-format-js/jscodeshift",
  "_nodeVersion": "5.7.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/jscodeshift-0.3.20.tgz_1461475753959_0.8293883518781513"
  },
  "_npmUser": {
    "name": "fkling",
    "email": "felix.kling@gmx.net"
  },
  "_npmVersion": "3.8.0",
  "_phantomChildren": {
    "ast-types": "0.9.6",
    "private": "0.1.7",
    "source-map": "0.5.6"
  },
  "_requested": {
    "raw": "jscodeshift@0.3.20",
    "scope": null,
    "escapedName": "jscodeshift",
    "name": "jscodeshift",
    "rawSpec": "0.3.20",
    "spec": "0.3.20",
    "type": "version"
  },
  "_requiredBy": [
    "/nuclide-format-js"
  ],
  "_resolved": "https://registry.npmjs.org/jscodeshift/-/jscodeshift-0.3.20.tgz",
  "_shasum": "1e8e7f1c7207d3ab91ae21f160281561156f7caa",
  "_shrinkwrap": null,
  "_spec": "jscodeshift@0.3.20",
  "_where": "/tmp/d-11752-1697-1neh3y8.msdj603sor/package.tgz",
  "author": {
    "name": "Felix Kling"
  },
  "bin": {
    "jscodeshift": "./bin/jscodeshift.sh"
  },
  "bugs": {
    "url": "https://github.com/facebook/jscodeshift/issues"
  },
  "dependencies": {
    "async": "^1.5.0",
    "babel-core": "^5.8.21",
    "babel-runtime": "^5.6.18",
    "colors": "^1.1.2",
    "es6-promise": "^3.0.0",
    "lodash": "^3.5.0",
    "micromatch": "^2.3.7",
    "node-dir": "0.1.8",
    "nomnom": "^1.8.1",
    "recast": "^0.11.0",
    "temp": "^0.8.1"
  },
  "description": "A toolkit for JavaScript codemods",
  "devDependencies": {
    "babel": "^5.6.14",
    "babel-jest": "^5.3.0",
    "jest-cli": "^0.9.0",
    "mkdirp": "^0.5.1"
  },
  "directories": {},
  "dist": {
    "shasum": "1e8e7f1c7207d3ab91ae21f160281561156f7caa",
    "tarball": "https://registry.npmjs.org/jscodeshift/-/jscodeshift-0.3.20.tgz"
  },
  "gitHead": "d07ac8ef2ea814b0ea1656f223e3c5271d5b991b",
  "homepage": "https://github.com/facebook/jscodeshift#readme",
  "jest": {
    "scriptPreprocessor": "<rootDir>/node_modules/babel-jest",
    "preprocessCachingDisabled": true,
    "testPathDirs": [
      "src",
      "bin",
      "sample"
    ],
    "unmockedModulePathPatterns": [
      "node_modules/"
    ]
  },
  "keywords": [
    "codemod",
    "recast"
  ],
  "license": "BSD-3-Clause",
  "main": "index.js",
  "maintainers": [
    {
      "name": "fkling",
      "email": "felix.kling@gmx.net"
    }
  ],
  "name": "jscodeshift",
  "optionalDependencies": {},
  "readme": "# jscodeshift [![Build Status](https://travis-ci.org/facebook/jscodeshift.svg?branch=master)](https://travis-ci.org/facebook/jscodeshift)\n\njscodeshift is a toolkit for running codemods over multiple JS files.\nIt provides:\n\n- A runner, which executes the provided transform for each file passed to it.\n  It also outputs a summary of how many files have (not) been transformed.\n- A wrapper around [recast][], providing a different API.  Recast is an\n  AST-to-AST transform tool and also tries to preserve the style of original code\n  as much as possible.\n\n## Install\n\nGet jscodeshift from [npm][]:\n\n```\n$ npm install -g jscodeshift\n```\n\nThis will install the runner as `jscodeshift`.\n\n## Usage (CLI)\n\nThe CLI provides the following options:\n\n```text\n$ jscodeshift --help\n\nUsage: jscodeshift <path>... [options]\n\npath     Files or directory to transform\n\nOptions:\n   -t FILE, --transform FILE   Path to the transform file  [./transform.js]\n   -c, --cpus                  (all by default) Determines the number of processes started.\n   -v, --verbose               Show more information about the transform process  [0]\n   -d, --dry                   Dry run (no changes are made to files)\n   -p, --print                 Print output, useful for development\n   --babel                     Apply Babel to transform files  [true]\n   --extensions                File extensions the transform file should be applied to  [js]\n   --ignore-pattern            Ignore files that match a provided glob expression\n   --ignore-config FILE        Ignore files if they match patterns sourced from a configuration file (e.g., a .gitignore)\n   --run-in-band               Run serially in the current process  [false]\n   -s, --silent                No output  [false]\n```\n\nThis passes the source of all passed through the transform module specified\nwith `-t` or `--transform` (defaults to `transform.js` in the current\ndirectory). The next section explains the structure of the transform module.\n\n## Transform module\n\nThe transform is simply a module that exports a function of the form:\n\n```js\nmodule.exports = function(fileInfo, api, options) {\n  // transform `fileInfo.source` here\n  // ...\n  // return changed source\n  return source;\n};\n```\n\n### Arguments\n\n#### `fileInfo`\n\nHolds information about the currently processed file.\n\nProperty    | Description\n------------|------------\npath        | File path\nsource      | File content\n\n#### `api`\n\nThis object exposes the `jscodeshift` library and helper functions from the\nrunner.\n\nProperty    | Description\n------------|------------\njscodeshift | A reference to the jscodeshift library\nstats       | A function to collect statistics during `--dry` runs\n\n`jscodeshift` is a reference to the wrapper around recast and provides a\njQuery-like API to navigate and transform the AST. Here is a quick example,\na more detailed description can be found below.\n\n```js\n/**\n * This replaces every occurence of variable \"foo\".\n */\nmodule.exports = function(fileInfo, api) {\n  return api.jscodeshift(fileInfo.source)\n    .findVariableDeclarators('foo')\n    .renameTo('bar')\n    .toSource();\n}\n```\n\n**Note:** This api is exposed for convenience, but you don't have to use it.\nYou can use any tool to modify the source.\n\n`stats` is a function that only works when the `--dry` options is set. It accepts\na string, and will simply count how often it was called with that value.\n\nAt the end, the CLI will report those values. This can be useful while\ndeveloping the transform, e.g. to find out how often a certain construct\nappears in the source(s).\n\n#### `options`\n\nContains all options that have been passed to runner. This allows you to pass\nadditional options to the transform. For example, if the CLI is called with\n\n```\n$ jscodeshift -t myTransforms fileA fileB --foo=bar\n```\n\n`options` would contain `{foo: 'bar'}`. jscodeshift uses [nomnom][] to parse\ncommand line options.\n\n#### Return value\n\nThe return value of the function determines the status of the transformation:\n\n- If a string is returned and it is different from passed source, the\n  transform is considered to be successful.\n- If a string is returned but it's the same as the source, the transform\n  is considered to be unsuccessful.\n- If nothing is returned, the file is not supposed to be transformed (which is\n  ok).\n\nThe CLI provides a summary of the transformation at the end. You can get more\ndetailed information by setting the `-v` option to `1` or `2`.\n\nYou can collect even more stats via the `stats` function as explained above.\n\n### Example\n\n```text\n$ jscodeshift -t myTransform.js src\nProcessing 10 files...\nSpawning 2 workers with 5 files each...\nAll workers done.\nResults: 0 errors 2 unmodified 3 skipped 5 ok\n```\n\n## The jscodeshift API\n\nAs already mentioned, jscodeshift also provides a wrapper around [recast][].\nIn order to properly use the jscodeshift API, one has to understand the basic\nbuilding blocks of recast (and ASTs) as well.\n\n### Core Concepts\n\n#### AST nodes\n\nAn AST node is a plain JavaScript object with a specific set of fields, in\naccordance with the [Mozilla Parser API][]. The primary way to identify nodes\nis via their `type`.\n\nFor example, string literals are represented via `Literal` nodes, which\nhave the structure\n\n```js\n// \"foo\"\n{\n  type: 'Literal',\n  value: 'foo',\n  raw: '\"foo\"'\n}\n```\n\nIt's OK to not know the structure of every AST node type.\nThe [(esprima) AST explorer][ast-explorer] is an online tool to inspect the AST\nfor a given piece of JS code.\n\n#### Path objects\n\nRecast itself relies heavily on [ast-types][] which defines methods to traverse\nthe AST, access node fields and build new nodes. ast-types wraps every AST node\ninto a *path object*. Paths contain meta-information and helper methods to\nprocess AST nodes.\n\nFor example, the child-parent relationship between two nodes is not explicitly\ndefined. Given a plain AST node, it is not possible to traverse the tree *up*.\nGiven a path object however, the parent can be traversed to via `path.parent`.\n\nFor more information about the path object API, please have a look at\n[ast-types][].\n\n#### Builders\n\nTo make creating AST nodes a bit simpler and \"safer\", ast-types defines a couple\nof *builder methods*, which are also exposed on `jscodeshift`.\n\nFor example, the following creates an AST equivalent to `foo(bar)`:\n\n```js\n// inside a module transform\nvar j = jscodeshift;\n// foo(bar);\nvar ast = j.callExpression(\n  j.identifier('foo'),\n  [j.identifier('bar')]\n);\n```\n\nThe signature of each builder function is best learned by having a look at the\n[definition files](https://github.com/benjamn/ast-types/blob/master/def/).\n\n### Collections and Traversal\n\nIn order to transform the AST, you have to traverse it and find the nodes that\nneed to be changed. jscodeshift is built around the idea of **collections** of\npaths and thus provides a different way of processing an AST than recast or\nast-types.\n\nA collection has methods to process the nodes inside a collection, often\nresulting in a new collection. This results in a fluent interface, which can\nmake the transform more readable.\n\nCollections are \"typed\" which means that the type of a collection is the\n\"lowest\" type all AST nodes in the collection have in common. That means you\ncannot call a method for a `FunctionExpression` collection on a `Identifier`\ncollection.\n\nHere is an example of how one would find/traverse all `Identifier` nodes with\njscodeshift and with recast:\n\n```js\n// recast\nvar ast = recast.parse(src);\nrecast.visit(ast, {\n  visitIdentifier: function(path) {\n    // do something with path\n    return false;\n  }\n});\n\n// jscodeshift\njscodeshift(src)\n  .find(jscodeshift.Identifier)\n  .forEach(function(path) {\n    // do something with path\n  });\n```\n\nTo learn about the provided methods, have a look at the\n[Collection.js](src/Collection.js) and its [extensions](src/collections/).\n\n### Extensibility\n\njscodeshift provides an API to extend collections. By moving common operators\ninto helper functions (which can be stored separately in other modules), a\ntransform can be made more readable.\n\nThere are two types of extensions: generic extensions and type-specific\nextensions. **Generic extensions** are applicable to all collections. As such,\nthey typically don't access specific node data, but rather traverse the AST from\nthe nodes in the collection. **Type-specific** extensions work only on specific\nnode types and are not callable on differently typed collections.\n\n#### Examples\n\n```js\n// Adding a method to all Identifiers\njscodeshift.registerMethods({\n\tlogNames: function() {\n\t\treturn this.forEach(function(path) {\n\t\t\tconsole.log(path.node.name);\n\t\t});\n\t}\n}, jscodeshift.Identifier);\n\n// Adding a method to all collections\njscodeshift.registerMethods({\n\tfindIdentifiers: function() {\n\t\treturn this.find(jscodeshift.Identifier);\n\t}\n});\n\njscodeshift(ast).findIdentifiers().logNames();\njscodeshift(ast).logNames(); // error, unless `ast` only consists of Identifier nodes\n```\n\n### Passing options to [recast]\n\nYou may want to change some of the output settings (like setting `'` instead of `\"`).\nThis can be done by passing config options to [recast].\n\n```js\n.toSource({quote: 'single'}); // sets strings to use single quotes in transformed code.\n```\n\nMore on config options [here](https://github.com/benjamn/recast/blob/52a7ec3eaaa37e78436841ed8afc948033a86252/lib/options.js#L61)\n\n### Unit Testing\n\njscodeshift comes with a simple utility to allow easy unit testing with [Jest](https://facebook.github.io/jest/), without having to write a lot of boilerplate code. This utility makes some assumptions in order to reduce the amount of configuration required:\n\n - The test is located in a subdirectory under the directory the transform itself is located in (eg. `__tests__`)\n - Test fixtures are located in a `__testfixtures__` directory\n\nThis results in a directory structure like this:\n```\n/MyTransform.js\n/__tests__/MyTransform-test.js\n/__testfixtures__/MyTransform.input.js\n/__testfixtures__/MyTransform.output.js\n```\n\nTo define a test, use `defineTest` from the `testUtils` module:\n\n```js\njest.autoMockOff();\nconst defineTest = require('jscodeshift/dist/testUtils').defineTest;\ndefineTest(__dirname, 'MyTransform');\n```\n\nAn alternate fixture filename can be provided as the fourth argument to `defineTest`. This also means that multiple test fixtures can be provided:\n```js\ndefineTest(__dirname, 'MyTransform', null, 'FirstFixture');\ndefineTest(__dirname, 'MyTransform', null, 'SecondFixture');\n```\nThis will run two tests: One for `__testfixtures__/FirstFixture.input.js` and one for `__testfixtures__/SecondFixture.input.js`\n\n\nA simple example is bundled in the [sample directory](sample).\n\n\n### Example Codemods\n\n- [react-codemod](https://github.com/reactjs/react-codemod) - React codemod scripts to update React APIs.\n- [js-codemod](https://github.com/cpojer/js-codemod/) - Codemod scripts to transform code to next generation JS.\n- [js-transforms](https://github.com/jhgg/js-transforms) - Some documented codemod experiments to help you learn.\n\n### Support\n\n* Discord - [#codemod](https://discordapp.com/channels/102860784329052160/103748721107292160) on [Reactiflux](http://www.reactiflux.com/)\n\n[npm]: https://www.npmjs.com/\n[Mozilla Parser API]: https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API\n[recast]: https://github.com/benjamn/recast\n[ast-types]: https://github.com/benjamn/ast-types\n[ast-explorer]: http://astexplorer.net/\n[nomnom]: https://www.npmjs.com/package/nomnom\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/facebook/jscodeshift.git"
  },
  "scripts": {
    "build": "rm -rf dist; babel src/ --out-dir dist/",
    "prepublish": "npm run test && npm run build",
    "test": " npm run build && jest",
    "watch": "babel src/ --out-dir dist/ --watch"
  },
  "version": "0.3.20"
}
