add move zsh completions
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	modified:   .radarerc
#	new file:   .vim/syntax/calt.vim
#	new file:   .zsh.d/completions/_r2
#	new file:   .zsh.d/completions/_rabin2
#	new file:   .zsh.d/completions/_radiff2
#	new file:   .zsh.d/completions/_rafind2
#	new file:   .zsh.d/completions/_ragg2
#	new file:   .zsh.d/completions/_ragg2-cc
#	new file:   .zsh.d/completions/_rahash2
#	new file:   .zsh.d/completions/_rasm2
#	new file:   .zsh.d/completions/_rax2
#	new file:   .zsh.d/completions/enabled/_r2
#	new file:   .zsh.d/completions/enabled/_rabin2
#	new file:   .zsh.d/completions/enabled/_radiff2
#	new file:   .zsh.d/completions/enabled/_rafind2
#	new file:   .zsh.d/completions/enabled/_ragg2
#	new file:   .zsh.d/completions/enabled/_ragg2-cc
#	new file:   .zsh.d/completions/enabled/_rahash2
#	new file:   .zsh.d/completions/enabled/_rasm2
#	new file:   .zsh.d/completions/enabled/_rax2
#	new file:   .zsh.d/zsdoc/.zshenv.adoc
#	new file:   .zsh.d/zsdoc/.zshrc.adoc
#	new file:   .zsh.d/zsdoc/.zwidgets.adoc
#	new file:   .zsh.d/zsdoc/data/autoload/.zshrc/_systemctl
#	new file:   .zsh.d/zsdoc/data/autoload/.zshrc/bashcompinit
#	new file:   .zsh.d/zsdoc/data/autoload/.zshrc/colors
#	new file:   .zsh.d/zsdoc/data/autoload/.zshrc/compinit
#	new file:   .zsh.d/zsdoc/data/autoload/.zshrc/promptinit
#	new file:   .zsh.d/zsdoc/data/autoload/.zshrc/vcs_info
#	new file:   .zsh.d/zsdoc/data/bodies/.zshenv
#	new file:   .zsh.d/zsdoc/data/bodies/.zshrc
#	new file:   .zsh.d/zsdoc/data/bodies/.zwidgets
#	new file:   .zsh.d/zsdoc/data/descriptions/.zwidgets/=
#	new file:   .zsh.d/zsdoc/data/descriptions/.zwidgets/check_last_exit_code
#	new file:   .zsh.d/zsdoc/data/descriptions/.zwidgets/fzf-locate-widget
#	new file:   .zsh.d/zsdoc/data/descriptions/.zwidgets/git_prompt_string
#	new file:   .zsh.d/zsdoc/data/descriptions/.zwidgets/insert-x-selection
#	new file:   .zsh.d/zsdoc/data/descriptions/.zwidgets/news_short
#	new file:   .zsh.d/zsdoc/data/descriptions/.zwidgets/parse_git_branch
#	new file:   .zsh.d/zsdoc/data/descriptions/.zwidgets/parse_git_state
#	new file:   .zsh.d/zsdoc/data/descriptions/.zwidgets/setescapes
#	new file:   .zsh.d/zsdoc/data/descriptions/.zwidgets/zshreadhist
#	new file:   .zsh.d/zsdoc/data/extended/.zshenv
#	new file:   .zsh.d/zsdoc/data/extended/.zshrc
#	new file:   .zsh.d/zsdoc/data/extended/.zwidgets
#	new file:   .zsh.d/zsdoc/data/features/.zshenv/Script_Body_/export
#	new file:   .zsh.d/zsdoc/data/features/.zshrc/Script_Body_/alias
#	new file:   .zsh.d/zsdoc/data/features/.zshrc/Script_Body_/autoload
#	new file:   .zsh.d/zsdoc/data/features/.zshrc/Script_Body_/bindkey
#	new file:   .zsh.d/zsdoc/data/features/.zshrc/Script_Body_/eval
#	new file:   .zsh.d/zsdoc/data/features/.zshrc/Script_Body_/export
#	new file:   .zsh.d/zsdoc/data/features/.zshrc/Script_Body_/read
#	new file:   .zsh.d/zsdoc/data/features/.zshrc/Script_Body_/trap
#	new file:   .zsh.d/zsdoc/data/features/.zshrc/Script_Body_/type
#	new file:   .zsh.d/zsdoc/data/features/.zshrc/Script_Body_/unalias
#	new file:   .zsh.d/zsdoc/data/features/.zshrc/Script_Body_/zle
#	new file:   .zsh.d/zsdoc/data/features/.zshrc/Script_Body_/zmodload
#	new file:   .zsh.d/zsdoc/data/features/.zshrc/Script_Body_/zstyle
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/cleanup/read
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/fzf-locate-widget/zle
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/setescapes/eval
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-backwards-delete-to-char/read
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-backwards-zap-to-char/read
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-compdef/zle
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-emacs-keymap/bindkey
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-fman/zle
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-keymap-select/zle
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-less/eval
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-less/zle
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-line-finish/zle
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-line-init/zle
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-toggle-keymap/bindkey
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-toggle-keymap/zle
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-vi-keymap/bindkey
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-vim/eval
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-vim/zle
#	new file:   .zsh.d/zsdoc/data/features/.zwidgets/zle-zaw-help/zle
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/=
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/append-x-selection
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/check_last_exit_code
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/cleanup
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/fzf-locate-widget
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/git_prompt_string
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/insert-x-selection
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/news_long
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/news_short
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/parse_git_branch
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/parse_git_state
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/setescapes
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/yank-x-selection
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-backwards-delete-to-char
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-backwards-zap-to-char
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-compdef
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-emacs-keymap
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-fh
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-fman
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-keymap-select
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-less
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-line-finish
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-line-init
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-toggle-keymap
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-vi-keymap
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-vim
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-youtube-helper
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zle-zaw-help
#	new file:   .zsh.d/zsdoc/data/functions/.zwidgets/zshreadhist
#	new file:   bash_autocompletion.sh
#	modified:   gtk-3.0/bookmarks
#	modified:   man/man7/cepl.7
#	new file:   maxp.pa
#	modified:   vimrc
#
# ------------------------ >8 ------------------------
# Do not touch the line above.
# Everything below will be removed.
diff --git a/.radarerc b/.radarerc
index d9f919c36..74a3b4f86 100644
--- a/.radarerc
+++ b/.radarerc
@@ -1,4 +1,19 @@
-e scr.color=1    ; enable color screen
-e file.id=1      ; identify files when opened
-e file.flag=1    ; automatically add bookmarks (flags) to syms, strings..
-e file.analyze=1 ; perform basic code analysis
+; enable color screen
+e scr.color = 1
+; identify files when opened
+e file.id = 1
+; automatically add bookmarks (flags) to syms, strings..
+e file.flag = 1
+; perform basic code analysis
+e file.analyze = 1
+; entry breakpoint
+e dbg.bep = main
+; e dbg.bep = entry
+; e dbg.bep = loader
+; asm style
+asm.syntax = att
+; asm.syntax = intel
+; enables or disables "fortune" messages displayed at each radare start
+cfg.fortunes = 1
+
+; vi:ft=lisp:
diff --git a/.vim/syntax/calt.vim b/.vim/syntax/calt.vim
new file mode 100644
index 000000000..7a58ae712
--- /dev/null
+++ b/.vim/syntax/calt.vim
@@ -0,0 +1,466 @@
+" Vim syntax file
+" Language:	C
+" Maintainer:	Bram Moolenaar <Bram@vim.org>
+" Last Change:	2013 Jul 05
+
+" Quit when a (custom) syntax file was already loaded
+if exists("b:current_syntax")
+  finish
+endif
+
+let s:cpo_save = &cpo
+set cpo&vim
+
+let s:ft = matchstr(&ft, '^\([^.]\)\+')
+
+" A bunch of useful C keywords
+syn keyword	cStatement	goto break return continue asm
+syn keyword	cLabel		case default
+syn keyword	cConditional	if else switch
+syn keyword	cRepeat		while for do
+
+syn keyword	cTodo		contained TODO FIXME XXX
+
+" It's easy to accidentally add a space after a backslash that was intended
+" for line continuation.  Some compilers allow it, which makes it
+" unpredictable and should be avoided.
+syn match	cBadContinuation contained "\\\s\+$"
+
+" cCommentGroup allows adding matches for special things in comments
+syn cluster	cCommentGroup	contains=cTodo,cBadContinuation
+
+" String and Character constants
+" Highlight special characters (those which have a backslash) differently
+syn match	cSpecial	display contained "\\\(x\x\+\|\o\{1,3}\|.\|$\)"
+if !exists("c_no_utf")
+  syn match	cSpecial	display contained "\\\(u\x\{4}\|U\x\{8}\)"
+endif
+if exists("c_no_cformat")
+  syn region	cString		start=+L\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,@Spell extend
+  " cCppString: same as cString, but ends at end of line
+  if !exists("cpp_no_cpp11") " ISO C++11
+    syn region cCppString	start=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
+  else
+    syn region cCppString	start=+L\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
+  endif
+  syn region	cCppOut2	contained start="0" end="^\s*\(%:\|#\)\s*\(endif\>\|else\>\|elif\>\)" contains=cSpaceError,cCppSkip
+  syn region	cCppSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppSkip
+else
+  if !exists("c_no_c99") " ISO C99
+    syn match	cFormat		display "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlLjzt]\|ll\|hh\)\=\([aAbdiuoxXDOUfFeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
+  else
+    syn match	cFormat		display "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlL]\|ll\)\=\([bdiuoxXDOUfeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
+  endif
+  syn match	cFormat		display "%%" contained
+  syn region	cString		start=+L\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
+  " cCppString: same as cString, but ends at end of line
+  syn region	cCppString	start=+L\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
+endif
+
+syn match	cCharacter	"L\='[^\\]'"
+syn match	cCharacter	"L'[^']*'" contains=cSpecial
+if exists("c_gnu")
+  syn match	cSpecialError	"L\='\\[^'\"?\\abefnrtv]'"
+  syn match	cSpecialCharacter "L\='\\['\"?\\abefnrtv]'"
+else
+  syn match	cSpecialError	"L\='\\[^'\"?\\abfnrtv]'"
+  syn match	cSpecialCharacter "L\='\\['\"?\\abfnrtv]'"
+endif
+syn match	cSpecialCharacter display "L\='\\\o\{1,3}'"
+syn match	cSpecialCharacter display "'\\x\x\{1,2}'"
+syn match	cSpecialCharacter display "L'\\x\x\+'"
+
+if !exists("c_no_c11") " ISO C11
+  if exists("c_no_cformat")
+    syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,@Spell extend
+  else
+    syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
+  endif
+  syn match	cCharacter	"[Uu]'[^\\]'"
+  syn match	cCharacter	"[Uu]'[^']*'" contains=cSpecial
+  if exists("c_gnu")
+    syn match	cSpecialError	"[Uu]'\\[^'\"?\\abefnrtv]'"
+    syn match	cSpecialCharacter "[Uu]'\\['\"?\\abefnrtv]'"
+  else
+    syn match	cSpecialError	"[Uu]'\\[^'\"?\\abfnrtv]'"
+    syn match	cSpecialCharacter "[Uu]'\\['\"?\\abfnrtv]'"
+  endif
+  syn match	cSpecialCharacter display "[Uu]'\\\o\{1,3}'"
+  syn match	cSpecialCharacter display "[Uu]'\\x\x\+'"
+endif
+
+"when wanted, highlight trailing white space
+if exists("c_space_errors")
+  if !exists("c_no_trail_space_error")
+    syn match	cSpaceError	display excludenl "\s\+$"
+  endif
+  if !exists("c_no_tab_space_error")
+    syn match	cSpaceError	display " \+\t"me=e-1
+  endif
+endif
+
+" This should be before cErrInParen to avoid problems with #define ({ xxx })
+if exists("c_curly_error")
+  syn match cCurlyError "}"
+  syn region	cBlock		start="{" end="}" contains=ALLBUT,cBadBlock,cCurlyError,@cParenGroup,cErrInParen,cCppParen,cErrInBracket,cCppBracket,cCppString,@Spell fold
+else
+  syn region	cBlock		start="{" end="}" transparent fold
+endif
+
+"catch errors caused by wrong parenthesis and brackets
+" also accept <% for {, %> for }, <: for [ and :> for ] (C99)
+" But avoid matching <::.
+syn cluster	cParenGroup	contains=cParenError,cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserLabel,cBitField,cOctalZero,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom
+if exists("c_no_curly_error")
+  if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
+    syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,cCppString,@Spell
+    " cCppParen: same as cParen but ends at end-of-line; used in cDefine
+    syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
+    syn match	cParenError	display ")"
+    syn match	cErrInParen	display contained "^^<%\|^%>"
+  else
+    syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,cCppString,@Spell
+    " cCppParen: same as cParen but ends at end-of-line; used in cDefine
+    syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
+    syn match	cParenError	display ")"
+    syn match	cErrInParen	display contained "^[{}]\|^<%\|^%>"
+  endif
+elseif exists("c_no_bracket_error")
+  if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
+    syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,cCppString,@Spell
+    " cCppParen: same as cParen but ends at end-of-line; used in cDefine
+    syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
+    syn match	cParenError	display ")"
+    syn match	cErrInParen	display contained "<%\|%>"
+  else
+    syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,cCppString,@Spell
+    " cCppParen: same as cParen but ends at end-of-line; used in cDefine
+    syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
+    syn match	cParenError	display ")"
+    syn match	cErrInParen	display contained "[{}]\|<%\|%>"
+  endif
+else
+  if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
+    syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,cCppString,@Spell
+    " cCppParen: same as cParen but ends at end-of-line; used in cDefine
+    syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
+    syn match	cParenError	display "[\])]"
+    syn match	cErrInParen	display contained "<%\|%>"
+    syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' contains=ALLBUT,@cParenGroup,cErrInParen,cCppParen,cCppBracket,cCppString,@Spell
+  else
+    syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,cCppString,@Spell
+    " cCppParen: same as cParen but ends at end-of-line; used in cDefine
+    syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
+    syn match	cParenError	display "[\])]"
+    syn match	cErrInParen	display contained "[\]{}]\|<%\|%>"
+    syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cErrInParen,cCppParen,cCppBracket,cCppString,@Spell
+  endif
+  " cCppBracket: same as cParen but ends at end-of-line; used in cDefine
+  syn region	cCppBracket	transparent start='\[\|<::\@!' skip='\\$' excludenl end=']\|:>' end='$' contained contains=ALLBUT,@cParenGroup,cErrInParen,cParen,cBracket,cString,@Spell
+  syn match	cErrInBracket	display contained "[);{}]\|<%\|%>"
+endif
+
+if s:ft ==# 'c' || exists("cpp_no_cpp11")
+  syn region	cBadBlock	keepend start="{" end="}" contained containedin=cParen,cBracket,cBadBlock transparent fold
+endif
+
+"integer number, or floating point number without a dot and with "f".
+syn case ignore
+syn match	cNumbers	display transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctalError,cOctal
+" Same, but without octal error (for comments)
+syn match	cNumbersCom	display contained transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctal
+syn match	cNumber		display contained "\d\+\(u\=l\{0,2}\|ll\=u\)\>"
+"hex number
+syn match	cNumber		display contained "0x\x\+\(u\=l\{0,2}\|ll\=u\)\>"
+" Flag the first zero of an octal number as something special
+syn match	cOctal		display contained "0\o\+\(u\=l\{0,2}\|ll\=u\)\>" contains=cOctalZero
+syn match	cOctalZero	display contained "\<0"
+syn match	cFloat		display contained "\d\+f"
+"floating point number, with dot, optional exponent
+syn match	cFloat		display contained "\d\+\.\d*\(e[-+]\=\d\+\)\=[fl]\="
+"floating point number, starting with a dot, optional exponent
+syn match	cFloat		display contained "\.\d\+\(e[-+]\=\d\+\)\=[fl]\=\>"
+"floating point number, without dot, with exponent
+syn match	cFloat		display contained "\d\+e[-+]\=\d\+[fl]\=\>"
+if !exists("c_no_c99")
+  "hexadecimal floating point number, optional leading digits, with dot, with exponent
+  syn match	cFloat		display contained "0x\x*\.\x\+p[-+]\=\d\+[fl]\=\>"
+  "hexadecimal floating point number, with leading digits, optional dot, with exponent
+  syn match	cFloat		display contained "0x\x\+\.\=p[-+]\=\d\+[fl]\=\>"
+endif
+
+" flag an octal number with wrong digits
+syn match	cOctalError	display contained "0\o*[89]\d*"
+syn case match
+
+if exists("c_comment_strings")
+  " A comment can contain cString, cCharacter and cNumber.
+  " But a "*/" inside a cString in a cComment DOES end the comment!  So we
+  " need to use a special type of cString: cCommentString, which also ends on
+  " "*/", and sees a "*" at the start of the line as comment again.
+  " Unfortunately this doesn't very well work for // type of comments :-(
+  syn match	cCommentSkip	contained "^\s*\*\($\|\s\+\)"
+  syn region cCommentString	contained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end=+\*/+me=s-1 contains=cSpecial,cCommentSkip
+  syn region cComment2String	contained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end="$" contains=cSpecial
+  syn region  cCommentL	start="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cComment2String,cCharacter,cNumbersCom,cSpaceError,@Spell
+  if exists("c_no_comment_fold")
+    " Use "extend" here to have preprocessor lines not terminate halfway a
+    " comment.
+    syn region cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell extend
+  else
+    syn region cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell fold extend
+  endif
+else
+  syn region	cCommentL	start="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cSpaceError,@Spell
+  if exists("c_no_comment_fold")
+    syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell extend
+  else
+    syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell fold extend
+  endif
+endif
+" keep a // comment separately, it terminates a preproc. conditional
+syn match	cCommentError	display "\*/"
+syn match	cCommentStartError display "/\*"me=e-1 contained
+
+syn keyword	cOperator	sizeof
+if exists("c_gnu")
+  syn keyword	cStatement	__asm__
+  syn keyword	cOperator	typeof __real__ __imag__
+endif
+syn keyword	cType		int long short char void
+syn keyword	cType		signed unsigned float double
+if !exists("c_no_ansi") || exists("c_ansi_typedefs")
+  syn keyword   cType		size_t ssize_t off_t wchar_t ptrdiff_t sig_atomic_t fpos_t
+  syn keyword   cType		clock_t time_t va_list jmp_buf FILE DIR div_t ldiv_t
+  syn keyword   cType		mbstate_t wctrans_t wint_t wctype_t
+endif
+if !exists("c_no_c99") " ISO C99
+  syn keyword	cType		_Bool bool _Complex complex _Imaginary imaginary
+  syn keyword	cType		int8_t int16_t int32_t int64_t
+  syn keyword	cType		uint8_t uint16_t uint32_t uint64_t
+  syn keyword	cType		int_least8_t int_least16_t int_least32_t int_least64_t
+  syn keyword	cType		uint_least8_t uint_least16_t uint_least32_t uint_least64_t
+  syn keyword	cType		int_fast8_t int_fast16_t int_fast32_t int_fast64_t
+  syn keyword	cType		uint_fast8_t uint_fast16_t uint_fast32_t uint_fast64_t
+  syn keyword	cType		intptr_t uintptr_t
+  syn keyword	cType		intmax_t uintmax_t
+endif
+if exists("c_gnu")
+  syn keyword	cType		__label__ __complex__ __volatile__
+endif
+
+syn keyword	cStructure	struct union enum typedef
+syn keyword	cStorageClass	static register auto volatile extern const
+if exists("c_gnu")
+  syn keyword	cStorageClass	inline __attribute__
+endif
+if !exists("c_no_c99")
+  syn keyword	cStorageClass	inline restrict
+endif
+if !exists("c_no_c11")
+  syn keyword	cStorageClass	_Alignas alignas
+  syn keyword	cOperator	_Alignof alignof
+  syn keyword	cStorageClass	_Atomic
+  syn keyword	cOperator	_Generic
+  syn keyword	cStorageClass	_Noreturn noreturn
+  syn keyword	cOperator	_Static_assert static_assert
+  syn keyword	cStorageClass	_Thread_local thread_local
+  syn keyword   cType		char16_t char32_t
+endif
+
+if !exists("c_no_ansi") || exists("c_ansi_constants") || exists("c_gnu")
+  if exists("c_gnu")
+    syn keyword cConstant __GNUC__ __FUNCTION__ __PRETTY_FUNCTION__ __func__
+  endif
+  syn keyword cConstant __LINE__ __FILE__ __DATE__ __TIME__ __STDC__
+  syn keyword cConstant __STDC_VERSION__
+  syn keyword cConstant CHAR_BIT MB_LEN_MAX MB_CUR_MAX
+  syn keyword cConstant UCHAR_MAX UINT_MAX ULONG_MAX USHRT_MAX
+  syn keyword cConstant CHAR_MIN INT_MIN LONG_MIN SHRT_MIN
+  syn keyword cConstant CHAR_MAX INT_MAX LONG_MAX SHRT_MAX
+  syn keyword cConstant SCHAR_MIN SINT_MIN SLONG_MIN SSHRT_MIN
+  syn keyword cConstant SCHAR_MAX SINT_MAX SLONG_MAX SSHRT_MAX
+  if !exists("c_no_c99")
+    syn keyword cConstant __func__
+    syn keyword cConstant LLONG_MIN LLONG_MAX ULLONG_MAX
+    syn keyword cConstant INT8_MIN INT16_MIN INT32_MIN INT64_MIN
+    syn keyword cConstant INT8_MAX INT16_MAX INT32_MAX INT64_MAX
+    syn keyword cConstant UINT8_MAX UINT16_MAX UINT32_MAX UINT64_MAX
+    syn keyword cConstant INT_LEAST8_MIN INT_LEAST16_MIN INT_LEAST32_MIN INT_LEAST64_MIN
+    syn keyword cConstant INT_LEAST8_MAX INT_LEAST16_MAX INT_LEAST32_MAX INT_LEAST64_MAX
+    syn keyword cConstant UINT_LEAST8_MAX UINT_LEAST16_MAX UINT_LEAST32_MAX UINT_LEAST64_MAX
+    syn keyword cConstant INT_FAST8_MIN INT_FAST16_MIN INT_FAST32_MIN INT_FAST64_MIN
+    syn keyword cConstant INT_FAST8_MAX INT_FAST16_MAX INT_FAST32_MAX INT_FAST64_MAX
+    syn keyword cConstant UINT_FAST8_MAX UINT_FAST16_MAX UINT_FAST32_MAX UINT_FAST64_MAX
+    syn keyword cConstant INTPTR_MIN INTPTR_MAX UINTPTR_MAX
+    syn keyword cConstant INTMAX_MIN INTMAX_MAX UINTMAX_MAX
+    syn keyword cConstant PTRDIFF_MIN PTRDIFF_MAX SIG_ATOMIC_MIN SIG_ATOMIC_MAX
+    syn keyword cConstant SIZE_MAX WCHAR_MIN WCHAR_MAX WINT_MIN WINT_MAX
+  endif
+  syn keyword cConstant FLT_RADIX FLT_ROUNDS
+  syn keyword cConstant FLT_DIG FLT_MANT_DIG FLT_EPSILON
+  syn keyword cConstant DBL_DIG DBL_MANT_DIG DBL_EPSILON
+  syn keyword cConstant LDBL_DIG LDBL_MANT_DIG LDBL_EPSILON
+  syn keyword cConstant FLT_MIN FLT_MAX FLT_MIN_EXP FLT_MAX_EXP
+  syn keyword cConstant FLT_MIN_10_EXP FLT_MAX_10_EXP
+  syn keyword cConstant DBL_MIN DBL_MAX DBL_MIN_EXP DBL_MAX_EXP
+  syn keyword cConstant DBL_MIN_10_EXP DBL_MAX_10_EXP
+  syn keyword cConstant LDBL_MIN LDBL_MAX LDBL_MIN_EXP LDBL_MAX_EXP
+  syn keyword cConstant LDBL_MIN_10_EXP LDBL_MAX_10_EXP
+  syn keyword cConstant HUGE_VAL CLOCKS_PER_SEC NULL
+  syn keyword cConstant LC_ALL LC_COLLATE LC_CTYPE LC_MONETARY
+  syn keyword cConstant LC_NUMERIC LC_TIME
+  syn keyword cConstant SIG_DFL SIG_ERR SIG_IGN
+  syn keyword cConstant SIGABRT SIGFPE SIGILL SIGHUP SIGINT SIGSEGV SIGTERM
+  " Add POSIX signals as well...
+  syn keyword cConstant SIGABRT SIGALRM SIGCHLD SIGCONT SIGFPE SIGHUP
+  syn keyword cConstant SIGILL SIGINT SIGKILL SIGPIPE SIGQUIT SIGSEGV
+  syn keyword cConstant SIGSTOP SIGTERM SIGTRAP SIGTSTP SIGTTIN SIGTTOU
+  syn keyword cConstant SIGUSR1 SIGUSR2
+  syn keyword cConstant _IOFBF _IOLBF _IONBF BUFSIZ EOF WEOF
+  syn keyword cConstant FOPEN_MAX FILENAME_MAX L_tmpnam
+  syn keyword cConstant SEEK_CUR SEEK_END SEEK_SET
+  syn keyword cConstant TMP_MAX stderr stdin stdout
+  syn keyword cConstant EXIT_FAILURE EXIT_SUCCESS RAND_MAX
+  " Add POSIX errors as well
+  syn keyword cConstant E2BIG EACCES EAGAIN EBADF EBADMSG EBUSY
+  syn keyword cConstant ECANCELED ECHILD EDEADLK EDOM EEXIST EFAULT
+  syn keyword cConstant EFBIG EILSEQ EINPROGRESS EINTR EINVAL EIO EISDIR
+  syn keyword cConstant EMFILE EMLINK EMSGSIZE ENAMETOOLONG ENFILE ENODEV
+  syn keyword cConstant ENOENT ENOEXEC ENOLCK ENOMEM ENOSPC ENOSYS
+  syn keyword cConstant ENOTDIR ENOTEMPTY ENOTSUP ENOTTY ENXIO EPERM
+  syn keyword cConstant EPIPE ERANGE EROFS ESPIPE ESRCH ETIMEDOUT EXDEV
+  " math.h
+  syn keyword cConstant M_E M_LOG2E M_LOG10E M_LN2 M_LN10 M_PI M_PI_2 M_PI_4
+  syn keyword cConstant M_1_PI M_2_PI M_2_SQRTPI M_SQRT2 M_SQRT1_2
+endif
+if !exists("c_no_c99") " ISO C99
+  syn keyword cConstant true false
+endif
+
+" Accept %: for # (C99)
+syn region	cPreCondit	start="^\s*\(%:\|#\)\s*\(if\|ifdef\|ifndef\|elif\)\>" skip="\\$" end="$" keepend contains=cComment,cCommentL,cCppString,cCharacter,cCppParen,cParenError,cNumbers,cCommentError,cSpaceError
+syn match	cPreConditMatch	display "^\s*\(%:\|#\)\s*\(else\|endif\)\>"
+if !exists("c_no_if0")
+  syn cluster	cCppOutInGroup	contains=cCppInIf,cCppInElse,cCppInElse2,cCppOutIf,cCppOutIf2,cCppOutElse,cCppInSkip,cCppOutSkip
+  syn region	cCppOutWrapper	start="^\s*\(%:\|#\)\s*if\s\+0\+\s*\($\|//\|/\*\|&\)" end=".\@=\|$" contains=cCppOutIf,cCppOutElse,@NoSpell fold
+  syn region	cCppOutIf	contained start="0\+" matchgroup=cCppOutWrapper end="^\s*\(%:\|#\)\s*endif\>" contains=cCppOutIf2,cCppOutElse
+  if !exists("c_no_if0_fold")
+    syn region	cCppOutIf2	contained matchgroup=cCppOutWrapper start="0\+" end="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0\+\s*\($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell fold
+  else
+    syn region	cCppOutIf2	contained matchgroup=cCppOutWrapper start="0\+" end="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0\+\s*\($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
+  endif
+  syn region	cCppOutElse	contained matchgroup=cCppOutWrapper start="^\s*\(%:\|#\)\s*\(else\|elif\)" end="^\s*\(%:\|#\)\s*endif\>"me=s-1 contains=TOP,cPreCondit
+  syn region	cCppInWrapper	start="^\s*\(%:\|#\)\s*if\s\+0*[1-9]\d*\s*\($\|//\|/\*\||\)" end=".\@=\|$" contains=cCppInIf,cCppInElse fold
+  syn region	cCppInIf	contained matchgroup=cCppInWrapper start="\d\+" end="^\s*\(%:\|#\)\s*endif\>" contains=TOP,cPreCondit
+  if !exists("c_no_if0_fold")
+    syn region	cCppInElse	contained start="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0*[1-9]\d*\s*\($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2 fold
+  else
+    syn region	cCppInElse	contained start="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0*[1-9]\d*\s*\($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2
+  endif
+  syn region	cCppInElse2	contained matchgroup=cCppInWrapper start="^\s*\(%:\|#\)\s*\(else\|elif\)\([^/]\|/[^/*]\)*" end="^\s*\(%:\|#\)\s*endif\>"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
+  syn region	cCppOutSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppOutSkip
+  syn region	cCppInSkip	contained matchgroup=cCppInWrapper start="^\s*\(%:\|#\)\s*\(if\s\+\(\d\+\s*\($\|//\|/\*\||\|&\)\)\@!\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" containedin=cCppOutElse,cCppInIf,cCppInSkip contains=TOP,cPreProc
+endif
+syn region	cIncluded	display contained start=+"+ skip=+\\\\\|\\"+ end=+"+
+syn match	cIncluded	display contained "<[^>]*>"
+syn match	cInclude	display "^\s*\(%:\|#\)\s*include\>\s*["<]" contains=cIncluded
+"syn match cLineSkip	"\\$"
+syn cluster	cPreProcGroup	contains=cPreCondit,cIncluded,cInclude,cDefine,cErrInParen,cErrInBracket,cUserLabel,cSpecial,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cString,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cParen,cBracket,cMulti,cBadBlock
+syn region	cDefine		start="^\s*\(%:\|#\)\s*\(define\|undef\)\>" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
+syn region	cPreProc	start="^\s*\(%:\|#\)\s*\(pragma\>\|line\>\|warning\>\|warn\>\|error\>\)" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
+
+" Highlight User Labels
+syn cluster	cMultiGroup	contains=cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserCont,cUserLabel,cBitField,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cCppParen,cCppBracket,cCppString
+if s:ft ==# 'c' || exists("cpp_no_cpp11")
+  syn region	cMulti		transparent start='?' skip='::' end=':' contains=ALLBUT,@cMultiGroup,@Spell
+endif
+" Avoid matching foo::bar() in C++ by requiring that the next char is not ':'
+syn cluster	cLabelGroup	contains=cUserLabel
+syn match	cUserCont	display "^\s*\I\i*\s*:$" contains=@cLabelGroup
+syn match	cUserCont	display ";\s*\I\i*\s*:$" contains=@cLabelGroup
+syn match	cUserCont	display "^\s*\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
+syn match	cUserCont	display ";\s*\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
+
+syn match	cUserLabel	display "\I\i*" contained
+
+" Avoid recognizing most bitfields as labels
+syn match	cBitField	display "^\s*\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
+syn match	cBitField	display ";\s*\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
+
+if exists("c_minlines")
+  let b:c_minlines = c_minlines
+else
+  if !exists("c_no_if0")
+    let b:c_minlines = 50	" #if 0 constructs can be long
+  else
+    let b:c_minlines = 15	" mostly for () constructs
+  endif
+endif
+if exists("c_curly_error")
+  syn sync fromstart
+else
+  exec "syn sync ccomment cComment minlines=" . b:c_minlines
+endif
+
+" Define the default highlighting.
+" Only used when an item doesn't have highlighting yet
+hi def link cFormat		cSpecial
+hi def link cCppString		cString
+hi def link cCommentL		cComment
+hi def link cCommentStart	cComment
+hi def link cLabel		Label
+hi def link cUserLabel		Label
+hi def link cConditional	Conditional
+hi def link cRepeat		Repeat
+hi def link cCharacter		Character
+hi def link cSpecialCharacter	cSpecial
+hi def link cNumber		Number
+hi def link cOctal		Number
+hi def link cOctalZero		PreProc	 " link this to Error if you want
+hi def link cFloat		Float
+hi def link cOctalError		cError
+hi def link cParenError		cError
+hi def link cErrInParen		cError
+hi def link cErrInBracket	cError
+hi def link cCommentError	cError
+hi def link cCommentStartError	cError
+hi def link cSpaceError		cError
+hi def link cSpecialError	cError
+hi def link cCurlyError		cError
+hi def link cOperator		Operator
+hi def link cStructure		Structure
+hi def link cStorageClass	StorageClass
+hi def link cInclude		Include
+hi def link cPreProc		PreProc
+hi def link cDefine		Macro
+hi def link cIncluded		cString
+hi def link cError		Error
+hi def link cStatement		Statement
+hi def link cCppInWrapper	cCppOutWrapper
+hi def link cCppOutWrapper	cPreCondit
+hi def link cPreConditMatch	cPreCondit
+hi def link cPreCondit		PreCondit
+hi def link cType		Type
+hi def link cConstant		Constant
+hi def link cCommentString	cString
+hi def link cComment2String	cString
+hi def link cCommentSkip	cComment
+hi def link cString		String
+hi def link cComment		Comment
+hi def link cSpecial		SpecialChar
+hi def link cTodo		Todo
+hi def link cBadContinuation	Error
+hi def link cCppOutSkip		cCppOutIf2
+hi def link cCppInElse2		cCppOutIf2
+hi def link cCppOutIf2		cCppOut2  " Old syntax group for #if 0 body
+hi def link cCppOut2		cCppOut  " Old syntax group for #if of #if 0
+hi def link cCppOut		Comment
+
+let b:current_syntax = "c"
+
+unlet s:ft
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+" vim: ts=8
diff --git a/.zsh.d/completions/_r2 b/.zsh.d/completions/_r2
new file mode 100644
index 000000000..777151c11
--- /dev/null
+++ b/.zsh.d/completions/_r2
@@ -0,0 +1,87 @@
+#compdef r2
+local context state state_descr line
+local -i ret=1
+
+r2_qc() {
+  r2 -qc $1 --
+}
+
+_r2() {
+  local -a options=(
+  '-\=[perform !=! command to run all commands remotely]'
+  '-0[print \x00 after init and every command]'
+  '-a+[set asm.arch]: :->arch'
+  "-A[run 'aaa' command to analyze all referenced code]"
+  '-b+[set asm.bits]:bits:(8 16 32 64)'
+  '-B+[set base address for PIE binaries]:baddr'
+  '-c+[execute radare command]:cmd'
+  '-C[file is host:port (alias for -c+=http://%s/cmd/)]'
+  "-d[debug the executable 'file' or running process 'pid']"
+  '-D+[enable debug mode (e cfg.debug=true)]: :->dbg.backend'
+  '-e+[evaluate config var]: :->config'
+  '-f[block size = file size]'
+  '-F+[force to use that rbin plugin]:binplug'
+  '(-h -hh)-h[show help message]'
+  '(-h -hh)-hh[show long help message]'
+  '-H[display variable]'
+  '-i+[run script file]:script:_files'
+  '-I+[run script file before the file is opened]:script:_files'
+  '-k+[set asm.os (linux, macos, w32, netbsd, ...)]: :->asm.os'
+  '-l+[load plugin file]:lib:_files'
+  '-L[list supported IO plugins]'
+  '-m+[map file at given address (loadaddr)]:addr'
+  '-M[do not demangle symbol names]'
+  '(-n -nn)-n[do not load RBin info]'
+  '(-n -nn)-nn[only load bin structures]'
+  '-N[do not load user settings and scripts]'
+  '(-q -Q)-q[quiet mode (no prompt) and quit after -i]'
+  '(-q -Q)-Q[quiet mode (no prompt) and quit faster (quietLeak=true)]'
+  '-p+[use project, list if no arg, load if no file]: :->project'
+  '-P+[apply rapatch file and quit]:rapatch:_files'
+  '-r+[specify rarun2 profile to load (same as -e dbg.profile=X)]:dbg.profile'
+  '-R+[specify custom rarun2 directive]:rr2rule'
+  '-s+[initial seek]:addr'
+  '-S[start r2 in sandbox mode]'
+  '-t[load rabin2 info in thread]'
+  '-u[set bin.filter=false to get raw sym/sec/cls names]'
+  '(-v -V)-v[show radare2 version]'
+  '(-v -V)-V[show radare2 and lib versions)]'
+  '-w[open file in write mode]'
+  '(-z -zz)-z[do not load strings]'
+  '(-z -zz)-zz[load strings from raw binary (even if unknown)]'
+  )
+
+  _arguments -S -s : $options '1:file:_files' && ret=0
+
+  case $state in
+    arch)
+      local -a sub=(${(f)"$(r2_qc 'e asm.arch=?~[2,4-99]' | sed -E 's/ (.*)/[\1]/')"})
+      _values 'arch' $sub && ret=0
+      ;;
+    asm.os)
+      _values 'asm.os' $(r2_qc 'e asm.os=?') && ret=0
+      ;;
+    config)
+      local -a sub=(${(f)"$(r2_qc 'e??' | sed -E -e 's/\[/\\[/g' -e 's/]/\\]/g' -e 's/\s*([^:]+): (.*)/\1[\2]:value:/')"})
+      _values 'config var' $sub && ret=0
+      ;;
+    dbg.backend)
+      _values 'dbg.backend' $(r2 '-D?') && ret=0
+      ;;
+    project)
+      _values 'project' $(r2 -p) && ret=0
+      ;;
+  esac
+  return ret
+}
+
+_r2 "$@"
+
+# Local Variables:
+# mode: shell-script
+# coding: utf-8-unix
+# indent-tabs-mode: nil
+# sh-indentation: 2
+# sh-basic-offset: 2
+# End:
+# vim: ft=zsh sw=2 sts=2 et
diff --git a/.zsh.d/completions/_rabin2 b/.zsh.d/completions/_rabin2
new file mode 100644
index 000000000..2af6d236b
--- /dev/null
+++ b/.zsh.d/completions/_rabin2
@@ -0,0 +1,90 @@
+#compdef rabin2
+local context state state_descr line
+local -i ret=1
+
+r2_qc() {
+  r2 -qc $1 --
+}
+
+_rabin2() {
+  local -a options=(
+  '-@+[show section, symbol or import at addr]:addr'
+  '-A[list sub-binaries and their arch-bits pairs]'
+  '-a+[set arch (x86, arm, .. or <arch>_<bits>)]: :->arch'
+  '-b+[set bits (32, 64 ...)]:bits:(8 16 32 64)'
+  '-B+[override base address (pie bins)]:addr'
+  '-c[list classes]'
+  '-C[create \[elf,mach0,pe\] with Code and Data hexpairs (see -a)]:fmt\:C\:D'
+  '-d[show debug/dwarf information]'
+  '-D+[demangle symbol name (-D all for bin.demangle=true)]:language'
+  '-e[entrypoint]'
+  '-E[globally exportable symbols]'
+  '-f+[select sub-bin named str]:str'
+  '-F+[force to use that bin plugin (ignore header check)]:binfmt'
+  '-g[same as -SMZIHVResizcld (show all info)]'
+  '-G+[load address . offset to header]:addr'
+  '-h[this help message]'
+  '-H[header fields]'
+  '-i[imports (symbols imported from libraries)]'
+  '-I[binary info]'
+  '(-j -q -qq -r)-j[output in json]'
+  "-k+[run sdb query. for example: '*']:sdb-query"
+  '-K+[calculate checksums (md5, sha1, ..)]: :->checksum'
+  '-l[linked libraries]'
+  '-L[list supported bin plugins or plugin details]: :->plugin'
+  '-m+[show source line at addr]:addr'
+  '-M[main (show address of main symbol)]'
+  '-n+[show section, symbol or import named str]:str'
+  '-N[force min:max number of chars per string (see -z and -zz)]:min\:max'
+  '-o+[output file/folder for write operations (out by default)]:_files'
+  '-O+[write/extract operations (-O help)]:str'
+  '-p[show physical addresses]'
+  '(-P -PP)-P[show debug/pdb information]'
+  '(-P -PP)-PP[download pdb file for binary]'
+  '(-j -q -qq -r)-q[be quiet, just show fewer data]'
+  '(-j -q -qq -r)-qq[show less info (no offset/size for -z for ex.)]'
+  '-Q[show load address used by dlopen (non-aslr libs)]'
+  '-r[radare output]'
+  '-R[relocations]'
+  '-s[symbols]'
+  '-S[sections]'
+  '-u[unfiltered (no rename duplicated symbols/sections)]'
+  '-U[resoUrces]'
+  '-v[display version and quit]'
+  '-V[Show binary version information]'
+  '-x[extract bins contained in file]'
+  '-X+[\[f\] .. package in fat or zip the given files and bins contained in file]:fmt'
+  '(-z -zz -zzz)-z[strings (from data section)]'
+  '(-z -zz -zzz)-zz[strings (from raw bins \[e bin.rawstr=1\])]'
+  '(-z -zz -zzz)-zzz[dump raw strings to stdout (for huge files)]'
+  '-Z[guess size of binary program]'
+  )
+
+  _arguments -S -s : $options '*:file:_files' && ret=0
+
+  case $state in
+    arch)
+      local -a sub=(${(f)"$(r2_qc 'e asm.arch=?~[2,4-99]' | sed -E 's/ (.*)/[\1]/')"})
+      _values 'arch' $sub && ret=0
+      ;;
+    checksum)
+      _values 'checksum' all $(r2_qc 'ph?') && ret=0
+      ;;
+    plugin)
+      local -a sub=(${(f)"$(rabin2 -L | grep '^bin ' | sed -E 's/bin +([^ ]+) +(.*)/\1[\2]/')"})
+      _values 'plugin' $sub && ret=0
+      ;;
+  esac
+  return ret
+}
+
+_rabin2 "$@"
+
+# Local Variables:
+# mode: shell-script
+# coding: utf-8-unix
+# indent-tabs-mode: nil
+# sh-indentation: 2
+# sh-basic-offset: 2
+# End:
+# vim: ft=zsh sw=2 sts=2 et
diff --git a/.zsh.d/completions/_radiff2 b/.zsh.d/completions/_radiff2
new file mode 100644
index 000000000..68a8f62a8
--- /dev/null
+++ b/.zsh.d/completions/_radiff2
@@ -0,0 +1,61 @@
+#compdef radiff2
+local context state state_descr line
+local -i ret=1
+
+r2_qc() {
+  r2 -qc $1 --
+}
+
+_radiff2() {
+  local -a options=(
+  '-a[specify architecture plugin to use (x86, arm, ..)]: :->arch'
+  '(-A -AA)-A[run aaa after loading each binary (see -C)]'
+  '(-A -AA)-AA[run aaaa after loading each binary (see -C)]'
+  '-b+[specify register size for arch (16 (thumb), 32, 64, ..)]:bits:(8 16 32 64)'
+  '-c[count of changes]'
+  '(-C -g -i)-C[graphdiff code (columns: off-A, match-ratio, off-B) (see -A)]'
+  '-d[use delta diffing]'
+  '-D[show disasm instead of hexpairs]'
+  '-e+[set eval config var value for all RCore instances]:config'
+  '(-C -g -i)-g+[graph diff of given symbol, or between two offsets]:sym|off1,off2'
+  '-G+[run an r2 command on every RCore instance created]:cmd'
+  '(-C -g -i)-i[diff imports of target files (see -u, -U and -z)]'
+  '(-j -r -u -U)-j[output in json format]'
+  '-n[print bare addresses only (diff.bare=1)]'
+  '-O[code diffing with opcode bytes only]'
+  '-p[use physical addressing (io.va=0)]'
+  '-q[quiet mode (disable colors, reduce output)]'
+  '(-j -r -u -U)-r[output in radare commands]'
+  '(-s -ss)-s[compute text distance]'
+  '(-s -ss)-ss[compute text distance (using levenstein algorithm)]'
+  '-S+[sort code diff (name, namelen, addr, size, type, dist) (only for -C or -g)]:sort:(addr dist name namelen size type)'
+  '-t+[set threshold for code diff (default is 70%)]:0-100'
+  '-x[show two column hexdump diffing]'
+  '(-j -r -u -U)-u[unified output (---+++)]'
+  "(-j -r -u -U)-U[unified output using system 'diff']"
+  '-v[show version information]'
+  '-V[be verbose (current only for -s)]'
+  '-z[diff on extracted strings]'
+  )
+
+  _arguments -S -s : $options '1:file:_files' '2:file:_files' && ret=0
+
+  case $state in
+    arch)
+      local -a sub=(${(f)"$(r2_qc 'e asm.arch=?~[2,4-99]' | sed -E 's/ (.*)/[\1]/')"})
+      _values 'arch' $sub && ret=0
+      ;;
+  esac
+  return ret
+}
+
+_radiff2 "$@"
+
+# Local Variables:
+# mode: shell-script
+# coding: utf-8-unix
+# indent-tabs-mode: nil
+# sh-indentation: 2
+# sh-basic-offset: 2
+# End:
+# vim: ft=zsh sw=2 sts=2 et
diff --git a/.zsh.d/completions/_rafind2 b/.zsh.d/completions/_rafind2
new file mode 100644
index 000000000..9f7443652
--- /dev/null
+++ b/.zsh.d/completions/_rafind2
@@ -0,0 +1,38 @@
+#compdef rafind2
+local context state state_descr line
+
+_rafind2() {
+  local -a options=(
+  '-a+[only accept aligned hits]:align'
+  '-b+[set block size]:size'
+  '*-e+[search for regular expression string matches]:regex'
+  "-f+[start searching from address 'from']:from"
+  '-h[show this help]'
+  '-i[identify filetype (r2 -nqcpm file)]'
+  '-m[magic search, file-type carver]'
+  '-M+[set a binary mask to be applied on keywords]:str'
+  '-n[do not stop on read errors]'
+  '-r[print using radare commands]'
+  '*-s+[search for a specific string (can be used multiple times)]:str'
+  '*-S+[search for a specific wide string (can be used multiple times)]:str'
+  "-t+[stop search at address 'to']:to"
+  '-v[print version and exit]'
+  '*-x+[search for hexpair string (909090) (can be used multiple times)]:hex'
+  '-X[show hexdump of search results]'
+  '-z[search for zero-terminated strings]'
+  '-Z[show string found on each search hit]'
+  )
+
+  _arguments -S -s : $options '*:file:_files'
+}
+
+_rafind2 "$@"
+
+# Local Variables:
+# mode: shell-script
+# coding: utf-8-unix
+# indent-tabs-mode: nil
+# sh-indentation: 2
+# sh-basic-offset: 2
+# End:
+# vim: ft=zsh sw=2 sts=2 et
diff --git a/.zsh.d/completions/_ragg2 b/.zsh.d/completions/_ragg2
new file mode 100644
index 000000000..71fa34ba3
--- /dev/null
+++ b/.zsh.d/completions/_ragg2
@@ -0,0 +1,64 @@
+#compdef ragg2
+local context state state_descr line
+local -i ret=1
+
+r2_qc() {
+  r2 -qc $1 --
+}
+
+_ragg2() {
+  local -a options=(
+  '-a+[select architecture (x86, mips, arm)]: :->arch'
+  '-b+[register size (32, 64, ..)]:bits:(32 64)'
+  '-B+[append some hexpair bytes]:hexpairs'
+  '-c+[set configuration options]:k=v'
+  '-C+[append contents of file]:file'
+  '-d+[patch dword (4 bytes) at given offset]:off\:dword'
+  '-D+[patch qword (8 bytes) at given offset]:off\:qword'
+  '-e+[use specific encoder. see -L]:encoder'
+  '-f+[output format (raw, pe, elf, mach0)]:format'
+  '-F[output native format (osx=mach0, linux=elf, ..)]'
+  '-h[show this help]'
+  '-i+[include shellcode plugin, uses options. see -L]:shellcode'
+  '-I+[add include path]: :_directories'
+  "-k+[operating system's kernel (linux,bsd,osx,w32)]: :->asm.os"
+  '-L[list all plugins (shellcodes and encoders)]'
+  '-n+[append 32bit number (4 bytes)]:dword'
+  '-N+[append 64bit number (8 bytes)]:dword'
+  '-o+[output file]: :_files'
+  '-O[use default output file (filename without extension or a.out)]'
+  '-p+[add padding after compilation (padding=n10s32)]:padding'
+  '-P+[prepend debruijn pattern]:size'
+  '-q+[debruijn pattern offset]:fragment'
+  '-r[show raw bytes instead of hexpairs]'
+  '-s[show assembler]'
+  '-v[show version]'
+  '-w+[patch hexpairs at given offset]:off\:hex'
+  '-x[execute]'
+  '-z[output in C string syntax]'
+  )
+
+  _arguments -S -s : $options '1:file:_files' && ret=0
+
+  case $state in
+    arch)
+      local -a sub=(${(f)"$(r2_qc 'e asm.arch=?~[2,4-99]' | sed -E 's/ (.*)/[\1]/')"})
+      _values 'arch' $sub && ret=0
+      ;;
+    asm.os)
+      _values 'asm.os' $(r2_qc 'e asm.os=?') && ret=0
+      ;;
+  esac
+  return ret
+}
+
+_ragg2 "$@"
+
+# Local Variables:
+# mode: shell-script
+# coding: utf-8-unix
+# indent-tabs-mode: nil
+# sh-indentation: 2
+# sh-basic-offset: 2
+# End:
+# vim: ft=zsh sw=2 sts=2 et
diff --git a/.zsh.d/completions/_ragg2-cc b/.zsh.d/completions/_ragg2-cc
new file mode 100644
index 000000000..c42beb87f
--- /dev/null
+++ b/.zsh.d/completions/_ragg2-cc
@@ -0,0 +1,45 @@
+#compdef ragg2-cc
+local context state state_descr line
+local -i ret=1
+
+r2_qc() {
+  r2 -qc $1 --
+}
+
+_ragg2-cc() {
+  local -a options=(
+  '-a+[select architecture (x86, mips, arm)]: :->arch'
+  '-b+[register size (32, 64, ..)]:bits:(32 64)'
+  '-c[generate compiled shellcode]'
+  '-d[enable debug mode]'
+  "-k+[set kernel]: :->asm.os"
+  '-o+[set output file]: :_files'
+  '-s[generate assembly]'
+  '-v[show version]'
+  '-x[show hexpair bytes]'
+  )
+
+  _arguments -S -s : $options '1:file:_files' && ret=0
+
+  case $state in
+    arch)
+      local -a sub=(${(f)"$(r2_qc 'e asm.arch=?~[2,4-99]' | sed -E 's/ (.*)/[\1]/')"})
+      _values 'arch' $sub && ret=0
+      ;;
+    asm.os)
+      _values 'asm.os' $(r2_qc 'e asm.os=?') && ret=0
+      ;;
+  esac
+  return ret
+}
+
+_ragg2-cc "$@"
+
+# Local Variables:
+# mode: shell-script
+# coding: utf-8-unix
+# indent-tabs-mode: nil
+# sh-indentation: 2
+# sh-basic-offset: 2
+# End:
+# vim: ft=zsh sw=2 sts=2 et
diff --git a/.zsh.d/completions/_rahash2 b/.zsh.d/completions/_rahash2
new file mode 100644
index 000000000..d60480b29
--- /dev/null
+++ b/.zsh.d/completions/_rahash2
@@ -0,0 +1,56 @@
+#compdef rahash2
+local context state state_descr line
+local -i ret=1
+
+r2_qc() {
+  r2 -qc $1 --
+}
+
+_rahash2() {
+  local -a options=(
+  "-a+[comma separated list of algorithms (default is 'sha256')]: :->algo"
+  '-b+[specify the size of the block (instead of full file)]:bsize'
+  '-B[show per-block hash]'
+  '-c+[compare with this hash]:hash'
+  '-e[swap endian (use little endian)]'
+  '-E[encrypt. Use -S to set key and -I to set IV]: :->coder'
+  '-D[decrypt. Use -S to set key and -I to set IV]: :->coder'
+  '-f+[start hashing at given address]:from'
+  '-i+[repeat hash N iterations]:num'
+  '-I[use give initialization vector (IV) (hexa or s:string)]:iv'
+  '-S[use given seed (hexa or s:string) use ^ to prefix (key for -E)]:seed'
+  "-k[show hash using the openssh's randomkey algorithm]"
+  '-q[run in quiet mode (-qq to show only the hash)]'
+  '-L[list all available algorithms (see -a)]'
+  '-r[output radare commands]'
+  '-s[hash this string instead of files]:string'
+  '-t[stop hashing at given address]:to'
+  '-x[hash this hexpair string instead of files]:hexstr'
+  '-v[show version information]'
+  )
+
+  _arguments -S -s : $options '*:file:_files' && ret=0
+
+  case $state in
+    algo)
+      _values 'algo' all $(r2_qc 'ph?') && ret=0
+      ;;
+    coder)
+      local -a crypto=(rc2 rc4 rc6 aes-ecb aes-cbc ror rol rot blowfish cps2 des-ecb xor)
+      local -a coder=(base64 base91 punycode)
+      _values 'encoder/decoder' $crypto $coder && ret=0
+      ;;
+  esac
+  return ret
+}
+
+_rahash2 "$@"
+
+# Local Variables:
+# mode: shell-script
+# coding: utf-8-unix
+# indent-tabs-mode: nil
+# sh-indentation: 2
+# sh-basic-offset: 2
+# End:
+# vim: ft=zsh sw=2 sts=2 et
diff --git a/.zsh.d/completions/_rasm2 b/.zsh.d/completions/_rasm2
new file mode 100644
index 000000000..57c7ba7c0
--- /dev/null
+++ b/.zsh.d/completions/_rasm2
@@ -0,0 +1,64 @@
+#compdef rasm2
+local context state state_descr line
+local -i ret=1
+
+r2_qc() {
+  r2 -qc $1 --
+}
+
+_rasm2() {
+  local -a options=(
+  '-a+[Set architecture to assemble/disassemble (see -L)]: :->arch'
+  '-A[Show Analysis information from given hexpairs]'
+  '-b+[Set cpu register size (8, 16, 32, 64) (RASM2_BITS)]:bits:(8 16 32 64)'
+  '-c+[Select specific CPU (depends on arch)]:cpu'
+  '-C[Output in C format]'
+  '(-d -D)'{-d,-D}'[Disassemble from hexpair bytes (-D show hexpairs)]'
+  '-e[Use big endian instead of little endian]'
+  '-E[Display ESIL expression (same input as in -d)]'
+  '-f+[Read data from file]: :_files'
+  '-F+[Specify input and/or output filters (att2intel, x86.pseudo, ...)]:in\:out'
+  '(-h, -hh)'{-h,-hh}'[show help message, -hh for long]'
+  '-i+[ignore/skip N bytes of the input buffer]:bytes'
+  '(-j -r)-j[output in json format]'
+  '-k+[Select operating system (linux, windows, darwin, ..)]: :->asm.os'
+  '-l+[Input/Output length]:len'
+  '-L[List Asm plugins: (a=asm, d=disasm, A=analyze, e=ESIL)]'
+  '-o+[Set start address for code (default 0)]:offset'
+  '-O+[Output file name (rasm2 -Bf a.asm -O a)]: :_files'
+  '-p[Run SPP over input for assembly]'
+  '(-j -r)-r[output in radare commands]'
+  '-s+[Select syntax (intel, att)]: :->syntax'
+  '-B[Binary input/output (-l is mandatory for binary input)]'
+  '-v[Show version information]'
+  "-w[What's this instruction for? describe opcode]"
+  '-q[quiet mode]'
+  )
+
+  _arguments -S -s : $options '1:code|hex|-' && ret=0
+
+  case $state in
+    arch)
+      local -a sub=(${(f)"$(rasm2 -L | cut -c 18-28 | tr -d ' ')"})
+      _values 'arch' $sub && ret=0
+      ;;
+    asm.os)
+      _values 'asm.os' $(r2_qc 'e asm.os=?') && ret=0
+      ;;
+    syntax)
+      _values 'syntax' $(rasm2 '-s?') && ret=0
+      ;;
+  esac
+  return ret
+}
+
+_rasm2 "$@"
+
+# Local Variables:
+# mode: shell-script
+# coding: utf-8-unix
+# indent-tabs-mode: nil
+# sh-indentation: 2
+# sh-basic-offset: 2
+# End:
+# vim: ft=zsh sw=2 sts=2 et
diff --git a/.zsh.d/completions/_rax2 b/.zsh.d/completions/_rax2
new file mode 100644
index 000000000..ad5624d96
--- /dev/null
+++ b/.zsh.d/completions/_rax2
@@ -0,0 +1,41 @@
+#compdef rax2
+local context state state_descr line
+
+_rax2() {
+  local -a options=(
+  '-b[bin -> str        ;  rax2 -b 01000101 01110110]'
+  '-B[str -> bin        ;  rax2 -B hello]'
+  '-d[force integer     ;  rax2 -d 3 -> 3 instead of 0x3]'
+  '-e[swap endianness   ;  rax2 -e 0x33]'
+  '-D[base64 decode     ;]'
+  '-E[base64 encode     ;]'
+  '-f[floating point    ;  rax2 -f 6.3+2.1]'
+  '-F[stdin slurp C hex ;  rax2 -F < shellcode.c]'
+  '-h[help              ;  rax2 -h]'
+  '-k[keep base         ;  rax2 -k 33+3 -> 36]'
+  '-K[randomart         ;  rax2 -K 0x34 1020304050]'
+  '-n[binary number     ;  rax2 -n 0x1234 # 34120000]'
+  '-N[binary number     ;  rax2 -N 0x1234 # \x34\x12\x00\x00]'
+  '-r[r2 style output   ;  rax2 -r 0x1234]'
+  '-s[hexstr -> raw     ;  rax2 -s 43 4a 50]'
+  '-S[raw -> hexstr     ;  rax2 -S < /bin/ls > ls.hex]'
+  '-t[tstamp -> str     ;  rax2 -t 1234567890]'
+  '-x[hash string       ;  rax2 -x linux osx]'
+  '-u[units             ;  rax2 -u 389289238 # 317.0M]'
+  '-w[signed word       ;  rax2 -w 16 0xffff]'
+  '-v[version           ;  rax2 -v]'
+  )
+
+  _arguments -S -s : $options '*:expr'
+}
+
+_rax2 "$@"
+
+# Local Variables:
+# mode: shell-script
+# coding: utf-8-unix
+# indent-tabs-mode: nil
+# sh-indentation: 2
+# sh-basic-offset: 2
+# End:
+# vim: ft=zsh sw=2 sts=2 et
diff --git a/.zsh.d/completions/enabled/_r2 b/.zsh.d/completions/enabled/_r2
new file mode 120000
index 000000000..69eb7e9e8
--- /dev/null
+++ b/.zsh.d/completions/enabled/_r2
@@ -0,0 +1 @@
+../_r2
\ No newline at end of file
diff --git a/.zsh.d/completions/enabled/_rabin2 b/.zsh.d/completions/enabled/_rabin2
new file mode 120000
index 000000000..626912fe5
--- /dev/null
+++ b/.zsh.d/completions/enabled/_rabin2
@@ -0,0 +1 @@
+../_rabin2
\ No newline at end of file
diff --git a/.zsh.d/completions/enabled/_radiff2 b/.zsh.d/completions/enabled/_radiff2
new file mode 120000
index 000000000..4c5af459c
--- /dev/null
+++ b/.zsh.d/completions/enabled/_radiff2
@@ -0,0 +1 @@
+../_radiff2
\ No newline at end of file
diff --git a/.zsh.d/completions/enabled/_rafind2 b/.zsh.d/completions/enabled/_rafind2
new file mode 120000
index 000000000..c44cf1d8a
--- /dev/null
+++ b/.zsh.d/completions/enabled/_rafind2
@@ -0,0 +1 @@
+../_rafind2
\ No newline at end of file
diff --git a/.zsh.d/completions/enabled/_ragg2 b/.zsh.d/completions/enabled/_ragg2
new file mode 120000
index 000000000..8d3a52d38
--- /dev/null
+++ b/.zsh.d/completions/enabled/_ragg2
@@ -0,0 +1 @@
+../_ragg2
\ No newline at end of file
diff --git a/.zsh.d/completions/enabled/_ragg2-cc b/.zsh.d/completions/enabled/_ragg2-cc
new file mode 120000
index 000000000..13549b0a7
--- /dev/null
+++ b/.zsh.d/completions/enabled/_ragg2-cc
@@ -0,0 +1 @@
+../_ragg2-cc
\ No newline at end of file
diff --git a/.zsh.d/completions/enabled/_rahash2 b/.zsh.d/completions/enabled/_rahash2
new file mode 120000
index 000000000..e32cf52cc
--- /dev/null
+++ b/.zsh.d/completions/enabled/_rahash2
@@ -0,0 +1 @@
+../_rahash2
\ No newline at end of file
diff --git a/.zsh.d/completions/enabled/_rasm2 b/.zsh.d/completions/enabled/_rasm2
new file mode 120000
index 000000000..838342353
--- /dev/null
+++ b/.zsh.d/completions/enabled/_rasm2
@@ -0,0 +1 @@
+../_rasm2
\ No newline at end of file
diff --git a/.zsh.d/completions/enabled/_rax2 b/.zsh.d/completions/enabled/_rax2
new file mode 120000
index 000000000..6e192ac37
--- /dev/null
+++ b/.zsh.d/completions/enabled/_rax2
@@ -0,0 +1 @@
+../_rax2
\ No newline at end of file
diff --git a/.zsh.d/zsdoc/.zshenv.adoc b/.zsh.d/zsdoc/.zshenv.adoc
new file mode 100644
index 000000000..2ad6cace6
--- /dev/null
+++ b/.zsh.d/zsdoc/.zshenv.adoc
@@ -0,0 +1,24 @@
+.zshenv(1)
+==========
+:compat-mode!:
+
+NAME
+----
+.zshenv - a shell script
+
+SYNOPSIS
+--------
+Documentation automatically generated with `zshelldoc'
+
+FUNCTIONS
+---------
+
+
+DETAILS
+-------
+
+Script Body
+~~~~~~~~~~~
+
+Has 11 line(s). No functions are called (may attach to Zle or do hooks, etc.).
+
diff --git a/.zsh.d/zsdoc/.zshrc.adoc b/.zsh.d/zsdoc/.zshrc.adoc
new file mode 100644
index 000000000..9c501bc12
--- /dev/null
+++ b/.zsh.d/zsdoc/.zshrc.adoc
@@ -0,0 +1,72 @@
+.zshrc(1)
+=========
+:compat-mode!:
+
+NAME
+----
+.zshrc - a shell script
+
+SYNOPSIS
+--------
+Documentation automatically generated with `zshelldoc'
+
+FUNCTIONS
+---------
+
+AUTOLOAD bashcompinit
+AUTOLOAD colors
+AUTOLOAD compinit
+AUTOLOAD promptinit
+AUTOLOAD _systemctl
+AUTOLOAD vcs_info
+
+DETAILS
+-------
+
+Script Body
+~~~~~~~~~~~
+
+Has 584 line(s). No functions are called (may attach to Zle or do hooks, etc.).
+
+bashcompinit
+~~~~~~~~~~~~
+
+Has 179 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+colors
+~~~~~~
+
+Has 117 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+compinit
+~~~~~~~~
+
+Has 547 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+promptinit
+~~~~~~~~~~
+
+Has 263 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+_systemctl
+~~~~~~~~~~
+
+Has 393 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+vcs_info
+~~~~~~~~
+
+Has 148 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
diff --git a/.zsh.d/zsdoc/.zwidgets.adoc b/.zsh.d/zsdoc/.zwidgets.adoc
new file mode 100644
index 000000000..93c630d99
--- /dev/null
+++ b/.zsh.d/zsdoc/.zwidgets.adoc
@@ -0,0 +1,329 @@
+.zwidgets(1)
+============
+:compat-mode!:
+
+NAME
+----
+.zwidgets - a shell script
+
+SYNOPSIS
+--------
+Documentation automatically generated with `zshelldoc'
+
+FUNCTIONS
+---------
+
+ =
+ append-x-selection
+ check_last_exit_code
+ cleanup
+ fzf-locate-widget
+ git_prompt_string
+ insert-x-selection
+ news_long
+ news_short
+ parse_git_branch
+ parse_git_state
+ setescapes
+ yank-x-selection
+ zle-backwards-delete-to-char
+ zle-backwards-zap-to-char
+ zle-compdef
+ zle-emacs-keymap
+ zle-fh
+ zle-fman
+ zle-keymap-select
+ zle-less
+ zle-line-finish
+ zle-line-init
+ zle-toggle-keymap
+ zle-vi-keymap
+ zle-vim
+ zle-youtube-helper
+ zle-zaw-help
+ zshreadhist
+
+DETAILS
+-------
+
+Script Body
+~~~~~~~~~~~
+
+Has 2 line(s). No functions are called (may attach to Zle or do hooks, etc.).
+
+=
+~
+
+____
+ # inline calculator `= 4 * 2`
+____
+
+Has 1 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+append-x-selection
+~~~~~~~~~~~~~~~~~~
+
+Has 1 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+check_last_exit_code
+~~~~~~~~~~~~~~~~~~~~
+
+____
+ # Function to capture exit code of later command.
+____
+
+Has 8 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+cleanup
+~~~~~~~
+
+Has 11 line(s). Doesn't call other functions.
+
+Uses feature(s): _read_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+fzf-locate-widget
+~~~~~~~~~~~~~~~~~
+
+____
+ # ALT-I - Paste the selected entry from locate output into the command line
+____
+
+Has 6 line(s). Doesn't call other functions.
+
+Uses feature(s): _zle_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+git_prompt_string
+~~~~~~~~~~~~~~~~~
+
+____
+ # If inside a Git repository, print its branch and state
+____
+
+Has 2 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+insert-x-selection
+~~~~~~~~~~~~~~~~~~
+
+____
+ # X clipboard functions
+____
+
+Has 1 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+news_long
+~~~~~~~~~
+
+Has 26 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+news_short
+~~~~~~~~~~
+
+____
+ # Arch latest news
+ # The characters "£, §" are used as metacharacters. They should not be encountered in a feed...
+____
+
+Has 26 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+parse_git_branch
+~~~~~~~~~~~~~~~~
+
+____
+ # Show Git branch/tag, or name-rev if on detached head
+____
+
+Has 1 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+parse_git_state
+~~~~~~~~~~~~~~~
+
+____
+ # Show different symbols as appropriate for various Git repository states
+____
+
+Has 26 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+setescapes
+~~~~~~~~~~
+
+____
+ # Set term escape strings
+____
+
+Has 20 line(s). Doesn't call other functions.
+
+Uses feature(s): _eval_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+yank-x-selection
+~~~~~~~~~~~~~~~~
+
+Has 1 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-backwards-delete-to-char
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Has 3 line(s). Doesn't call other functions.
+
+Uses feature(s): _read_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-backwards-zap-to-char
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Has 3 line(s). Doesn't call other functions.
+
+Uses feature(s): _read_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-compdef
+~~~~~~~~~~~
+
+Has 9 line(s). Doesn't call other functions.
+
+Uses feature(s): _zle_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-emacs-keymap
+~~~~~~~~~~~~~~~~
+
+Has 2 line(s). Doesn't call other functions.
+
+Uses feature(s): _bindkey_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-fh
+~~~~~~
+
+Has 1 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-fman
+~~~~~~~~
+
+Has 26 line(s). Doesn't call other functions.
+
+Uses feature(s): _zle_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-keymap-select
+~~~~~~~~~~~~~~~~~
+
+Has 10 line(s). Doesn't call other functions.
+
+Uses feature(s): _zle_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-less
+~~~~~~~~
+
+Has 8 line(s). Doesn't call other functions.
+
+Uses feature(s): _eval_, _zle_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-line-finish
+~~~~~~~~~~~~~~~
+
+Has 10 line(s). Doesn't call other functions.
+
+Uses feature(s): _zle_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-line-init
+~~~~~~~~~~~~~
+
+Has 10 line(s). Doesn't call other functions.
+
+Uses feature(s): _zle_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-toggle-keymap
+~~~~~~~~~~~~~~~~~
+
+Has 8 line(s). Doesn't call other functions.
+
+Uses feature(s): _bindkey_, _zle_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-vi-keymap
+~~~~~~~~~~~~~
+
+Has 2 line(s). Doesn't call other functions.
+
+Uses feature(s): _bindkey_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-vim
+~~~~~~~
+
+Has 8 line(s). Doesn't call other functions.
+
+Uses feature(s): _eval_, _zle_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-youtube-helper
+~~~~~~~~~~~~~~~~~~
+
+Has 7 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zle-zaw-help
+~~~~~~~~~~~~
+
+Has 3 line(s). Doesn't call other functions.
+
+Uses feature(s): _zle_
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
+zshreadhist
+~~~~~~~~~~~
+
+____
+ # Make history entries from other zsh instances immediately visible
+____
+
+Has 1 line(s). Doesn't call other functions.
+
+Not called by script or any function, may be a hook or Zle widget, etc.
+
diff --git a/.zsh.d/zsdoc/data/autoload/.zshrc/_systemctl b/.zsh.d/zsdoc/data/autoload/.zshrc/_systemctl
new file mode 100644
index 000000000..a2d9a52bc
--- /dev/null
+++ b/.zsh.d/zsdoc/data/autoload/.zshrc/_systemctl
@@ -0,0 +1,393 @@
+#compdef systemctl
+
+(( $+functions[_systemctl_command] )) || _systemctl_command()
+{
+  local -a _systemctl_cmds
+  _systemctl_cmds=(
+    "list-sockets:List sockets"
+    "list-timers:List timers"
+    "list-units:List units"
+    "start:Start (activate) one or more units"
+    "stop:Stop (deactivate) one or more units"
+    "reload:Reload one or more units"
+    "restart:Start or restart one or more units"
+    "condrestart:Restart one or more units if active"
+    "try-restart:Restart one or more units if active"
+    "reload-or-restart:Reload one or more units if possible, otherwise start or restart"
+    "force-reload:Reload one or more units if possible, otherwise restart if active"
+    "hibernate:Hibernate the system"
+    "hybrid-sleep:Hibernate and suspend the system"
+    "try-reload-or-restart:Reload one or more units if possible, otherwise restart if active"
+    "isolate:Start one unit and stop all others"
+    "kill:Send signal to processes of a unit"
+    "is-active:Check whether units are active"
+    "is-failed:Check whether units are failed"
+    "status:Show runtime status of one or more units"
+    "show:Show properties of one or more units/jobs or the manager"
+    "cat:Show the source unit files and drop-ins"
+    "reset-failed:Reset failed state for all, one, or more units"
+    "list-unit-files:List installed unit files"
+    "enable:Enable one or more unit files"
+    "disable:Disable one or more unit files"
+    "add-wants:Add Wants= dependencies to a unit"
+    "add-requires:Add Requires= dependencies to a unit"
+    "reenable:Reenable one or more unit files"
+    "preset:Enable/disable one or more unit files based on preset configuration"
+    "set-default:Set the default target"
+    "get-default:Query the default target"
+    "edit:Edit one or more unit files"
+    "is-system-running:Query overall status of the system"
+    "help:Show documentation for specified units"
+    "list-dependencies:Show unit dependency tree"
+    "mask:Mask one or more units"
+    "unmask:Unmask one or more units"
+    "link:Link one or more units files into the search path"
+    "is-enabled:Check whether unit files are enabled"
+    "list-jobs:List jobs"
+    "cancel:Cancel all, one, or more jobs"
+    "show-environment:Dump environment"
+    "set-environment:Set one or more environment variables"
+    "unset-environment:Unset one or more environment variables"
+    "daemon-reload:Reload systemd manager configuration"
+    "daemon-reexec:Reexecute systemd manager"
+    "default:Enter system default mode"
+    "rescue:Enter system rescue mode"
+    "emergency:Enter system emergency mode"
+    "halt:Shut down and halt the system"
+    "suspend:Suspend the system"
+    "poweroff:Shut down and power-off the system"
+    "reboot:Shut down and reboot the system"
+    "kexec:Shut down and reboot the system with kexec"
+    "exit:Ask for user instance termination"
+    "switch-root:Change root directory"
+    "revert:Revert unit files to their vendor versions"
+  )
+
+  if (( CURRENT == 1 )); then
+    _describe -t commands 'systemctl command' _systemctl_cmds || compadd "$@"
+  else
+    local curcontext="$curcontext" expl
+
+    cmd="${${_systemctl_cmds[(r)$words[1]:*]%%:*}}"
+    # Deal with any aliases
+    case $cmd in
+      condrestart) cmd="try-restart";;
+      force-reload) cmd="try-reload-or-restart";;
+    esac
+
+    if (( $#cmd )); then
+      curcontext="${curcontext%:*:*}:systemctl-${cmd}:"
+
+      local update_policy
+      zstyle -s ":completion:${curcontext}:" cache-policy update_policy
+      if [[ -z "$update_policy" ]]; then
+        zstyle ":completion:${curcontext}:" cache-policy _systemctl_caching_policy
+      fi
+
+      _call_function ret _systemctl_$cmd || _message 'no more arguments'
+    else
+      _message "unknown systemctl command: $words[1]"
+    fi
+    return ret
+  fi
+}
+
+__systemctl()
+{
+  systemctl $_sys_service_mgr --full --no-legend --no-pager "$@" 2>/dev/null
+}
+
+
+# Fills the unit list
+_systemctl_all_units()
+{
+  if ( [[ ${+_sys_all_units} -eq 0 ]] || _cache_invalid SYS_ALL_UNITS$_sys_service_mgr ) ||
+    ! _retrieve_cache SYS_ALL_UNITS$_sys_service_mgr;
+  then
+    _sys_all_units=( ${${(f)"$(__systemctl list-units --all)"}%% *} )
+    _store_cache SYS_ALL_UNITS$_sys_service_mgr _sys_all_units
+  fi
+}
+
+# Fills the unit list including all file units
+_systemctl_really_all_units()
+{
+  local -a all_unit_files;
+  local -a really_all_units;
+  if ( [[ ${+_sys_really_all_units} -eq 0 ]] || _cache_invalid SYS_REALLY_ALL_UNITS$_sys_service_mgr ) ||
+    ! _retrieve_cache SYS_REALLY_ALL_UNITS$_sys_service_mgr;
+  then
+    all_unit_files=( ${${(f)"$(__systemctl list-unit-files)"}%% *} )
+    _systemctl_all_units
+    really_all_units=($_sys_all_units $all_unit_files)
+    _sys_really_all_units=(${(u)really_all_units})
+    _store_cache SYS_REALLY_ALL_UNITS$_sys_service_mgr _sys_really_all_units
+  fi
+}
+
+_filter_units_by_property() {
+  local property=$1 value=$2; shift 2
+  local -a units; units=("${(q-)@}")
+  local -A props
+  props=(${(f)"$(_call_program units "$service $_sys_service_mgr show --no-pager --property=\"Id,$property\" -- ${units} 2>/dev/null")"})
+  echo -E - "${(@g:o:)${(k@)props[(Re)$property=$value]}#Id=}"
+}
+
+_systemctl_get_template_names() { echo -E - ${^${(M)${(f)"$(__systemctl list-unit-files "*$PREFIX*$SUFFIX*" )"}##*@.[^[:space:]]##}%%@.*}\@ }
+
+
+_systemctl_active_units()  {_sys_active_units=(  ${${(f)"$(__systemctl list-units "*$PREFIX*$SUFFIX*" )"}%% *} )}
+
+_systemctl_startable_units(){
+    _sys_startable_units=( $( _filter_units_by_property ActiveState inactive $(
+                          _filter_units_by_property CanStart yes $(
+                          __systemctl $mode list-unit-files --state enabled,disabled,static "*$PREFIX*$SUFFIX*" | \
+                               { while read -r a b; do [[ $a =~ @\. ]] || echo -E - " $a"; done; }
+                          __systemctl $mode list-units --state inactive,failed "*$PREFIX*$SUFFIX*" | \
+                               { while read -r a b; do echo -E - " $a"; done; } )) ) )
+}
+
+_systemctl_restartable_units(){
+    _sys_restartable_units=( $(_filter_units_by_property CanStart yes $(
+                          __systemctl $mode list-unit-files --state enabled,disabled,static "*$PREFIX*$SUFFIX*" | \
+                               { while read -r a b; do [[ $a =~ @\. ]] || echo -E - " $a"; done; }
+                          __systemctl $mode list-units "*$PREFIX*$SUFFIX*" | \
+                               { while read -r a b; do echo -E - " $a"; done; } )) )
+}
+
+_systemctl_failed_units()  {_sys_failed_units=( ${${(f)"$(__systemctl list-units --state=failed "*$PREFIX*$SUFFIX*" )"}%% *} ) }
+_systemctl_unit_state() { typeset -gA _sys_unit_state; _sys_unit_state=( $(__systemctl list-unit-files "*$PREFIX*$SUFFIX*" ) ) }
+
+local fun
+# Completion functions for ALL_UNITS
+for fun in is-active is-failed is-enabled status show cat mask preset help list-dependencies edit revert add-wants add-requires ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    _systemctl_really_all_units
+    _wanted systemd-units expl unit \
+      compadd "$@" -a - _sys_really_all_units
+  }
+done
+
+# Completion functions for ENABLED_UNITS
+(( $+functions[_systemctl_disable] )) || _systemctl_disable()
+{
+    local _sys_unit_state; _systemctl_unit_state
+    _wanted systemd-units expl 'enabled unit' \
+      compadd "$@" - ${(k)_sys_unit_state[(R)enabled]}
+}
+
+(( $+functions[_systemctl_reenable] )) || _systemctl_reenable()
+{
+    local _sys_unit_state; _systemctl_unit_state
+    _wanted systemd-units expl 'enabled/disabled unit' \
+      compadd "$@" - ${(k)_sys_unit_state[(R)(enabled|disabled)]} $(_systemctl_get_template_names)
+}
+
+# Completion functions for DISABLED_UNITS
+(( $+functions[_systemctl_enable] )) || _systemctl_enable()
+{
+  local _sys_unit_state; _systemctl_unit_state
+  _wanted systemd-units expl 'disabled unit' \
+    compadd "$@" - ${(k)_sys_unit_state[(R)disabled]} $(_systemctl_get_template_names)
+}
+
+# Completion functions for FAILED_UNITS
+(( $+functions[_systemctl_reset-failed] )) || _systemctl_reset-failed()
+{
+  local _sys_failed_units; _systemctl_failed_units
+  _wanted systemd-units expl 'failed unit' \
+    compadd "$@" -a - _sys_failed_units || _message "no failed unit found"
+}
+
+# Completion functions for STARTABLE_UNITS
+(( $+functions[_systemctl_start] )) || _systemctl_start()
+{
+   local _sys_startable_units; _systemctl_startable_units
+   _wanted systemd-units expl 'startable unit' \
+     compadd "$@" - ${_sys_startable_units[*]} $(_systemctl_get_template_names)
+}
+
+# Completion functions for STOPPABLE_UNITS
+for fun in stop kill try-restart condrestart ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    local _sys_active_units; _systemctl_active_units
+    _wanted systemd-units expl 'stoppable unit' \
+      compadd "$@" - $( _filter_units_by_property CanStop yes \
+        ${_sys_active_units[*]} )
+  }
+done
+
+# Completion functions for ISOLATABLE_UNITS
+(( $+functions[_systemctl_isolate] )) || _systemctl_isolate()
+{
+  _systemctl_all_units
+  _wanted systemd-units expl 'isolatable unit' \
+    compadd "$@" - $( _filter_units_by_property AllowIsolate yes \
+      ${_sys_all_units[*]} )
+}
+
+# Completion functions for RELOADABLE_UNITS
+for fun in reload try-reload-or-restart force-reload ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    local _sys_active_units; _systemctl_active_units
+    _wanted systemd-units expl 'reloadable unit' \
+      compadd "$@" - $( _filter_units_by_property CanReload yes \
+        ${_sys_active_units[*]} )
+  }
+done
+
+# Completion functions for RESTARTABLE_UNITS
+for fun in restart reload-or-restart ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    local _sys_restartable_units; _systemctl_restartable_units
+    _wanted systemd-units expl 'restartable unit' \
+      compadd "$@" - ${_sys_restartable_units[*]} $(_systemctl_get_template_names)
+  }
+done
+
+# Completion functions for MASKED_UNITS
+(( $+functions[_systemctl_unmask] )) || _systemctl_unmask()
+{
+  local _sys_unit_state; _systemctl_unit_state
+  _wanted systemd-units expl 'masked unit' \
+    compadd "$@" - ${(k)_sys_unit_state[(R)masked]} || _message "no masked units found"
+}
+
+# Completion functions for JOBS
+(( $+functions[_systemctl_cancel] )) || _systemctl_cancel()
+{
+  _wanted systemd-jobs expl job \
+    compadd "$@" - ${${(f)"$(__systemctl list-jobs)"}%% *} ||
+      _message "no jobs found"
+}
+
+# Completion functions for TARGETS
+(( $+functions[_systemctl_set-default] )) || _systemctl_set-default()
+{
+  _wanted systemd-targets expl target \
+    compadd "$@" - ${${(f)"$(__systemctl list-unit-files --type target --all)"}%% *} ||
+      _message "no targets found"
+}
+
+# Completion functions for ENVS
+for fun in set-environment unset-environment ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    local fun=$0 ; fun=${fun##_systemctl_}
+    local suf
+    if [[ "${fun}" = "set-environment" ]]; then
+      suf='-S='
+    fi
+    _wanted systemd-environment expl 'environment variable' \
+      compadd "$@" ${suf} - ${${(f)"$(systemctl show-environment)"}%%=*}
+  }
+done
+
+(( $+functions[_systemctl_link] )) || _systemctl_link() {
+   _sd_unit_files
+}
+
+(( $+functions[_systemctl_switch-root] )) || _systemctl_switch-root() {
+   _files
+}
+
+# no systemctl completion for:
+#    [STANDALONE]='daemon-reexec daemon-reload default
+#                  emergency exit halt kexec list-jobs list-units
+#                  list-unit-files poweroff reboot rescue show-environment'
+
+_systemctl_caching_policy()
+{
+  local _sysunits
+  local -a oldcache
+
+  # rebuild if cache is more than a day old
+  oldcache=( "$1"(mh+1) )
+  (( $#oldcache )) && return 0
+
+  _sysunits=(${${(f)"$(__systemctl --all)"}%% *})
+
+  if (( $#_sysunits )); then
+    for unit in $_sysunits; do
+      [[ "$unit" -nt "$1" ]] && return 0
+    done
+  fi
+
+  return 1
+}
+
+_unit_states() {
+    local -a _states
+    _states=("${(fo)$(__systemctl --state=help)}")
+    _values -s , "${_states[@]}"
+}
+
+_unit_types() {
+    local -a _types
+    _types=("${(fo)$(__systemctl -t help)}")
+    _values -s , "${_types[@]}"
+}
+
+_unit_properties() {
+  if ( [[ ${+_sys_all_properties} -eq 0 ]] || _cache_invalid SYS_ALL_PROPERTIES$_sys_service_mgr ) ||
+    ! _retrieve_cache SYS_ALL_PROPERTIES$_sys_service_mgr;
+  then
+    _sys_all_properties=( ${${(M)${(f)"$(__systemctl show --all;
+    /usr/lib/systemd/systemd --dump-configuration-items)"}##[[:alnum:]]##=*}%%=*}
+    )
+    _store_cache SYS_ALL_PROPERTIES$_sys_service_mgr _sys_all_properties
+  fi
+  _values -s , "${_sys_all_properties[@]}"
+}
+
+_job_modes() {
+    local -a _modes
+    _modes=(fail replace replace-irreversibly isolate ignore-dependencies ignore-requirements flush)
+    _values -s , "${_modes[@]}"
+}
+
+# Build arguments for "systemctl" to be used in completion.
+local -a _modes; _modes=("--user" "--system")
+# Use the last mode (they are exclusive and the last one is used).
+local _sys_service_mgr=${${words:*_modes}[(R)(${(j.|.)_modes})]}
+_arguments -s \
+    {-h,--help}'[Show help]' \
+    '--version[Show package version]' \
+    {-t+,--type=}'[List only units of a particular type]:unit type:_unit_types' \
+    '--state=[Display units in the specified state]:unit state:_unit_states' \
+    '--job-mode=[Specify how to deal with other jobs]:mode:_job_modes' \
+    {-p+,--property=}'[Show only properties by specific name]:unit property:_unit_properties' \
+    {-a,--all}'[Show all units/properties, including dead/empty ones]' \
+    '--reverse[Show reverse dependencies]' \
+    '--after[Show units ordered after]' \
+    '--before[Show units ordered before]' \
+    {-l,--full}"[Don't ellipsize unit names on output]" \
+    '--show-types[When showing sockets, show socket type]' \
+    {-i,--ignore-inhibitors}'[When executing a job, ignore jobs dependencies]' \
+    {-q,--quiet}'[Suppress output]' \
+    '--no-block[Do not wait until operation finished]' \
+    '--no-legend[Do not print a legend, i.e. the column headers and the footer with hints]' \
+    '--no-pager[Do not pipe output into a pager]' \
+    '--system[Connect to system manager]' \
+    '--user[Connect to user service manager]' \
+    "--no-wall[Don't send wall message before halt/power-off/reboot]" \
+    '--global[Enable/disable unit files globally]' \
+    "--no-reload[When enabling/disabling unit files, don't reload daemon configuration]" \
+    '--no-ask-password[Do not ask for system passwords]' \
+    '--kill-who=[Who to send signal to]:killwho:(main control all)' \
+    {-s+,--signal=}'[Which signal to send]:signal:_signals' \
+    {-f,--force}'[When enabling unit files, override existing symlinks. When shutting down, execute action immediately]' \
+    '--root=[Enable unit files in the specified root directory]:directory:_directories' \
+    '--runtime[Enable unit files only temporarily until next reboot]' \
+    {-H+,--host=}'[Operate on remote host]:userathost:_sd_hosts_or_user_at_host' \
+    {-P,--privileged}'[Acquire privileges before execution]' \
+    {-n+,--lines=}'[Journal entries to show]:number of entries' \
+    {-o+,--output=}'[Change journal output mode]:modes:_sd_outputmodes' \
+    '--firmware-setup[Tell the firmware to show the setup menu on next boot]' \
+    '--plain[When used with list-dependencies, print output as a list]' \
+    '--failed[Show failed units]' \
+    '*::systemctl command:_systemctl_command'
diff --git a/.zsh.d/zsdoc/data/autoload/.zshrc/bashcompinit b/.zsh.d/zsdoc/data/autoload/.zshrc/bashcompinit
new file mode 100644
index 000000000..902fa88a8
--- /dev/null
+++ b/.zsh.d/zsdoc/data/autoload/.zshrc/bashcompinit
@@ -0,0 +1,179 @@
+#autoload
+
+_bash_complete() {
+  local ret=1
+  local -a suf matches
+  local -x COMP_POINT COMP_CWORD
+  local -a COMP_WORDS COMPREPLY BASH_VERSINFO
+  local -x COMP_LINE="$words"
+  local -A savejobstates savejobtexts
+
+  (( COMP_POINT = 1 + ${#${(j. .)words[1,CURRENT]}} + $#QIPREFIX + $#IPREFIX + $#PREFIX ))
+  (( COMP_CWORD = CURRENT - 1))
+  COMP_WORDS=( $words )
+  BASH_VERSINFO=( 2 05b 0 1 release )
+
+  savejobstates=( ${(kv)jobstates} )
+  savejobtexts=( ${(kv)jobtexts} )
+
+  [[ ${argv[${argv[(I)nospace]:-0}-1]} = -o ]] && suf=( -S '' )
+
+  matches=( ${(f)"$(compgen $@ -- ${words[CURRENT]})"} )
+
+  if [[ -n $matches ]]; then
+    if [[ ${argv[${argv[(I)filenames]:-0}-1]} = -o ]]; then
+      compset -P '*/' && matches=( ${matches##*/} )
+      compset -S '/*' && matches=( ${matches%%/*} )
+      compadd -Q -f "${suf[@]}" -a matches && ret=0
+    else
+      compadd -Q "${suf[@]}" -a matches && ret=0
+    fi
+  fi
+
+  if (( ret )); then
+    if [[ ${argv[${argv[(I)default]:-0}-1]} = -o ]]; then
+      _default "${suf[@]}" && ret=0
+    elif [[ ${argv[${argv[(I)dirnames]:-0}-1]} = -o ]]; then
+      _directories "${suf[@]}" && ret=0
+    fi
+  fi
+
+  return ret
+}
+
+compgen() {
+  local opts prefix suffix job OPTARG OPTIND ret=1
+  local -a name res results jids
+  local -A shortopts
+
+  # words changes behavior: words[1] -> words[0]
+  emulate -L sh
+  setopt kshglob noshglob braceexpand nokshautoload
+
+  shortopts=(
+    a alias b builtin c command d directory e export f file
+    g group j job k keyword u user v variable
+  )
+
+  while getopts "o:A:G:C:F:P:S:W:X:abcdefgjkuv" name; do
+    case $name in
+      [abcdefgjkuv]) OPTARG="${shortopts[$name]}" ;&
+      A)
+        case $OPTARG in
+	  alias) results+=( "${(k)aliases[@]}" ) ;;
+	  arrayvar) results+=( "${(k@)parameters[(R)array*]}" ) ;;
+	  binding) results+=( "${(k)widgets[@]}" ) ;;
+	  builtin) results+=( "${(k)builtins[@]}" "${(k)dis_builtins[@]}" ) ;;
+	  command)
+	    results+=(
+	      "${(k)commands[@]}" "${(k)aliases[@]}" "${(k)builtins[@]}"
+	      "${(k)functions[@]}" "${(k)reswords[@]}"
+	    )
+	  ;;
+	  directory)
+	    setopt bareglobqual
+	    results+=( ${IPREFIX}${PREFIX}*${SUFFIX}${ISUFFIX}(N-/) )
+	    setopt nobareglobqual
+	  ;;
+	  disabled) results+=( "${(k)dis_builtins[@]}" ) ;;
+	  enabled) results+=( "${(k)builtins[@]}" ) ;;
+	  export) results+=( "${(k)parameters[(R)*export*]}" ) ;;
+	  file)
+	    setopt bareglobqual
+	    results+=( ${IPREFIX}${PREFIX}*${SUFFIX}${ISUFFIX}(N) )
+	    setopt nobareglobqual
+	  ;;
+	  function) results+=( "${(k)functions[@]}" ) ;;
+	  group)
+	    emulate zsh
+	    _groups -U -O res
+	    emulate sh
+	    setopt kshglob noshglob braceexpand
+	    results+=( "${res[@]}" )
+	  ;;
+	  hostname)
+	    emulate zsh
+	    _hosts -U -O res
+	    emulate sh
+	    setopt kshglob noshglob braceexpand
+	    results+=( "${res[@]}" )
+	  ;;
+	  job) results+=( "${savejobtexts[@]%% *}" );;
+	  keyword) results+=( "${(k)reswords[@]}" ) ;;
+	  running)
+	    jids=( "${(@k)savejobstates[(R)running*]}" )
+	    for job in "${jids[@]}"; do
+	      results+=( ${savejobtexts[$job]%% *} )
+	    done
+	  ;;
+	  stopped)
+	    jids=( "${(@k)savejobstates[(R)suspended*]}" )
+	    for job in "${jids[@]}"; do
+	      results+=( ${savejobtexts[$job]%% *} )
+	    done
+	  ;;
+	  setopt|shopt) results+=( "${(k)options[@]}" ) ;;
+	  signal) results+=( "SIG${^signals[@]}" ) ;;
+	  user) results+=( "${(k)userdirs[@]}" ) ;;
+      	  variable) results+=( "${(k)parameters[@]}" ) ;;
+	  helptopic) ;;
+	esac
+      ;;
+      F)
+        COMPREPLY=()
+        local -a args
+        args=( "${words[0]}" "${@[-1]}" "${words[CURRENT-2]}" )
+        (){
+          # There may be more things we need to add to this typeset to
+          # protect bash functions from compsys special variable names
+          typeset -h words
+          $OPTARG "${args[@]}"
+        }
+	results+=( "${COMPREPLY[@]}" )
+      ;;
+      G)
+        setopt nullglob
+        results+=( ${~OPTARG} )
+	unsetopt nullglob
+      ;;
+      W) results+=( ${(Q)~=OPTARG} ) ;;
+      C) results+=( $(eval $OPTARG) ) ;;
+      P) prefix="$OPTARG" ;;
+      S) suffix="$OPTARG" ;;
+      X)
+        if [[ ${OPTARG[0]} = '!' ]]; then
+	  results=( "${(M)results[@]:#${OPTARG#?}}" )
+	else
+ 	  results=( "${results[@]:#$OPTARG}" )
+	fi
+      ;;
+    esac
+  done
+  
+  # support for the last, `word' option to compgen. Zsh's matching does a
+  # better job but if you need to, comment this in and use compadd -U
+  # (( $# >= OPTIND)) && results=( "${(M)results[@]:#${@[-1]}*}" )
+
+  print -l -r -- "$prefix${^results[@]}$suffix"
+}
+
+complete() {
+  emulate -L zsh
+  local args void cmd print remove
+  args=( "$@" )
+  zparseopts -D -a void o: A: G: W: C: F: P: S: X: a b c d e f g j k u v \
+      p=print r=remove
+  if [[ -n $print ]]; then
+    printf 'complete %2$s %1$s\n' "${(@kv)_comps[(R)_bash*]#* }"
+  elif [[ -n $remove ]]; then
+    for cmd; do
+      unset "_comps[$cmd]"
+    done
+  else
+    compdef _bash_complete\ ${(j. .)${(q)args[1,-1-$#]}} "$@"
+  fi
+}
+
+unfunction bashcompinit
+autoload -Uz bashcompinit
+return 0
diff --git a/.zsh.d/zsdoc/data/autoload/.zshrc/colors b/.zsh.d/zsdoc/data/autoload/.zshrc/colors
new file mode 100644
index 000000000..027ca9a14
--- /dev/null
+++ b/.zsh.d/zsdoc/data/autoload/.zshrc/colors
@@ -0,0 +1,117 @@
+# Put standard ANSI color codes in shell parameters for easy use.
+# Note that some terminals do not support all combinations.
+
+emulate -L zsh
+
+typeset -Ag color colour
+
+color=(
+# Codes listed in this array are from ECMA-48, Section 8.3.117, p. 61.
+# Those that are commented out are not widely supported or aren't closely
+# enough related to color manipulation, but are included for completeness.
+
+# Attribute codes:
+  00 none                 # 20 gothic
+  01 bold                 # 21 double-underline
+  02 faint                  22 normal
+  03 standout               23 no-standout
+  04 underline              24 no-underline
+  05 blink                  25 no-blink
+# 06 fast-blink           # 26 proportional
+  07 reverse                27 no-reverse
+  08 conceal                28 no-conceal
+# 09 strikethrough        # 29 no-strikethrough
+
+# Font selection:
+# 10 font-default
+# 11 font-first
+# 12 font-second
+# 13 font-third
+# 14 font-fourth
+# 15 font-fifth
+# 16 font-sixth
+# 17 font-seventh
+# 18 font-eighth
+# 19 font-ninth
+
+# Text color codes:
+  30 black                  40 bg-black
+  31 red                    41 bg-red
+  32 green                  42 bg-green
+  33 yellow                 43 bg-yellow
+  34 blue                   44 bg-blue
+  35 magenta                45 bg-magenta
+  36 cyan                   46 bg-cyan
+  37 white                  47 bg-white
+# 38 iso-8316-6           # 48 bg-iso-8316-6
+  39 default                49 bg-default
+
+# Other codes:
+# 50 no-proportional
+# 51 border-rectangle
+# 52 border-circle
+# 53 overline
+# 54 no-border
+# 55 no-overline
+# 56 through 59 reserved
+
+# Ideogram markings:
+# 60 underline-or-right
+# 61 double-underline-or-right
+# 62 overline-or-left
+# 63 double-overline-or-left
+# 64 stress
+# 65 no-ideogram-marking
+)
+
+# A word about black and white:  The "normal" shade of white is really a
+# very pale grey on many terminals; to get truly white text, you have to
+# use bold white, and to get a truly white background you have to use
+# bold reverse white bg-xxx where xxx is your desired foreground color
+# (and which means the foreground is also bold).
+
+# Map in both directions; could do this with e.g. ${(k)colors[(i)normal]},
+# but it's clearer to include them all both ways.
+
+local k
+for k in ${(k)color}; do color[${color[$k]}]=$k; done
+
+# Add "fg-" keys for all the text colors, for clarity.
+
+for k in ${color[(I)3?]}; do color[fg-${color[$k]}]=$k; done
+
+# This is inaccurate, but the prompt theme system needs it.
+
+color[grey]=${color[black]}
+color[fg-grey]=${color[grey]}
+color[bg-grey]=${color[bg-black]}
+
+# Assistance for the color-blind.
+
+colour=(${(kv)color})	# A case where ksh namerefs would be useful ...
+
+# The following are terminal escape sequences used by colored prompt themes.
+
+local lc=$'\e[' rc=m	# Standard ANSI terminal escape values
+
+typeset -Hg reset_color bold_color
+reset_color="$lc${color[none]}$rc"
+bold_color="$lc${color[bold]}$rc"
+
+# Foreground
+
+typeset -AHg fg fg_bold fg_no_bold
+for k in ${(k)color[(I)fg-*]}; do
+    fg[${k#fg-}]="$lc${color[$k]}$rc"
+    fg_bold[${k#fg-}]="$lc${color[bold]};${color[$k]}$rc"
+    fg_no_bold[${k#fg-}]="$lc${color[normal]};${color[$k]}$rc"
+done
+
+# Background
+
+typeset -AHg bg bg_bold bg_no_bold
+for k in ${(k)color[(I)bg-*]}; do
+    bg[${k#bg-}]="$lc${color[$k]}$rc"
+    bg_bold[${k#bg-}]="$lc${color[bold]};${color[$k]}$rc"
+    bg_no_bold[${k#bg-}]="$lc${color[normal]};${color[$k]}$rc"
+done
diff --git a/.zsh.d/zsdoc/data/autoload/.zshrc/compinit b/.zsh.d/zsdoc/data/autoload/.zshrc/compinit
new file mode 100644
index 000000000..c345ceb43
--- /dev/null
+++ b/.zsh.d/zsdoc/data/autoload/.zshrc/compinit
@@ -0,0 +1,547 @@
+# Initialisation for new style completion. This mainly contains some helper
+# functions and setup. Everything else is split into different files that
+# will automatically be made autoloaded (see the end of this file).  The
+# names of the files that will be considered for autoloading are those that
+# begin with an underscores (like `_condition).
+#
+# The first line of each of these files is read and must indicate what
+# should be done with its contents:
+#
+#   `#compdef <names ...>'
+#     If the first line looks like this, the file is autoloaded as a
+#     function and that function will be called to generate the matches
+#     when completing for one of the commands whose <names> are given.
+#     The names may also be interspersed with `-T <assoc>' options
+#     specifying for which set of functions this should be added.
+#
+#   `#compdef -[pP] <patterns ...>'
+#     This defines a function that should be called to generate matches
+#     for commands whose name matches <pattern>. Note that only one pattern
+#     may be given.
+#
+#   `#compdef -k <style> [ <key-sequence> ... ]'
+#     This is used to bind special completions to all the given
+#     <key-sequence>(s). The <style> is the name of one of the built-in
+#     completion widgets (complete-word, delete-char-or-list,
+#     expand-or-complete, expand-or-complete-prefix, list-choices,
+#     menu-complete, menu-expand-or-complete, or reverse-menu-complete).
+#     This creates a widget behaving like <style> so that the
+#     completions are chosen as given in the rest of the file,
+#     rather than by the context.  The widget has the same name as
+#     the autoload file and can be bound using bindkey in the normal way.
+#
+#   `#compdef -K <widget-name> <style> <key-sequence> [ ... ]'
+#     This is similar to -k, except it takes any number of sets of
+#     three arguments.  In each set, the widget <widget-name> will
+#     be defined, which will behave as <style>, as with -k, and will
+#     be bound to <key-sequence>, exactly one of which must be defined.
+#     <widget-name> must be different for each:  this must begin with an
+#     underscore, else one will be added, and should not clash with other
+#     completion widgets (names based on the name of the function are the
+#     clearest), but is otherwise arbitrary.  It can be tested in the
+#     function by the parameter $WIDGET.
+#
+#   `#autoload [ <options> ]'
+#     This is for helper functions that are not used to
+#     generate matches, but should automatically be loaded
+#     when they are called. The <options> will be given to the
+#     autoload builtin when making the function autoloaded. Note
+#     that this need not include `-U' and `-z'.
+#
+# Note that no white space is allowed between the `#' and the rest of
+# the string.
+#
+# Functions that are used to generate matches should return zero if they
+# were able to add matches and non-zero otherwise.
+#
+# See the file `compdump' for how to speed up initialisation.
+
+# If we got the `-d'-flag, we will automatically dump the new state (at
+# the end).  This takes the dumpfile as an argument.  -d (with the
+# default dumpfile) is now the default; to turn off dumping use -D.
+
+# The -C flag bypasses both the check for rebuilding the dump file and the
+# usual call to compaudit; the -i flag causes insecure directories found by
+# compaudit to be ignored, and the -u flag causes all directories found by
+# compaudit to be used (without security checking).  Otherwise the user is
+# queried for whether to use or ignore the insecure directories (which
+# means compinit should not be called from non-interactive shells).
+
+emulate -L zsh
+setopt extendedglob
+
+typeset _i_dumpfile _i_files _i_line _i_done _i_dir _i_autodump=1
+typeset _i_tag _i_file _i_addfiles _i_fail=ask _i_check=yes _i_name
+
+while [[ $# -gt 0 && $1 = -[dDiuC] ]]; do
+  case "$1" in
+  -d)
+    _i_autodump=1
+    shift
+    if [[ $# -gt 0 && "$1" != -[dfQC] ]]; then
+      _i_dumpfile="$1"
+      shift
+    fi
+    ;;
+  -D)
+    _i_autodump=0
+    shift
+    ;;
+  -i)
+    _i_fail=ign
+    shift
+    ;;
+  -u)
+    _i_fail=use
+    shift
+    ;;
+  -C)
+    _i_check=
+    shift
+    ;;
+  esac
+done
+
+# The associative arrays containing the definitions for the commands and
+# services.
+
+typeset -gHA _comps _services _patcomps _postpatcomps
+
+# `_compautos' contains the names and options for autoloaded functions
+# that get options.
+
+typeset -gHA _compautos
+
+# The associative array use to report information about the last
+# completion to the outside.
+
+typeset -gHA _lastcomp
+
+# Remember dumpfile.
+if [[ -n $_i_dumpfile ]]; then
+  # Explicitly supplied dumpfile.
+  typeset -g _comp_dumpfile="$_i_dumpfile"
+else
+  typeset -g _comp_dumpfile="${ZDOTDIR:-$HOME}/.zcompdump"
+fi
+
+# The standard options set in completion functions.
+
+typeset -gHa _comp_options
+_comp_options=(
+       bareglobqual
+       extendedglob
+       glob
+       multibyte
+       multifuncdef
+       nullglob
+       rcexpandparam
+       unset
+    NO_allexport
+    NO_aliases
+    NO_cshnullglob
+    NO_cshjunkiequotes
+    NO_errexit
+    NO_errreturn
+    NO_globassign
+    NO_globsubst
+    NO_histsubstpattern
+    NO_ignorebraces
+    NO_ignoreclosebraces
+    NO_kshglob
+    NO_ksharrays
+    NO_kshtypeset
+    NO_markdirs
+    NO_octalzeroes
+    NO_posixbuiltins
+    NO_posixidentifiers
+    NO_shwordsplit
+    NO_shglob
+    NO_warnnestedvar
+    NO_warncreateglobal
+)
+
+# And this one should be `eval'ed at the beginning of every entry point
+# to the completion system.  It sets up what we currently consider a
+# sane environment.  That means we set the options above, make sure we
+# have a valid stdin descriptor (zle closes it before calling widgets)
+# and don't get confused by user's ZERR trap handlers.
+
+typeset -gH _comp_setup='local -A _comp_caller_options;
+             _comp_caller_options=(${(kv)options[@]});
+             setopt localoptions localtraps localpatterns ${_comp_options[@]};
+             local IFS=$'\'\ \\t\\r\\n\\0\'';
+             builtin enable -p \| \~ \( \? \* \[ \< \^ \# 2>&-;
+             exec </dev/null;
+             trap - ZERR;
+             local -a reply;
+             local REPLY'
+
+# These can hold names of functions that are to be called before/after all
+# matches have been generated.
+
+typeset -ga compprefuncs comppostfuncs
+compprefuncs=()
+comppostfuncs=()
+
+# Loading it now ensures that the `funcstack' parameter is always correct.
+
+: $funcstack
+
+# This function is used to register or delete completion functions. For
+# registering completion functions, it is invoked with the name of the
+# function as it's first argument (after the options). The other
+# arguments depend on what type of completion function is defined. If
+# none of the `-p' and `-k' options is given a function for a command is
+# defined. The arguments after the function name are then interpreted as
+# the names of the command for which the function generates matches.
+# With the `-p' option a function for a name pattern is defined. This 
+# function will be invoked when completing for a command whose name 
+# matches the pattern given as argument after the function name (in this
+# case only one argument is accepted).
+# The option `-P' is like `-p', but the function will be called after
+# trying to find a function defined for the command on the line if no
+# such function could be found.
+# With the `-k' option a function for a special completion keys is 
+# defined and immediately bound to those keys. Here, the extra arguments
+# are the name of one of the builtin completion widgets and any number
+# of key specifications as accepted by the `bindkey' builtin.
+# In any case the `-a' option may be given which makes the function
+# whose name is given as the first argument be autoloaded. When defining
+# a function for command names the `-n' option may be given and keeps
+# the definitions from overriding any previous definitions for the
+# commands; with `-k', the `-n' option prevents compdef from rebinding
+# a key sequence which is already bound.
+# For deleting definitions, the `-d' option must be given. Without the
+# `-p' option, this deletes definitions for functions for the commands
+# whose names are given as arguments. If combined with the `-p' option
+# it deletes the definitions for the patterns given as argument.
+# The `-d' option may not be combined with the `-k' option, i.e.
+# definitions for key function can not be removed.
+#
+# Examples:
+#
+#  compdef -a foo bar baz
+#    make the completion for the commands `bar' and `baz' use the
+#    function `foo' and make this function be autoloaded
+#
+#  compdef -p foo 'c*'
+#    make completion for all command whose name begins with a `c'
+#    generate matches by calling the function `foo' before generating
+#    matches defined for the command itself
+#
+#  compdef -k foo list-choices '^X^M' '\C-xm'
+#    make the function `foo' be invoked when typing `Control-X Control-M'
+#    or `Control-X m'; the function should generate matches and will
+#    behave like the `list-choices' builtin widget
+#
+#  compdef -d bar baz
+#   delete the definitions for the command names `bar' and `baz'
+
+compdef() {
+  local opt autol type func delete eval new i ret=0 cmd svc
+  local -a match mbegin mend
+
+  emulate -L zsh
+  setopt extendedglob
+
+  # Get the options.
+
+  if (( ! $# )); then
+    print -u2 "$0: I need arguments"
+    return 1
+  fi
+
+  while getopts "anpPkKde" opt; do
+    case "$opt" in
+    a)    autol=yes;;
+    n)    new=yes;;
+    [pPkK]) if [[ -n "$type" ]]; then
+            # Error if both `-p' and `-k' are given (or one of them
+	    # twice).
+            print -u2 "$0: type already set to $type"
+	    return 1
+	  fi
+	  if [[ "$opt" = p ]]; then
+	    type=pattern
+	  elif [[ "$opt" = P ]]; then
+	    type=postpattern
+	  elif [[ "$opt" = K ]]; then
+	    type=widgetkey
+	  else
+	    type=key
+	  fi
+	  ;;
+    d) delete=yes;;
+    e) eval=yes;;
+    esac
+  done
+  shift OPTIND-1
+
+  if (( ! $# )); then
+    print -u2 "$0: I need arguments"
+    return 1
+  fi
+
+  if [[ -z "$delete" ]]; then
+    # If the first word contains an equal sign, all words must contain one
+    # and we define which services to use for the commands.
+
+    if [[ -z "$eval" ]] && [[ "$1" = *\=* ]]; then
+      while (( $# )); do
+        if [[ "$1" = *\=* ]]; then
+	  cmd="${1%%\=*}"
+	  svc="${1#*\=}"
+          func="$_comps[${_services[(r)$svc]:-$svc}]"
+          [[ -n ${_services[$svc]} ]] &&
+              svc=${_services[$svc]}
+	  [[ -z "$func" ]] &&
+	      func="${${_patcomps[(K)$svc][1]}:-${_postpatcomps[(K)$svc][1]}}"
+          if [[ -n "$func" ]]; then
+	    _comps[$cmd]="$func"
+	    _services[$cmd]="$svc"
+	  else
+	    print -u2 "$0: unknown command or service: $svc"
+	    ret=1
+	  fi
+	else
+	  print -u2 "$0: invalid argument: $1"
+	  ret=1
+	fi
+        shift
+      done
+
+      return ret
+    fi
+
+    # Adding definitions, first get the name of the function name
+    # and probably do autoloading.
+
+    func="$1"
+    [[ -n "$autol" ]] && autoload -Uz "$func"
+    shift
+
+    case "$type" in
+    widgetkey)
+      while [[ -n $1 ]]; do
+	if [[ $# -lt 3 ]]; then
+	  print -u2 "$0: compdef -K requires <widget> <comp-widget> <key>"
+	  return 1
+	fi
+	[[ $1 = _* ]] || 1="_$1"
+	[[ $2 = .* ]] || 2=".$2"
+        [[ $2 = .menu-select ]] && zmodload -i zsh/complist
+	zle -C "$1" "$2" "$func"
+	if [[ -n $new ]]; then
+	  bindkey "$3" | IFS=$' \t' read -A opt
+	  [[ $opt[-1] = undefined-key ]] && bindkey "$3" "$1"
+	else
+	  bindkey "$3" "$1"
+	fi
+	shift 3
+      done
+      ;;
+    key)
+      if [[ $# -lt 2 ]]; then
+        print -u2 "$0: missing keys"
+	return 1
+      fi
+
+      # Define the widget.
+      if [[ $1 = .* ]]; then
+        [[ $1 = .menu-select ]] && zmodload -i zsh/complist
+	zle -C "$func" "$1" "$func"
+      else
+        [[ $1 = menu-select ]] && zmodload -i zsh/complist
+	zle -C "$func" ".$1" "$func"
+      fi
+      shift
+
+      # And bind the keys...
+      for i; do
+        if [[ -n $new ]]; then
+	   bindkey "$i" | IFS=$' \t' read -A opt
+	   [[ $opt[-1] = undefined-key ]] || continue
+	fi
+        bindkey "$i" "$func"
+      done
+      ;;
+    *)
+      # For commands store the function name in the
+      # associative array, command names as keys.
+      while (( $# )); do
+        if [[ "$1" = -N ]]; then
+          type=normal
+        elif [[ "$1" = -p ]]; then
+          type=pattern
+        elif [[ "$1" = -P ]]; then
+          type=postpattern
+        else
+          case "$type" in
+          pattern)
+	    if [[ $1 = (#b)(*)=(*) ]]; then
+	      _patcomps[$match[1]]="=$match[2]=$func"
+	    else
+	      _patcomps[$1]="$func"
+	    fi
+            ;;
+          postpattern)
+	    if [[ $1 = (#b)(*)=(*) ]]; then
+	      _postpatcomps[$match[1]]="=$match[2]=$func"
+	    else
+	      _postpatcomps[$1]="$func"
+	    fi
+            ;;
+          *)
+            if [[ "$1" = *\=* ]]; then
+	      cmd="${1%%\=*}"
+	      svc=yes
+            else
+	      cmd="$1"
+	      svc=
+            fi
+            if [[ -z "$new" || -z "${_comps[$1]}" ]]; then
+              _comps[$cmd]="$func"
+	      [[ -n "$svc" ]] && _services[$cmd]="${1#*\=}"
+	    fi
+            ;;
+          esac
+        fi
+        shift
+      done
+      ;;
+    esac
+  else
+    # Handle the `-d' option, deleting.
+
+    case "$type" in
+    pattern)
+      unset "_patcomps[$^@]"
+      ;;
+    postpattern)
+      unset "_postpatcomps[$^@]"
+      ;;
+    key)
+      # Oops, cannot do that yet.
+
+      print -u2 "$0: cannot restore key bindings"
+      return 1
+      ;;
+    *)
+      unset "_comps[$^@]"
+    esac
+  fi
+}
+
+# Now we automatically make the definition files autoloaded.
+
+typeset _i_wdirs _i_wfiles
+
+_i_wdirs=()
+_i_wfiles=()
+
+autoload -Uz compaudit
+if [[ -n "$_i_check" ]]; then
+  typeset _i_q
+  if ! eval compaudit; then
+    if [[ -n "$_i_q" ]]; then
+      if [[ "$_i_fail" = ask ]]; then
+        if ! read -q \
+"?zsh compinit: insecure $_i_q, run compaudit for list.
+Ignore insecure $_i_q and continue [y] or abort compinit [n]? "; then
+	  print -u2 "$0: initialization aborted"
+          unfunction compinit compdef
+          unset _comp_dumpfile _comp_secure compprefuncs comppostfuncs \
+                _comps _patcomps _postpatcomps _compautos _lastcomp
+
+          return 1
+        fi
+        _i_wfiles=()
+	_i_wdirs=()
+      else
+        (( $#_i_wfiles )) && _i_files=( "${(@)_i_files:#(${(j:|:)_i_wfiles%.zwc})}"  )
+        (( $#_i_wdirs ))  && _i_files=( "${(@)_i_files:#(${(j:|:)_i_wdirs%.zwc})/*}" )
+      fi
+    fi
+    typeset -g _comp_secure=yes
+  fi
+fi
+
+# Make sure compdump is available, even if we aren't going to use it.
+autoload -Uz compdump compinstall
+
+# If we have a dump file, load it.
+
+_i_done=''
+
+if [[ -f "$_comp_dumpfile" ]]; then
+  if [[ -n "$_i_check" ]]; then
+    IFS=$' \t' read -rA _i_line < "$_comp_dumpfile"
+    if [[ _i_autodump -eq 1 && $_i_line[2] -eq $#_i_files &&
+        $ZSH_VERSION = $_i_line[4] ]]
+    then
+      builtin . "$_comp_dumpfile"
+      _i_done=yes
+    fi
+  else
+    builtin . "$_comp_dumpfile"
+    _i_done=yes
+  fi
+fi
+if [[ -z "$_i_done" ]]; then
+  typeset -A _i_test
+
+  for _i_dir in $fpath; do
+    [[ $_i_dir = . ]] && continue
+    (( $_i_wdirs[(I)$_i_dir] )) && continue
+    for _i_file in $_i_dir/^([^_]*|*~|*.zwc)(N); do
+      _i_name="${_i_file:t}"
+      (( $+_i_test[$_i_name] + $_i_wfiles[(I)$_i_file] )) && continue
+      _i_test[$_i_name]=yes
+      IFS=$' \t' read -rA _i_line < $_i_file
+      _i_tag=$_i_line[1]
+      shift _i_line
+      case $_i_tag in
+      (\#compdef)
+	if [[ $_i_line[1] = -[pPkK](n|) ]]; then
+	  compdef ${_i_line[1]}na "${_i_name}" "${(@)_i_line[2,-1]}"
+	else
+	  compdef -na "${_i_name}" "${_i_line[@]}"
+	fi
+	;;
+      (\#autoload)
+	autoload -Uz "$_i_line[@]" ${_i_name}
+	[[ "$_i_line" != \ # ]] && _compautos[${_i_name}]="$_i_line"
+	;;
+      esac
+    done
+  done
+
+  # If autodumping was requested, do it now.
+
+  if [[ $_i_autodump = 1 ]]; then
+    compdump
+  fi
+fi
+
+# Rebind the standard widgets
+for _i_line in complete-word delete-char-or-list expand-or-complete \
+  expand-or-complete-prefix list-choices menu-complete \
+  menu-expand-or-complete reverse-menu-complete; do
+  zle -C $_i_line .$_i_line _main_complete
+done
+zle -la menu-select && zle -C menu-select .menu-select _main_complete
+
+# If the default completer set includes _expand, and tab is bound
+# to expand-or-complete, rebind it to complete-word instead.
+bindkey '^i' | IFS=$' \t' read -A _i_line
+if [[ ${_i_line[2]} = expand-or-complete ]] &&
+  zstyle -a ':completion:' completer _i_line &&
+  (( ${_i_line[(i)_expand]} <= ${#_i_line} )); then
+  bindkey '^i' complete-word
+fi
+
+unfunction compinit compaudit
+autoload -Uz compinit compaudit
+
+return 0
diff --git a/.zsh.d/zsdoc/data/autoload/.zshrc/promptinit b/.zsh.d/zsdoc/data/autoload/.zshrc/promptinit
new file mode 100644
index 000000000..e27b8779a
--- /dev/null
+++ b/.zsh.d/zsdoc/data/autoload/.zshrc/promptinit
@@ -0,0 +1,263 @@
+##
+## zsh prompt themes extension
+## by Adam Spiers <adam@spiers.net>
+##
+## Load with `autoload -Uz promptinit; promptinit'.
+## Type `prompt -h' for help.
+##
+
+typeset -gaU prompt_themes
+typeset -ga prompt_theme
+typeset -g prompt_newline
+prompt_themes=()
+
+promptinit () {
+  emulate -L zsh
+  setopt extendedglob
+  local ppath='' name theme
+  local -a match mbegin mend
+
+  # Autoload all prompt_*_setup functions in fpath
+  for theme in $^fpath/prompt_*_setup(N); do
+    if [[ $theme == */prompt_(#b)(*)_setup ]]; then
+      name="$match[1]"
+      if [[ -r "$theme" ]]; then
+        prompt_themes=($prompt_themes $name)
+        autoload -Uz prompt_${name}_setup
+      else
+        print "Couldn't read file $theme containing theme $name."
+      fi
+    else
+      print "Eh?  Mismatch between glob patterns in promptinit."
+    fi
+  done
+
+  # To manipulate precmd and preexec hooks...
+  autoload -Uz add-zsh-hook
+
+  # Variables common to all prompt styles
+  prompt_newline=$'\n%{\r%}'
+}
+
+prompt_preview_safely() {
+  emulate -L zsh
+  print -P "%b%f%k"
+  if [[ -z "$prompt_themes[(r)$1]" ]]; then
+    print "Unknown theme: $1"
+    return
+  fi
+
+  # This handles all the stuff from the default :prompt-theme cleanup
+  local +h PS1=$PS1 PS2=$PS2 PS3=$PS3 PS4=$PS4 RPS1=$RPS1 RPS2=$RPS2
+  local +h PROMPT=$PROMPT RPROMPT=$RPOMPT RPROMPT2=$RPROMPT2 PSVAR=$PSVAR
+  local -a precmd_functions preexec_functions prompt_preview_cleanup
+  local -aLl +h zle_highlight
+
+  {
+    # Save and clear current restore-point if any
+    zstyle -g prompt_preview_cleanup :prompt-theme cleanup
+    {
+      zstyle -d :prompt-theme cleanup
+
+      # The next line is a bit ugly.  It (perhaps unnecessarily)
+      # runs the prompt theme setup function to ensure that if
+      # the theme has a _preview function that it's been autoloaded.
+      prompt_${1}_setup
+
+      if typeset +f prompt_${1}_preview >&/dev/null; then
+        prompt_${1}_preview "$@[2,-1]"
+      else
+        prompt_preview_theme "$@"
+      fi
+    } always {
+      # Run any theme-specific cleanup, then reset restore point
+      zstyle -t :prompt-theme cleanup
+    }
+  } always {
+    (( $#prompt_preview_cleanup )) &&
+      zstyle -e :prompt-theme cleanup "${prompt_preview_cleanup[@]}"
+  }
+}
+
+set_prompt() {
+  emulate -L zsh
+  local opt preview theme usage old_theme
+
+  usage='Usage: prompt <options>
+Options:
+    -c              Show currently selected theme and parameters
+    -l              List currently available prompt themes
+    -p [<themes>]   Preview given themes (defaults to all)
+    -h [<theme>]    Display help (for given theme)
+    -s <theme>      Set and save theme
+    <theme>         Switch to new theme immediately (changes not saved)
+
+Use prompt -h <theme> for help on specific themes.'
+
+  getopts "chlps:" opt
+  case "$opt" in
+    (h|p)
+      setopt localtraps
+      if [[ -z "$prompt_theme[1]" ]]; then
+        # Not using a prompt theme; save settings
+        local +h PS1=$PS1 PS2=$PS2 PS3=$PS3 PS4=$PS4 RPS1=$RPS1 RPS2=$RPS2
+        local +h PROMPT=$PROMPT RPROMPT=$RPOMPT RPROMPT2=$RPROMPT2 PSVAR=$PSVAR
+        local -a precmd_functions preexec_functions
+      else
+        trap 'prompt_${prompt_theme[1]}_setup "${(@)prompt_theme[2,-1]}"' 0
+      fi
+      ;;
+  esac
+  case "$opt" in
+    c) if [[ -n $prompt_theme ]]; then
+         print -n "Current prompt theme"
+         (( $#prompt_theme > 1 )) && print -n " with parameters"
+         print " is:\n  $prompt_theme"
+       else
+         print "Current prompt is not a theme."
+       fi
+       return
+       ;;
+    h) if [[ -n "$2" && -n $prompt_themes[(r)$2] ]]; then
+         if functions prompt_$2_setup >/dev/null; then
+           # The next line is a bit ugly.  It (perhaps unnecessarily)
+           # runs the prompt theme setup function to ensure that if
+           # the theme has a _help function that it's been autoloaded.
+           prompt_$2_setup
+         fi
+         if functions prompt_$2_help >/dev/null; then
+           print "Help for $2 theme:\n"
+           prompt_$2_help
+         else
+           print "No help available for $2 theme."
+         fi
+         print "\nType \`prompt -p $2' to preview the theme, \`prompt $2'"
+         print "to try it out, and \`prompt -s $2' to use it in future sessions."
+       else
+         print "$usage"
+       fi
+       ;;
+    l) print Currently available prompt themes:
+       print $prompt_themes
+       return
+       ;;
+    p) preview=( $prompt_themes )
+       (( $#* > 1 )) && preview=( "$@[2,-1]" )
+       for theme in $preview; do
+         [[ "$theme" == "$prompt_theme[*]" ]] && continue
+         prompt_preview_safely "$=theme"
+       done
+       print -P "%b%f%k"
+       ;;
+    s) print "Set and save not yet implemented.  Please ensure your ~/.zshrc"
+       print "contains something similar to the following:\n"
+       print "  autoload -Uz promptinit"
+       print "  promptinit"
+       print "  prompt $*[2,-1]"
+       shift
+       ;&
+    *) if [[ "$1" == 'random' ]]; then
+         local random_themes
+         if (( $#* == 1 )); then
+           random_themes=( $prompt_themes )
+         else
+           random_themes=( "$@[2,-1]" )
+         fi
+         local i=$(( ( $RANDOM % $#random_themes ) + 1 ))
+         argv=( "${=random_themes[$i]}" )
+       fi
+       if [[ -z "$1" || -z $prompt_themes[(r)$1] ]]; then
+         print "$usage"
+         return
+       fi
+
+       # Reset some commonly altered bits to the default
+       local hook
+       for hook in chpwd precmd preexec periodic zshaddhistory zshexit; do
+         add-zsh-hook -D "${hook}" "prompt_*_${hook}"
+       done
+       typeset -ga zle_highlight=( ${zle_highlight:#default:*} )
+       (( ${#zle_highlight} )) || unset zle_highlight
+
+       prompt_$1_setup "$@[2,-1]" && prompt_theme=( "$@" )
+       ;;
+  esac
+}
+
+prompt_cleanup () {
+  local -a cleanup_hooks
+  if zstyle -g cleanup_hooks :prompt-theme cleanup
+  then
+    cleanup_hooks+=(';' "$@")
+    zstyle -e :prompt-theme cleanup "${cleanup_hooks[@]}"
+  elif (( $+prompt_preview_cleanup == 0 ))
+  then
+    print -u2 "prompt_cleanup: no prompt theme active"
+    return 1
+  fi
+}
+
+prompt () {
+  local -a prompt_opts theme_active
+
+  zstyle -g theme_active :prompt-theme cleanup || {
+    # This is done here rather than in set_prompt so that it
+    # is safe and sane for set_prompt to setopt localoptions,
+    # which will be cleared before we arrive back here again.
+    # This is also why we pass around the prompt_opts array.
+    [[ -o promptbang ]] && prompt_opts+=(bang)
+    [[ -o promptcr ]] && prompt_opts+=(cr)
+    [[ -o promptpercent ]] && prompt_opts+=(percent)
+    [[ -o promptsp ]] && prompt_opts+=(sp)
+    [[ -o promptsubst ]] && prompt_opts+=(subst)
+    zstyle -e :prompt-theme cleanup \
+        'zstyle -d :prompt-theme cleanup;' \
+	'prompt_default_setup;' \
+        ${PS1+PS1="${(q)PS1}"} \
+        ${PS2+PS2="${(q)PS2}"} \
+        ${PS3+PS3="${(q)PS3}"} \
+        ${PS4+PS4="${(q)PS4}"} \
+        ${RPS1+RPS1="${(q)RPS1}"} \
+        ${RPS2+RPS2="${(q)RPS2}"} \
+        ${RPROMPT+RPROMPT="${(q)RPROMPT}"} \
+        ${RPROMPT2+RPROMPT2="${(q)RPROMPT2}"} \
+        ${PSVAR+PSVAR="${(q)PSVAR}"} \
+        "precmd_functions=(${(q)precmd_functions[@]})" \
+        "preexec_functions=(${(q)preexec_functions[@]})" \
+        "prompt_opts=( ${prompt_opts[*]} )" \
+        'reply=(yes)'
+  }
+  set_prompt "$@"
+
+  (( ${#prompt_opts} )) &&
+      setopt noprompt{bang,cr,percent,sp,subst} "prompt${^prompt_opts[@]}"
+
+  true
+}
+
+prompt_preview_theme () {
+  emulate -L zsh
+
+  # Check for proper state handling
+  (( $+prompt_preview_cleanup )) || {
+    prompt_preview_safely "$@"
+    return
+  }
+
+  # Minimal preview for prompts that don't supply one
+  local -a prompt_opts
+  print -n "$1 theme"
+  (( $#* > 1 )) && print -n " with parameters \`$*[2,-1]'"
+  print ":"
+  prompt_${1}_setup "$@[2,-1]"
+  (( ${#prompt_opts} )) &&
+      setopt noprompt{bang,cr,percent,sp,subst} "prompt${^prompt_opts[@]}"
+  [[ -n ${precmd_functions[(r)prompt_${1}_precmd]} ]] &&
+    prompt_${1}_precmd
+  [[ -o promptcr ]] && print -n $'\r'; :
+  print -P "${PS1}command arg1 arg2 ... argn"
+  [[ -n ${preexec_functions[(r)prompt_${1}_preexec]} ]] &&
+    prompt_${1}_preexec
+}
+
+[[ -o kshautoload ]] || promptinit "$@"
diff --git a/.zsh.d/zsdoc/data/autoload/.zshrc/vcs_info b/.zsh.d/zsdoc/data/autoload/.zshrc/vcs_info
new file mode 100644
index 000000000..4e9ac6c6a
--- /dev/null
+++ b/.zsh.d/zsdoc/data/autoload/.zshrc/vcs_info
@@ -0,0 +1,148 @@
+## vim:ft=zsh:foldmethod=marker
+##
+## vcs_info - provide version control information
+##
+## Written by Frank Terbeck <ft@bewatermyfriend.org>
+##
+## This file and all corresponding files in Functions/VCS_Info/ are
+## distributed under the same BSD-ish license as zsh itself.
+##
+
+setopt localoptions noksharrays extendedglob NO_shwordsplit
+local file func sys
+local -a static_functions msgs
+local -i maxexports
+
+static_functions=(
+    VCS_INFO_adjust
+    VCS_INFO_bydir_detect
+    VCS_INFO_check_com
+    VCS_INFO_formats
+    VCS_INFO_get_cmd
+    VCS_INFO_hexdump
+    VCS_INFO_hook
+    VCS_INFO_set-patch-format
+    VCS_INFO_maxexports
+    VCS_INFO_nvcsformats
+    VCS_INFO_patch2subject
+    VCS_INFO_quilt
+    VCS_INFO_realpath
+    VCS_INFO_reposub
+    VCS_INFO_set
+
+    vcs_info_hookadd
+    vcs_info_hookdel
+    vcs_info_lastmsg
+    vcs_info_printsys
+    vcs_info_setsys
+)
+
+for func in ${static_functions} ; do
+    autoload -Uz ${func}
+done
+
+[[ -n ${(Mk)parameters:#vcs_info_msg_<->_} ]] && unset ${parameters[(I)vcs_info_msg_<->_]}
+VCS_INFO_maxexports
+VCS_INFO_set --nvcs '-preinit-'
+vcs_info_setsys
+
+# and now, finally create the real vcs_info function
+vcs_info () {
+    emulate -L zsh
+    setopt extendedglob NO_warn_create_global
+
+    [[ -r . ]] || return 0
+
+    local pat
+    local -i found retval
+    local -a enabled disabled dps
+    local usercontext vcs rrn quiltmode
+    local -x LC_MESSAGES
+    local -i maxexports
+    local -a msgs
+    local -A vcs_comm hook_com backend_misc user_data
+
+    LC_MESSAGES=C
+    if [[ -n ${LC_ALL} ]]; then
+        local -x LANG
+        LANG=${LC_ALL}
+        local -x LC_ALL
+    fi
+    vcs='-init-'; rrn='-all-'; quiltmode='addon'
+    usercontext=${1:-default}
+
+    VCS_INFO_hook "start-up"
+    retval=$?
+    if (( retval == 1 )); then
+        return 0
+    elif (( retval == 2 )); then
+        # This needs `max-exports' set. We're still setting it again later
+        # for more specific contexts.
+        VCS_INFO_maxexports
+        VCS_INFO_set --nvcs
+        return 0
+    fi
+
+    zstyle -a ":vcs_info:${vcs}:${usercontext}:${rrn}" "enable" enabled
+    (( ${#enabled} == 0 )) && enabled=( all )
+
+    if [[ -n ${(M)enabled:#(#i)none} ]] ; then
+        [[ -n ${vcs_info_msg_0_} ]] && VCS_INFO_set --nvcs
+        return 0
+    fi
+
+    if [[ -n ${(M)enabled:#(#i)all} ]] ; then
+        enabled=( ${VCS_INFO_backends} )
+        zstyle -a ":vcs_info:${vcs}:${usercontext}:${rrn}" "disable" disabled
+    fi
+
+    zstyle -a ":vcs_info:${vcs}:${usercontext}:${rrn}" "disable-patterns" dps
+
+    for pat in ${dps} ; do
+        if [[ ${PWD} == ${~pat} ]] ; then
+            VCS_INFO_maxexports
+            [[ -n ${vcs_info_msg_0_} ]] && VCS_INFO_set --nvcs
+            return 0
+        fi
+    done
+
+    VCS_INFO_maxexports
+
+    (( found = 0 ))
+    for vcs in ${enabled} ; do
+        [[ -n ${(M)disabled:#${vcs}} ]] && continue
+        if (( ${+functions[VCS_INFO_detect_${vcs}]} == 0 )) ; then
+            printf 'vcs_info: configured unknown backend: '\''%s'\''\n' ${vcs}
+            printf 'vcs_info: use '\''vcs_info_printsys'\'' to find supported systems.\n'
+            continue
+        fi
+        vcs_comm=()
+        VCS_INFO_get_cmd
+        VCS_INFO_detect_${vcs} && (( found = 1 )) && break
+    done
+
+    (( found == 0 )) && {
+        vcs='-quilt-'; quiltmode='standalone'
+        VCS_INFO_quilt standalone || VCS_INFO_set --nvcs
+        return 0
+    }
+
+    VCS_INFO_hook "pre-get-data"
+    retval=$?
+    if (( retval == 1 )); then
+        return 0
+    elif (( retval == 2 )); then
+        VCS_INFO_set --nvcs
+        return 0
+    fi
+
+    VCS_INFO_get_data_${vcs} || {
+        VCS_INFO_set --nvcs
+        return 1
+    }
+
+    VCS_INFO_set
+    return 0
+}
+
+vcs_info "$@"
diff --git a/.zsh.d/zsdoc/data/bodies/.zshenv b/.zsh.d/zsdoc/data/bodies/.zshenv
new file mode 100644
index 000000000..6b4087d6a
--- /dev/null
+++ b/.zsh.d/zsdoc/data/bodies/.zshenv
@@ -0,0 +1,11 @@
+
+
+export ZSH="/usr/share/zsh"
+[[ ! -f "${HOME}/.profile" ]] || \
+	emulate sh -c '. "${HOME}/.profile"'
+[[ ! -f "/etc/profile.d/cnf.sh" ]] || \
+	emulate sh -c '. "/etc/profile.d/cnf.sh"'
+[[ ! -f "${HOME}/perl5/perlbrew/etc/bashrc" ]] || \
+	emulate bash -c '. "${HOME}/perl5/perlbrew/etc/bashrc"'
+[[ ! -f "${ZDOTDIR:-$HOME}/.zwidgets" ]] || \
+	. "${ZDOTDIR:-$HOME}/.zwidgets"
diff --git a/.zsh.d/zsdoc/data/bodies/.zshrc b/.zsh.d/zsdoc/data/bodies/.zshrc
new file mode 100644
index 000000000..805f05d58
--- /dev/null
+++ b/.zsh.d/zsdoc/data/bodies/.zshrc
@@ -0,0 +1,584 @@
+
+trap '{ cleanup; trap -; }' USR1 EXIT
+trap '{ cleanup; trap -; kill -INT $$; }' INT
+trap '{ cleanup; trap -; kill -QUIT $$; }' QUIT
+trap '{ cleanup; trap -; kill -TERM $$; }' TERM
+ZSH_ERROR="$(mktemp)"
+exec 9>&2
+exec 2<>"$ZSH_ERROR"
+[[ -f "$ZSH_ERROR" ]] && rm -f "$ZSH_ERROR" || cleanup
+() {
+	local -a unsetarr setarr
+	unsetarr+=(alwaystoend autolist automenu caseglob casematch checkjobs)
+	unsetarr+=(correctall extendedhistory flowcontrol histfcntllock globalexport)
+	unsetarr+=(globcomplete globsubst histignorespace histsavebycopy)
+	unsetarr+=(histverify multios nomatch printexitvalue sharehistory verbose)
+	setarr+=(appendhistory autocd autopushd bareglobqual beep casematch cbases)
+	setarr+=(chaselinks clobber completeinword correct cprecedences equals)
+	setarr+=(extendedglob globassign globdots globstarshort histexpiredupsfirst)
+	setarr+=(histignorealldups histignoredups histlexwords histreduceblanks)
+	setarr+=(hup incappendhistory interactivecomments kshglob kshoptionprint)
+	setarr+=(listambiguous longlistjobs magicequalsubst octalzeroes)
+	setarr+=(markdirs menucomplete monitor multibyte notify pathdirs pipefail)
+	setarr+=(promptsubst pushdignoredups pushdminus pushdtohome rematchpcre)
+	() for 1 { unsetopt "$1"; }  $unsetarr
+	() for 1 { setopt "$1"; } $setarr
+}
+[[ "$EMACS" == t ]] && unsetopt zle
+bindkey -e
+() for 1 { zle -N "$1" } zle-keymap-select zle-line-init zle-line-finish
+_theme=1
+_km=emacs _emacs=main _vi=
+setescapes
+case "$_km" in
+(vi)
+	printf "$cblock"; printf "$cgrey" ;;
+(emacs)
+	printf "$cblock"; printf "$cyellow" ;;
+esac
+ZSH_CACHE_DIR="${ZDOTDIR:-$HOME/.zsh.d}/cache"
+[[ ! -d "$ZSH_CACHE_DIR" ]] && mkdir "$ZSH_CACHE_DIR"
+zstyle ':completion:*'			rehash true
+zstyle ':completion:*'			use-cache yes
+zstyle ':completion::complete:*'	cache-path "$ZSH_CACHE_DIR"
+zstyle ':history-search-multi-word'	page-size 5
+autoload -U colors && colors
+eval "$(dircolors -b)"
+export CLICOLOR=1 REPORTTIME=5
+HISTFILE="${HOME}/.zsh_history"
+type zshreadhist &>/dev/null && precmd_functions=(zshreadhist $precmd_functions)
+() {
+	local -a au_arr zle_arr zmod_arr
+	au_arr+=(expand-absolute-path up-line-or-beginning-search)
+	au_arr+=(down-line-or-beginning-search filter-select run-help)
+	au_arr+=(regexp-replace edit-command-line nsert-unicode-char)
+	au_arr+=(insert-composed-char tetriscurses tetris zargs zed zmv)
+	zle_arr+=(edit-command-line expand-absolute-path)
+	zle_arr+=(up-line-or-beginning-search down-line-or-beginning-search)
+	zle_arr+=(znt-history-widget znt-cd-widget znt-kill-widget)
+	zle_arr+=(insert-unicode-char tetris zmv)
+	zmod_arr+=(zsh/datetime zsh/mapfile zsh/mathfunc)
+	zmod_arr+=(zsh/terminfo zsh/deltochar zsh/curses)
+	zmod_arr+=(zsh/net/socket zsh/system zsh/net/tcp)
+	zmod_arr+=(zsh/zftp zsh/zprof zsh/zpty zsh/zselect)
+	zmod_arr+=(zsh/pcre zsh/db/gdbm zsh/deltochar)
+	() for 1 { autoload -Uz "$1"; } $au_arr
+	() for 1 { zle -N "$1"; } $zle_arr
+	() for 1 { zmodload "$1"; } $zmod_arr
+}
+unalias run-help help 2>/dev/null
+alias help='run-help'
+typeset -gA AUTOPAIR_PAIRS
+AUTOPAIR_PAIRS=('`' '`' "'" "'" '"' '"' '{' '}' '[' ']' '(' ')')
+typeset -gA AUTOPAIR_LBOUNDS
+AUTOPAIR_LBOUNDS=('`' '`')
+AUTOPAIR_LBOUNDS[all]='[.:/\!]'
+AUTOPAIR_LBOUNDS[quotes]='[]})a-zA-Z0-9]'
+AUTOPAIR_LBOUNDS[braces]=''
+AUTOPAIR_LBOUNDS["'"]="'"
+typeset -gA AUTOPAIR_RBOUNDS
+AUTOPAIR_RBOUNDS[all]='[[{(<,.:?/%$!a-zA-Z0-9]'
+AUTOPAIR_RBOUNDS[quotes]='[a-zA-Z0-9]'
+AUTOPAIR_RBOUNDS[braces]=''
+typeset -ga ZSH_HIGHLIGHT_HIGHLIGHTERS
+ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets line pattern root)
+ZSH_HIGHLIGHT_HIGHLIGHTERS_DIR="${ZDOTDIR:-${HOME}/.zsh.d}/plugins/highlighters"
+ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=8'
+ZSH_AUTOSUGGEST_ORIGINAL_WIDGET_PREFIX=autosuggest-orig-
+ZSH_AUTOSUGGEST_STRATEGY=default
+ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=25
+GIT_PROMPT_SYMBOL="%{$fg[blue]%}±"
+GIT_PROMPT_PREFIX="%{$fg[green]%}[%{$reset_color%}"
+GIT_PROMPT_SUFFIX="%{$fg[green]%}]%{$reset_color%}"
+GIT_PROMPT_AHEAD="%{$fg[red]%}ANUM%{$reset_color%}"
+GIT_PROMPT_BEHIND="%{$fg[cyan]%}BNUM%{$reset_color%}"
+GIT_PROMPT_MERGING="%{$fg[magenta]%}⚡︎%{$reset_color%}"
+GIT_PROMPT_UNTRACKED="%{$fg[red]%}●%{$reset_color%}"
+GIT_PROMPT_MODIFIED="%{$fg[yello w]%}●%{$reset_color%}"
+GIT_PROMPT_STAGED="%{$fg[green]%}●%{$reset_color%}"
+
+case "$_theme" in
+(0)
+	type prompt_clint_setup &>/dev/null && prompt_clint_setup || _theme=1 ;|
+
+(1)
+	PS1='$prompt_newline%{$(echo -en "$reset_color$fg[green]"$(($(:
+		)$(sed -n "s/MemFree:[[:space:]]\+\([0-9]\+\) kB/\1/Ip" $(:
+		)/proc/meminfo)/1024))"$(:
+		)$reset_color$fg[yellow]/"$(($(:
+		)$(sed -n "s/MemTotal:[[:space:]]\+\([0-9]\+\) kB/\1/Ip" $(:
+		)/proc/meminfo)/1024))MB"		$(:
+		)$reset_color$fg[magenta]$(</proc/loadavg)")$(:
+		)$prompt_newline$bold_color$fg[grey]%}[%{$(:
+		)$reset_color$fg[white]%}$$:$PPID %j:%l%{$(:
+		)$bold_color$fg[grey]%}]%{$reset_color$fg[cyan]%}	$(:
+		)%D{%a %d %b %I:%M:%S%P}'
+	if [[ ! -d /proc ]]; then
+		type prompt_clint_setup &>/dev/null && prompt_clint_setup
+	elif (( EUID != 0 )); then
+		PS1+='$bold_color$fg[grey]%}[%{$bold_color$fg[green]%}%n@%m%{$bold_color$fg[grey]%}:%{$(:
+			)$reset_color$fg[white]%}${SSH_TTY} %{$bold_color$fg[red]%}+${SHLVL}%{$(:
+			)$bold_color$fg[grey]%}] %{$bold_color$fg[yellow]%}%~%{$(:
+			)$reset_color$fg[yellow]%} $prompt_newline($SHLVL:%!)%{$(:
+			)$reset_color$fg[cyan]%} %(!.#.$) %{$reset_color%}'
+	else
+		PS1+='$bold_color$fg[grey]%}[%{$bold_color$fg[red]%}%n@%m%{$bold_color$fg[grey]%}:%{$(:
+			)$reset_color$fg[white]%}${SSH_TTY} %{$bold_color$fg[green]%}+${SHLVL}%{$(:
+			)$bold_color$fg[grey]%}] %{$bold_color$fg[yellow]%}%~%{$(:
+			)$reset_color$fg[yellow]%} $prompt_newline($SHLVL:%!)%{$(:
+			)$bold_color$fg[red]%} %(!.#.$) %{$reset_color%}'
+	fi ;;
+
+(*)
+	type prompt_clint_setup >/dev/null 2>&1 && prompt_clint_setup ;;
+esac
+autoload -Uz vcs_info
+if type vcs_info >/dev/null 2>&1; then
+	zstyle ':vcs_info:*' enable git cvs svn
+	zstyle ':vcs_info:*' disable bzr cdv darcs mtn svk tla
+	zstyle ':vcs_info:*' check-for-changes true
+	zstyle ':vcs_info:*:prompt:*' check-for-changes true
+	zstyle ':vcs_info:*:prompt:*' stagedstr "%{$fg[green]%}*%{$reset_color%}"
+	zstyle ':vcs_info:*:prompt:*' unstagedstr "%{$fg[red]%}*%{$reset_color%}"
+	zstyle ':vcs_info:*:prompt:*' branchformat "%r"
+	zstyle ':vcs_info:*:prompt:*' formats "%u%c%{$fg[green]%}[%b]%{$reset_color%}"
+	zstyle ':vcs_info:*:prompt:*' nvcsformats ""
+	zstyle ':vcs_info:*' actionformats \
+		'%F{5}(%f%s%F{5})%F{3}-%F{5}[%F{2}%b%F{3}|%F{1}%a%F{5}]%f '
+	zstyle ':vcs_info:*' formats \
+		'%F{5}(%f%s%F{5})%F{3}-%F{5}[%F{2}%b%F{5}]%f '
+	zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%b%F{1}:%F{3}%r'
+	zstyle ':vcs_info:git:*' actionformats \
+		'%F{3}-%F{5}(%F{7}%r/%S%F{2}[%F{2}%m%F{9}%u%F{6}%c%F{2}]%F{5})%f '
+	zstyle ':vcs_info:git:*' formats \
+		'%F{3}-%F{5}(%F{7}%r/%S%F{2}[%F{2}%m%F{9}%u%F{6}%c%F{2}]%F{5})%f '
+	precmd_functions=( vcs_info $precmd_functions )
+	RPS1='$(check_last_exit_code)%(?,%F{green},%F{red} ┐❨ツ❩┌ )%f$(git_prompt_string)${vcs_info_msg_0_}'
+else
+	RPS1='$(check_last_exit_code)%(?,%F{green},%F{red} ┐❨ツ❩┌ )%f$(git_prompt_string)'
+fi
+fpath[1,0]="${ZDOTDIR:-$HOME/.zsh.d}/zcomps.zwc"
+fpath[1,0]="${ZDOTDIR:-$HOME/.zsh.d}/zfuncs.zwc"
+autoload -U promptinit && promptinit
+autoload -U +X compinit && compinit -u
+autoload -U +X bashcompinit && bashcompinit -u
+[[ -f /etc/profile.d/cnf.sh ]] && \
+	. /etc/profile.d/cnf.sh
+[[ -f /usr/share/bash-completion/completions/dkms ]] && \
+	. /usr/share/bash-completion/completions/dkms
+[[ -d "${ZDOTDIR:-$HOME/.zsh.d}"/plugins ]] && \
+	{ for i in "${ZDOTDIR:-$HOME/.zsh.d}"/plugins/enabled/*.zsh; do . "$i"; done; }
+[[ -f "${HOME}/perl5/perlbrew/etc/perlbrew-completion.bash" ]] && \
+	. "${HOME}/perl5/perlbrew/etc/perlbrew-completion.bash"
+[[ -f "${HOME}/.aliases" ]] && \
+	. "${HOME}/.aliases"
+() for 1 2 { autoload -Uwz "$1"; autoload -Uwz +X "$2"; } "${(M@z)fpath%%*.zwc}"
+
+news_short
+safetytoggle -n
+() {
+	local muhcow="$(print -l -- /usr/share/cows/*(.:r:t) | sort -R | head -1)"
+	host -t txt istheinternetonfire.com | cut -f 2 -d '"' | cowsay -f "$muhcow" -W 50
+}
+[[ "$(type _systemctl)" =~ "autoload" ]] && autoload -Uz +X _systemctl
+type fasd &>/dev/null && eval "$(fasd --init auto)"
+
+if type filter-select &>/dev/null; then
+	filter-select -i
+	bindkey -M filterselect '^E' accept-search
+fi
+
+if type zplug >/dev/null 2>&1; then
+	zplug "oknowton/zsh-dwim"
+	zplug "zsh-users/zsh-autosuggestions"
+	zplug "zsh-users/zsh-syntax-highlighting"
+	zplug "zsh-users/zsh-history-substring-search"
+	zplug 'zplug/zplug', hook-build:'zplug --self-manage'
+	if ! zplug check --verbose; then
+		print -- "Install? [y/N]: "
+		if read -sq; then zplug install; fi
+	fi
+	zplug load --verbose
+fi
+
+zle -N zle-youtube-helper
+zle -N zle-fman
+zle -N zle-compdef
+zle -N zle-toggle-keymap
+zle -N zle-emacs-keymap
+zle -N zle-vi-keymap
+zle -N append-x-selection
+zle -N insert-x-selection
+zle -N yank-x-selection
+zle -N fzf-locate-widget
+zle -N insert-composed-char
+zle -N zle-backwards-delete-to-char
+zle -N zle-backwards-zap-to-char
+zle -N zle-zaw-help
+zle -N zle-less
+zle -N zle-vim
+zle -N zle-fh
+export fzf_default_completion="expand-or-complete-prefix"
+export FZF_COMPLETION_TRIGGER='//'
+bindkey -M emacs '^P' history-substring-search-up
+bindkey -M emacs '^N' history-substring-search-down
+bindkey -M emacs "\e[1~" beginning-of-line
+bindkey -M emacs "\e\e[A" beginning-of-line
+bindkey -M emacs "\e[4~" end-of-line
+bindkey -M emacs "\e\e[B" end-of-line
+bindkey -M emacs "\C-k" kill-whole-line
+bindkey -M emacs "\eu" undo
+bindkey -M vicmd "u" vi-undo-change
+bindkey -M viins "\eu" vi-undo-change
+bindkey -M vicmd "\eu" undo
+bindkey -M vicmd 'k' up-line-or-beginning-search
+bindkey -M vicmd 'j' down-line-or-beginning-search
+bindkey -M vicmd "\e[3~" delete-char
+bindkey -M viins "\e[3~" delete-char
+() for 1 {
+	bindkey -sM "$1" "\e[23~" "*"
+	bindkey -M "$1" "\ep" expand-absolute-path
+	bindkey -M "$1" "\eo" zle-less
+	bindkey -M "$1" "\e\\" insert-last-word
+	bindkey -M "$1" "\eE" tetris
+	bindkey -M "$1" "\e\er" znt-history-widget
+	bindkey -M "$1" "\e\et" znt-cd-widget
+	bindkey -M "$1" "\e\ek" znt-kill-widget
+	bindkey -M "$1" "\C-x\C-h" _complete_help
+	bindkey -M "$1" "\C-xh" _complete_help
+	bindkey -M "$1" "\eOA" up-line-or-beginning-search
+	bindkey -M "$1" "\e[A" up-line-or-beginning-search
+	bindkey -M "$1" "\eOB" down-line-or-beginning-search
+	bindkey -M "$1" "\e[B" down-line-or-beginning-search
+	bindkey -M "$1" '^[[A' up-line-or-beginning-search
+	bindkey -M "$1" '^[[B' down-line-or-beginning-search
+	bindkey -M "$1" "\eOD" backward-word
+	bindkey -M "$1" "\e\e[D" backward-word
+	bindkey -M "$1" "\e[1;5D" backward-word
+	bindkey -M "$1" "\e[1;3D" backward-word
+	bindkey -M "$1" "\e[1;2D" backward-word
+	bindkey -M "$1" "\eOC" forward-word
+	bindkey -M "$1" "\e\e[C" forward-word
+	bindkey -M "$1" "\e[1;5C" forward-word
+	bindkey -M "$1" "\e[1;3C" forward-word
+	bindkey -M "$1" "\e[1;2C" forward-word
+	bindkey -M "$1" "\e[7~" beginning-of-line
+	bindkey -M "$1" "\e[1;5B" beginning-of-line
+	bindkey -M "$1" "\e[1;3B" beginning-of-line
+	bindkey -M "$1" "\e[8~" end-of-line
+	bindkey -M "$1" "\e[1;5A" end-of-line
+	bindkey -M "$1" "\e[1;3A" end-of-line
+	bindkey -M "$1" "\e[1;2B" beginning-of-line
+	bindkey -M "$1" "\e[1;2A" end-of-line
+	bindkey -M "$1" "$terminfo[kcuu1]" history-substring-search-up
+	bindkey -M "$1" "$terminfo[kcud1]" history-substring-search-down
+	bindkey -M "$1" "\e[5~" history-substring-search-up
+	bindkey -M "$1" "\e[6~" history-substring-search-down
+	bindkey -M "$1" "\e-" history-substring-search-up
+	bindkey -M "$1" "\e=" history-substring-search-down
+	bindkey -M "$1" "$(echotc kl)" backward-char
+	bindkey -M "$1" "$(echotc kr)" forward-char
+	bindkey -M "$1" "$(echotc ku)" up-line-or-beginning-search
+	bindkey -M "$1" "$(echotc kd)" down-line-or-beginning-search
+
+	bindkey -M "$1" "\e[3~" delete-char
+	bindkey -M "$1" "\ek" describe-key-briefly
+	bindkey -M "$1" "\C-xe" edit-command-line
+	bindkey -M "$1" "\C-x\C-e" edit-command-line
+	bindkey -M "$1" "\e\ey" zle-youtube-helper
+	bindkey -M "$1" "\eU" up-case-word
+	bindkey -M "$1" "\e\e\e" _history-complete-newer
+	bindkey -M "$1" "\e," zaw
+	bindkey -M "$1" "\e<" zle-zaw-help
+	bindkey -M "$1" "\ew" zle-backwards-delete-to-char
+	bindkey -M "$1" "\ee" delete-to-char
+	bindkey -M "$1" "\eOP" zle-less
+	bindkey -M "$1" "\eOQ" zle-vim
+	bindkey -M "$1" "\eOR" insert-unicode-char
+	bindkey -M "$1" "\eOS" zle-compdef
+	bindkey -M "$1" "\e[P" delete-char
+	bindkey -M "$1" "\C-r" redo
+	bindkey -M "$1" "\e/" zle-fman
+	bindkey -M "$1" "\e?" where-is
+	bindkey -M "$1" "^Xi" insert-unicode-char
+	bindkey -M "$1" "\C-x\C-i" insert-unicode-char
+	bindkey -M "$1" "\e>" autosuggest-clear
+	bindkey -M "$1" "\e[15~" zle-toggle-keymap
+	bindkey -M "$1" "\e[17~" yank-x-selection
+	bindkey -M "$1" "\e[18~" insert-x-selection
+	bindkey -M "$1" "\e[" yank-x-selection
+	bindkey -M "$1" "\e]" insert-x-selection
+
+	bindkey -M "$1" "\e;" fzf-completion
+	bindkey -M "$1" "\e\C-i" fasd-complete
+	bindkey -M "$1" "\e[Z" fasd-complete-d
+	bindkey -M "$1" "\C-i" "$fzf_default_completion"
+	bindkey -M "$1" "\ei" fzf-locate-widget
+	bindkey -M "$1" "\er" fzf-history-widget
+	bindkey -M "$1" "\C-t" transpose-words
+	bindkey -M "$1" "\et" fzf-file-widget
+	if zle -la | grep -q dwim; then
+		bindkey -M "$1" "\C-u" dwim
+		bindkey -M "$1" "\e[19~" dwim
+	fi
+} emacs vicmd viins
+() {
+	local -a defargcmds asmcmds dbpkgs kmods pubkeys seckeys
+
+	defargcmds+=(as auracle autopep8 autopep8-python2 basename bash bsdtar)
+	defargcmds+=(calcc canto-curses canto-daemon canto-remote catdoc cd2raw)
+	defargcmds+=(cdcd cdr2raw cdrdao cd-read cdu cepl cgasm chromium)
+	defargcmds+=(col colordiff compton configure conky cower cpanm cppcheck)
+	defargcmds+=(cpulimit crontab ctags curl define dmidecode elftoc)
+	defargcmds+=(expac fasd file flac2all fusermount-glusterfs fusermount3)
+	defargcmds+=(fzf gnome-keyring-daemon gpg-agent help2man highlight)
+	defargcmds+=(highlight hping hsetroot install keyring kid3-cli)
+	defargcmds+=(kid3-qt ld lighttpd2 ln lrz lua lz4 maim more mpd muttprint)
+	defargcmds+=(mv named netstat netstat newsbeuter node nohup)
+	defargcmds+=(objconv objdump optipng pacconf pactree paste pstree)
+	defargcmds+=(qemu-img qemu-nbd reptyr resolvconf rfc rg rmdir)
+	defargcmds+=(rmlint rst2man rst2man2 saldl scan-build seq shred)
+	defargcmds+=(sox split stat st stjerm strings supybot swapon)
+	defargcmds+=(systool termite test tic tload transmission-cli)
+	defargcmds+=(transmission-create transmission-daemon transmission-edit)
+	defargcmds+=(transmission-get transmission-gtk transmission-qt)
+	defargcmds+=(transmission-remote transmission-remote-cli transmission-remote-cli)
+	defargcmds+=(transmission-remote-gtk transmission-show transset-df)
+	defargcmds+=(updatedb urxvtc urxvtcd urxvtd vanitygen vimpager x11vnc)
+	defargcmds+=(xbindkeys xsel youtube-dl)
+
+	asmcmds+=(${(o)$(cgasm -f '.*' | perl -alne '
+			BEGIN{ my @cmds; }
+			push @cmds, split(/ /, lc $F[0] =~ y|/| |r);
+			END{ print join " ", @cmds;}'
+		)})
+	dbpkgs+=(${(fo@)$(pacman -Qq)})
+	kmods+=(${${(f0@)$(find /usr/lib/modules/$(uname -r) -type f -name '*.ko.gz' 2>/dev/null)%.ko.gz}##*/})
+	pubkeys+=(${${(Mo)$(gpg2 -k --no-default-keyring --list-options no-show-photos):%<*>}//(<|>)/})
+	seckeys+=(${${(Mo)$(gpg2 -K --no-default-keyring --list-options no-show-photos):%<*>}//(<|>)/})
+
+	cgasm_str+=$'_arguments "*:arg:_default" ":assembly instruction:('
+	cgasm_str+="${asmcmds[*]}"
+	cgasm_str+=')" -- '
+	dgpg_str+=$'_arguments "*:arg:_default" ":secret keys:('
+	# dgpg_str+=$'_arguments "*:arg:_default" ":public key:('
+	dgpg_str+="${seckeys[*]}"
+	# dgpg_str+="${pubkeys[*]}"
+	dgpg_str+=$')" -- '
+	hi_str+=$'_arguments "*:file:_files" ":syntax:_files '
+	hi_str+=$'-W \'/usr/share/highlight/langDefs/\' '
+	hi_str+=$'-g \'*.lang(:r)\'" -- '
+	high_str+=$'_arguments "*:file:_files" ":theme:_files '
+	high_str+=$'-W \'/usr/share/highlight/themes\''
+	high_str+=$'-g \'*.theme(:r)\'" ":syntax:_files'
+	high_str+=$'-W \'/usr/share/highlight/langDefs\''
+	high_str+=$'-g \'*.lang(:r)\'" ":out format:'
+	high_str+=$'(html xhtml latex tex rtf odt ansi xterm256 truecolor bbcode pango svg)" -- '
+	pinfo_str+=$'_arguments "*:arg:_default" ":info page:_texinfo" -- '
+	qpc_str+=$'_arguments "*:packages:('
+	qpc_str+="${dbpkgs[*]}"
+	qpc_str+=$')" -- '
+	reptyr_str+=$'_arguments "*:arg:_default" ":processe:_pids" -- '
+	modprobe_str+=$'_arguments "*:arg:_default" ":modules:('
+	modprobe_str+="${kmods[*]}"
+	modprobe_str+=$')" -- '
+
+	() for 1 { compdef _gnu_generic "$1"; } $defargcmds
+
+	compdef "$cgasm_str" cgasm
+	compdef "$dgpg_str" dgpg
+	compdef "$hi_str" hi
+	compdef "$high_str" high
+	compdef "$modprobe_str" modprobe
+	compdef "$pinfo_str" pinfo
+	compdef "$qpc_str" qpc
+	compdef "$reptyr_str" reptyr
+}
+
+compdef _fman fman
+compdef _gem gem
+compdef _git fshow
+compdef _man cppman
+compdef _man tldr
+compdef _pacaur apacman
+compdef _pacaur pml
+compdef _pacaur pspc
+compdef _systemctl_status scrs
+compdef _systemctl_status pscrs
+compdef _systemctl_status uscrs
+compdef _systemctl_status puscrs
+compdef _texinfo info
+compdef _uscrs uscrs
+compdef _vim v
+compdef _pip pip
+compdef _au au
+compdef _au wau
+compdef _pwns pwns
+compdef azle=autoload
+compdef gnpm=npm
+compdef p=perl
+compdef run=gcc
+compdef xs=xsel
+
+# named directories
+hash -d audio="/media/microSDXC/audio"
+hash -d b="${HOME}/bin/"
+hash -d aur="${HOME}/code/aur"
+hash -d calibre="/media/microSDXC/calibre"
+hash -d code="${P:-/store/code/projects}/school"
+hash -d c="${CONF:-/store/dotfiles}"
+hash -d djzomg="/media/microSDXC/Music/djzomg"
+hash -d d="${CONF:-/store/dotfiles}/docs"
+hash -d efi="/boot/efi/EFI"
+hash -d euler="${HOME}/code/euler"
+hash -d g="${HOME}/git"
+hash -d inc="/usr/include"
+hash -d initcpio="/usr/lib/initcpio/install"
+hash -d magnets="${CONF:-/store/dotfiles}/magnets"
+hash -d man="${CONF:-/store/dotfiles}/man"
+hash -d music="/store/music"
+hash -d nginx="/etc/nginx"
+hash -d omz="/usr/share/oh-my-zsh"
+hash -d plugins="/usr/share/oh-my-zsh/plugins"
+hash -d p="${P:-/store/code/projects}"
+hash -d prose="/store/writing"
+hash -d repos="/store/repos"
+hash -d rfc="/usr/share/doc/rfc"
+hash -d s="/media/microSDXC/school"
+hash -d surfraw="/usr/lib/surfraw"
+hash -d stuff="/media/toshiba1TB"
+hash -d systemd="/etc/systemd/system"
+hash -d t="/store/torrents"
+hash -d tt="/media/toshiba1TB/torrents"
+hash -d vim="${HOME}/.vim"
+hash -d wanderlust="/hdd/wanderlust"
+hash -d words="${CONF:-/store/dotfiles}/unixstories"
+hash -d www="/srv/http"
+hash -d z="${ZDOTDIR:-$HOME/.zsh.d}"
+hash -d zf="${ZDOTDIR:-$HOME/.zsh.d}/zfunctions"
+hash -d zc="${ZDOTDIR:-$HOME/.zsh.d}/completions"
+hash -d zp="${ZDOTDIR:-$HOME/.zsh.d}/plugins"
+hash -d znc="/var/lib/znc/.znc/moddata/log/alyptik/freenode/"
+hash -d zsh="$ZSH"
+
+# Define word separators (for stuff like backward-word, forward-word, backward-kill-word,..)
+WORDCHARS=
+# WORDCHARS='_-*~'
+# WORDCHARS='*?_-.[]~=/&;!#$%^ (){}<>'
+
+# Completion tweaks
+zstyle ':completion:*:(ssh|scp|sftp|rsync):*'		hosts \
+	${${(Mu)${${${${(f@)$(cat ${HOME}/.ssh/{config,known_hosts})}%%,*}##*/}##*@}##*.*}%%:*}
+	# ${(Mu)${${(f@)$(<${HOME}/.ssh/known_hosts)}%%,*}%%*.*}
+zstyle ':acceptline'					nocompwarn true
+# allow one error for every two characters typed in approximate completer
+zstyle ':completion:*:approximate:'			max-errors 'reply=("$(( ($#PREFIX+$#SUFFIX)/2 ))" numeric)'
+# zstyle ':completion:*:approximate:'			max-errors 5 numeric
+# don't complete backup files as executables
+zstyle ':completion:*:complete:-command-::commands'	ignored-patterns '(aptitude-*|*\~)'
+# start menu completion only if it could find no unambiguous initial string
+zstyle ':completion:*:correct:*'			insert-unambiguous true
+zstyle ':completion:*:corrections'			format $'%{\e[0;31m%}%d (errors: %e)%{\e[0m%}'
+zstyle ':completion:*:correct:*'			original true
+# activate color-completion
+zstyle ':completion:*:default'				list-colors "${(s.:.)LS_COLORS}"
+# format on completion
+zstyle ':completion:*:descriptions'			format $'%{\e[0;31m%}completing %B%d%b%{\e[0m%}'
+# complete 'cd -<tab>' with menu
+zstyle ':completion:*:*:cd:*:directory-stack'		menu yes select
+# insert all expansions for expand completer
+zstyle ':completion:*:expand:*'				tag-order all-expansions
+zstyle ':completion:*:history-words'			list true
+# activate menu
+zstyle ':completion:*:history-words'			menu yes select
+# ignore duplicate entries
+zstyle ':completion:*:history-words'			remove-all-dups yes
+zstyle ':completion:*:history-words'			stop yes
+# match uppercase from lowercase
+# zstyle ':completion:*'				matcher-list 'm:{a-z}={A-Z}'
+# zstyle ':completion:*'				matcher-list 'm:{a-zA-Z}={A-Za-z}'
+# 0 -- vanilla completion (abc => abc)
+# 1 -- smart case completion (abc => Abc)
+# 2 -- word flex completion (abc => A-big-Car)
+# 3 -- full flex completion (abc => ABraCadabra)
+zstyle ':completion:*'					matcher-list \
+	'' \
+	'm:{a-z\-}={A-Z\_}' \
+	'r:[^[:alpha:]]||[[:alpha:]]=** r:|=* m:{a-z\-}={A-Z\_}' \
+	'r:|?=** m:{a-z\-}={A-Z\_}'
+# separate matches into groups
+zstyle ':completion:*:matches'				group 'yes'
+zstyle ':completion:*'					group-name ''
+zstyle ':completion:*'					menu select
+zstyle ':completion:*:messages'				format '%d'
+zstyle ':completion:*:options'				auto-description '%d'
+# describe options in full
+zstyle ':completion:*:options'				description 'yes'
+# on processes completion complete all user processes
+zstyle ':completion:*:processes'			command 'ps -au$USER'
+# offer indexes before parameters in subscripts
+zstyle ':completion:*:*:-subscript-:*'			tag-order indexes parameters
+# provide verbose completion information
+zstyle ':completion:*'					verbose true
+# recent (as of Dec 2007) zsh versions are able to provide descriptions
+# for commands (read: 1st word in the line) that it will list for the user
+# to choose from. The following disables that, because it's not exactly fast.
+zstyle ':completion:*:-command-:*:'			verbose true
+# set format for warnings
+zstyle ':completion:*:warnings'				format $'%{\e[0;31m%}No matches for:%{\e[0m%} %d'
+# define files to ignore for zcompile
+zstyle ':completion:*:*:zcompile:*'			ignored-patterns '(*~|*.sw[a-p])'
+# zstyle ':completion:*:*:zcompile:*'			ignored-patterns '(*~|*.zwc)'
+zstyle ':completion:correct:'				prompt 'correct to: %e'
+# Ignore completion functions for commands you don't have:
+# zstyle ':completion::(^approximate*):*:functions' ignored-patterns '_*'
+# Provide more processes in completion of programs like killall:
+zstyle ':completion:*:processes-names'			command 'ps c -u ${USER} -o command | uniq'
+zstyle ':completion:*:killall:*'			command 'ps -u ${USER} -o cmd'
+# complete manual by their section
+zstyle ':completion:*:manuals'				separate-sections true
+zstyle ':completion:*:manuals*'				insert-sections   true
+zstyle ':completion:*:man*'				menu yes select
+# provide .. as a completion
+# zstyle ':completion:*'					special-dirs ..
+
+# run rehash on completion so new installed program are found automatically:
+_force_rehash() {
+	(( CURRENT == 1 )) && rehash
+	return 1
+}
+
+# correction
+# try to be smart about when to use what completer...
+zstyle -e ':completion:*'				completer '
+	if [[ $_last_try != "$HISTNO$BUFFER$CURSOR" ]] ; then
+		_last_try="$HISTNO$BUFFER$CURSOR"
+		reply=(_complete _correct _approximate _expand _match _ignored _prefix _files)
+	else
+		if [[ $words[1] == (rm|mv|cp) ]] ; then
+			reply=(_complete _files)
+		else
+			reply=(_oldlist _expand _force_rehash _complete _ignored _correct _approximate _files)
+		fi
+	fi'
+
+# command for process lists, the local web server details and host completion
+zstyle ':completion:*:urls'				local 'www' 'public_html'
+
+# filter-select options
+zstyle ':filter-select:highlight'			matched fg=yellow,standout
+# use $LINES - 10 for filter-select
+zstyle ':filter-select'					max-lines 10
+# enable rotation for filter-select
+zstyle ':filter-select'					rotate-list yes
+# enable case-insensitive search
+zstyle ':filter-select'					case-insensitive yes
+# see below
+zstyle ':filter-select'					extended-search yes
+
+# cleanup
+kill -USR1 $$
+
+# end of .zshrc config
+#
+# all dankness must come to an end :(
diff --git a/.zsh.d/zsdoc/data/bodies/.zwidgets b/.zsh.d/zsdoc/data/bodies/.zwidgets
new file mode 100644
index 000000000..9f137d188
--- /dev/null
+++ b/.zsh.d/zsdoc/data/bodies/.zwidgets
@@ -0,0 +1,2 @@
+
+aliases[=]='noglob ='
diff --git a/.zsh.d/zsdoc/data/descriptions/.zwidgets/= b/.zsh.d/zsdoc/data/descriptions/.zwidgets/=
new file mode 100644
index 000000000..c411ffd18
--- /dev/null
+++ b/.zsh.d/zsdoc/data/descriptions/.zwidgets/=
@@ -0,0 +1 @@
+# inline calculator `= 4 * 2`
diff --git a/.zsh.d/zsdoc/data/descriptions/.zwidgets/check_last_exit_code b/.zsh.d/zsdoc/data/descriptions/.zwidgets/check_last_exit_code
new file mode 100644
index 000000000..c3e49bcd6
--- /dev/null
+++ b/.zsh.d/zsdoc/data/descriptions/.zwidgets/check_last_exit_code
@@ -0,0 +1 @@
+# Function to capture exit code of later command.
diff --git a/.zsh.d/zsdoc/data/descriptions/.zwidgets/fzf-locate-widget b/.zsh.d/zsdoc/data/descriptions/.zwidgets/fzf-locate-widget
new file mode 100644
index 000000000..d51bc7f19
--- /dev/null
+++ b/.zsh.d/zsdoc/data/descriptions/.zwidgets/fzf-locate-widget
@@ -0,0 +1 @@
+# ALT-I - Paste the selected entry from locate output into the command line
diff --git a/.zsh.d/zsdoc/data/descriptions/.zwidgets/git_prompt_string b/.zsh.d/zsdoc/data/descriptions/.zwidgets/git_prompt_string
new file mode 100644
index 000000000..dd9973ad5
--- /dev/null
+++ b/.zsh.d/zsdoc/data/descriptions/.zwidgets/git_prompt_string
@@ -0,0 +1 @@
+# If inside a Git repository, print its branch and state
diff --git a/.zsh.d/zsdoc/data/descriptions/.zwidgets/insert-x-selection b/.zsh.d/zsdoc/data/descriptions/.zwidgets/insert-x-selection
new file mode 100644
index 000000000..ec58bd513
--- /dev/null
+++ b/.zsh.d/zsdoc/data/descriptions/.zwidgets/insert-x-selection
@@ -0,0 +1 @@
+# X clipboard functions
diff --git a/.zsh.d/zsdoc/data/descriptions/.zwidgets/news_short b/.zsh.d/zsdoc/data/descriptions/.zwidgets/news_short
new file mode 100644
index 000000000..1d20051a5
--- /dev/null
+++ b/.zsh.d/zsdoc/data/descriptions/.zwidgets/news_short
@@ -0,0 +1,2 @@
+# Arch latest news
+# The characters "£, §" are used as metacharacters. They should not be encountered in a feed...
diff --git a/.zsh.d/zsdoc/data/descriptions/.zwidgets/parse_git_branch b/.zsh.d/zsdoc/data/descriptions/.zwidgets/parse_git_branch
new file mode 100644
index 000000000..f4d2db731
--- /dev/null
+++ b/.zsh.d/zsdoc/data/descriptions/.zwidgets/parse_git_branch
@@ -0,0 +1 @@
+# Show Git branch/tag, or name-rev if on detached head
diff --git a/.zsh.d/zsdoc/data/descriptions/.zwidgets/parse_git_state b/.zsh.d/zsdoc/data/descriptions/.zwidgets/parse_git_state
new file mode 100644
index 000000000..2e907d11b
--- /dev/null
+++ b/.zsh.d/zsdoc/data/descriptions/.zwidgets/parse_git_state
@@ -0,0 +1 @@
+# Show different symbols as appropriate for various Git repository states
diff --git a/.zsh.d/zsdoc/data/descriptions/.zwidgets/setescapes b/.zsh.d/zsdoc/data/descriptions/.zwidgets/setescapes
new file mode 100644
index 000000000..54bf0a440
--- /dev/null
+++ b/.zsh.d/zsdoc/data/descriptions/.zwidgets/setescapes
@@ -0,0 +1 @@
+# Set term escape strings
diff --git a/.zsh.d/zsdoc/data/descriptions/.zwidgets/zshreadhist b/.zsh.d/zsdoc/data/descriptions/.zwidgets/zshreadhist
new file mode 100644
index 000000000..fdcebc5f4
--- /dev/null
+++ b/.zsh.d/zsdoc/data/descriptions/.zwidgets/zshreadhist
@@ -0,0 +1 @@
+# Make history entries from other zsh instances immediately visible
diff --git a/.zsh.d/zsdoc/data/extended/.zshenv b/.zsh.d/zsdoc/data/extended/.zshenv
new file mode 100644
index 000000000..edccc2bc8
--- /dev/null
+++ b/.zsh.d/zsdoc/data/extended/.zshenv
@@ -0,0 +1,27 @@
+#!/usr/bin/env zsh
+#
+# .zshenv
+#
+# zsh environment
+
+export ZSH="/usr/share/zsh"
+
+# enable gnome keyring for applications run through the terminal, such as SSH
+# if [[ -n "$DESKTOP_SESSION" ]]; then
+#         #pgrep -x gnome-keyring-daemon >/dev/null 2>&1 && eval "$(gnome-keyring-daemon -r -c secrets 2>/dev/null)"
+#         eval "$(gnome-keyring-daemon -s -c secrets 2>/dev/null)"
+#         export SSH_AUTH_SOCK
+# fi
+
+# source personal dotfiles
+[[ ! -f "${HOME}/.profile" ]] || \
+	emulate sh -c '. "${HOME}/.profile"'
+# source command-not-found files.
+[[ ! -f "/etc/profile.d/cnf.sh" ]] || \
+	emulate sh -c '. "/etc/profile.d/cnf.sh"'
+# source perlbrew completions
+[[ ! -f "${HOME}/perl5/perlbrew/etc/bashrc" ]] || \
+	emulate bash -c '. "${HOME}/perl5/perlbrew/etc/bashrc"'
+# define ZLE widgets
+[[ ! -f "${ZDOTDIR:-$HOME}/.zwidgets" ]] || \
+	. "${ZDOTDIR:-$HOME}/.zwidgets"
diff --git a/.zsh.d/zsdoc/data/extended/.zshrc b/.zsh.d/zsdoc/data/extended/.zshrc
new file mode 100644
index 000000000..7eab57aef
--- /dev/null
+++ b/.zsh.d/zsdoc/data/extended/.zshrc
@@ -0,0 +1,2349 @@
+#!/usr/bin/env zsh
+#
+# .zshrc
+#
+# Zsh configuration file
+
+# Catch EXIT, SIGINT, SIGQUIT, SIGTERM, and SIGTRAP signals for clean up
+trap '{ cleanup; trap -; }' USR1 EXIT
+trap '{ cleanup; trap -; kill -INT $$; }' INT
+trap '{ cleanup; trap -; kill -QUIT $$; }' QUIT
+trap '{ cleanup; trap -; kill -TERM $$; }' TERM
+# Redirect errors to a temporary fd, and then append them to a log file
+ZSH_ERROR="$(mktemp)"
+exec 9>&2
+exec 2<>"$ZSH_ERROR"
+[[ -f "$ZSH_ERROR" ]] && rm -f "$ZSH_ERROR" || cleanup
+
+## Set/unset options
+() {
+	local -a unsetarr setarr
+	unsetarr+=(alwaystoend autolist automenu caseglob casematch checkjobs)
+	unsetarr+=(correctall extendedhistory flowcontrol histfcntllock globalexport)
+	unsetarr+=(globcomplete globsubst histignorespace histsavebycopy)
+	unsetarr+=(histverify multios nomatch printexitvalue sharehistory verbose)
+	setarr+=(appendhistory autocd autopushd bareglobqual beep casematch cbases)
+	setarr+=(chaselinks clobber completeinword correct cprecedences equals)
+	setarr+=(extendedglob globassign globdots globstarshort histexpiredupsfirst)
+	setarr+=(histignorealldups histignoredups histlexwords histreduceblanks)
+	setarr+=(hup incappendhistory interactivecomments kshglob kshoptionprint)
+	setarr+=(listambiguous longlistjobs magicequalsubst octalzeroes)
+	setarr+=(markdirs menucomplete monitor multibyte notify pathdirs pipefail)
+	setarr+=(promptsubst pushdignoredups pushdminus pushdtohome rematchpcre)
+	() for 1 { unsetopt "$1"; }  $unsetarr
+	() for 1 { setopt "$1"; } $setarr
+}
+
+# Emacs 19.29 or thereabouts stopped using a terminal type of "emacs" in
+# shell buffers, and instead sets it to "dumb". Zsh only kicks in its special
+# I'm-inside-emacs initialization when the terminal type is "emacs".
+[[ "$EMACS" == t ]] && unsetopt zle
+
+## Set emacs or vi as default
+bindkey -e
+() for 1 { zle -N "$1" } zle-keymap-select zle-line-init zle-line-finish
+# theme: 0 = clint / 1 = custom PS1 / * = wtf are u doing
+_theme=1
+# Initialize _km for ZLE widgets and set initial cursor color
+_km=emacs _emacs=main _vi=
+setescapes
+case "$_km" in
+(vi)
+	printf "$cblock"; printf "$cgrey" ;;
+(emacs)
+	printf "$cblock"; printf "$cyellow" ;;
+esac
+
+# Cache setup
+ZSH_CACHE_DIR="${ZDOTDIR:-$HOME/.zsh.d}/cache"
+[[ ! -d "$ZSH_CACHE_DIR" ]] && mkdir "$ZSH_CACHE_DIR"
+zstyle ':completion:*'			rehash true
+zstyle ':completion:*'			use-cache yes
+zstyle ':completion::complete:*'	cache-path "$ZSH_CACHE_DIR"
+zstyle ':history-search-multi-word'	page-size 5
+# Enable colors in prompt
+autoload -U colors && colors
+eval "$(dircolors -b)"
+export CLICOLOR=1 REPORTTIME=5
+
+# History stuff
+HISTFILE="${HOME}/.zsh_history"
+type zshreadhist &>/dev/null && precmd_functions=(zshreadhist $precmd_functions)
+
+# zmodules
+() {
+	local -a au_arr zle_arr zmod_arr
+	au_arr+=(expand-absolute-path up-line-or-beginning-search)
+	au_arr+=(down-line-or-beginning-search filter-select run-help)
+	au_arr+=(regexp-replace edit-command-line nsert-unicode-char)
+	au_arr+=(insert-composed-char tetriscurses tetris zargs zed zmv)
+	# zle_arr+=(bracketed-paste bracketed-paste-magic)
+	zle_arr+=(edit-command-line expand-absolute-path)
+	zle_arr+=(up-line-or-beginning-search down-line-or-beginning-search)
+	zle_arr+=(znt-history-widget znt-cd-widget znt-kill-widget)
+	zle_arr+=(insert-unicode-char tetris zmv)
+	zmod_arr+=(zsh/datetime zsh/mapfile zsh/mathfunc)
+	zmod_arr+=(zsh/terminfo zsh/deltochar zsh/curses)
+	zmod_arr+=(zsh/net/socket zsh/system zsh/net/tcp)
+	zmod_arr+=(zsh/zftp zsh/zprof zsh/zpty zsh/zselect)
+	zmod_arr+=(zsh/pcre zsh/db/gdbm zsh/deltochar)
+	() for 1 { autoload -Uz "$1"; } $au_arr
+	() for 1 { zle -N "$1"; } $zle_arr
+	() for 1 { zmodload "$1"; } $zmod_arr
+}
+
+# equiv of bash's "help"
+unalias run-help help 2>/dev/null
+alias help='run-help'
+
+#AUTOPAIR_INHIBIT_INIT=${AUTOPAIR_INHIBIT_INIT:-}
+#AUTOPAIR_BETWEEN_WHITESPACE=${AUTOPAIR_BETWEEN_WHITESPACE:-}
+typeset -gA AUTOPAIR_PAIRS
+#AUTOPAIR_PAIRS=('`' '`' "'" "'" '"' '"' '{' '}' '[' ']' '(' ')' '<' '>')
+AUTOPAIR_PAIRS=('`' '`' "'" "'" '"' '"' '{' '}' '[' ']' '(' ')')
+## For example, if AUTOPAIR_LBOUNDS[braces]="[a-zA-Z]", then braces
+## {([) won't be autopaired if the cursor follows an alphabetical character.
+## Individual delimiters can be used too. Setting
+## AUTOPAIR_RBOUNDS['{']="[0-9]" will cause { specifically to not be
+## autopaired when the cursor precedes a number.
+typeset -gA AUTOPAIR_LBOUNDS
+AUTOPAIR_LBOUNDS=('`' '`')
+AUTOPAIR_LBOUNDS[all]='[.:/\!]'
+AUTOPAIR_LBOUNDS[quotes]='[]})a-zA-Z0-9]'
+AUTOPAIR_LBOUNDS[braces]=''
+AUTOPAIR_LBOUNDS["'"]="'"
+typeset -gA AUTOPAIR_RBOUNDS
+AUTOPAIR_RBOUNDS[all]='[[{(<,.:?/%$!a-zA-Z0-9]'
+AUTOPAIR_RBOUNDS[quotes]='[a-zA-Z0-9]'
+AUTOPAIR_RBOUNDS[braces]=''
+## Array declaring active highlighters names.
+typeset -ga ZSH_HIGHLIGHT_HIGHLIGHTERS
+ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets line pattern root)
+ZSH_HIGHLIGHT_HIGHLIGHTERS_DIR="${ZDOTDIR:-${HOME}/.zsh.d}/plugins/highlighters"
+## Zsh autosuggest defaults
+ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=8'
+## Prefix to use when saving original versions of bound widgets
+ZSH_AUTOSUGGEST_ORIGINAL_WIDGET_PREFIX=autosuggest-orig-
+ZSH_AUTOSUGGEST_STRATEGY=default
+ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=25
+# Adapted from code found at <https://gist.github.com/1712320>.
+# Modify the colors and symbols in these variables as desired.
+GIT_PROMPT_SYMBOL="%{$fg[blue]%}±"
+GIT_PROMPT_PREFIX="%{$fg[green]%}[%{$reset_color%}"
+GIT_PROMPT_SUFFIX="%{$fg[green]%}]%{$reset_color%}"
+GIT_PROMPT_AHEAD="%{$fg[red]%}ANUM%{$reset_color%}"
+GIT_PROMPT_BEHIND="%{$fg[cyan]%}BNUM%{$reset_color%}"
+GIT_PROMPT_MERGING="%{$fg[magenta]%}⚡︎%{$reset_color%}"
+GIT_PROMPT_UNTRACKED="%{$fg[red]%}●%{$reset_color%}"
+GIT_PROMPT_MODIFIED="%{$fg[yello w]%}●%{$reset_color%}"
+GIT_PROMPT_STAGED="%{$fg[green]%}●%{$reset_color%}"
+
+case "$_theme" in
+(0)
+	# continue scanning
+	type prompt_clint_setup &>/dev/null && prompt_clint_setup || _theme=1 ;|
+
+(1)
+	# common PS1 section
+	PS1='$prompt_newline%{$(echo -en "$reset_color$fg[green]"$(($(:
+		)$(sed -n "s/MemFree:[[:space:]]\+\([0-9]\+\) kB/\1/Ip" $(:
+		)/proc/meminfo)/1024))"$(:
+		)$reset_color$fg[yellow]/"$(($(:
+		)$(sed -n "s/MemTotal:[[:space:]]\+\([0-9]\+\) kB/\1/Ip" $(:
+		)/proc/meminfo)/1024))MB"		$(:
+		)$reset_color$fg[magenta]$(</proc/loadavg)")$(:
+		)$prompt_newline$bold_color$fg[grey]%}[%{$(:
+		)$reset_color$fg[white]%}$$:$PPID %j:%l%{$(:
+		)$bold_color$fg[grey]%}]%{$reset_color$fg[cyan]%}	$(:
+		)%D{%a %d %b %I:%M:%S%P}'
+	# fallback theme if no /proc
+	if [[ ! -d /proc ]]; then
+		type prompt_clint_setup &>/dev/null && prompt_clint_setup
+	elif (( EUID != 0 )); then
+		# normal colors
+		PS1+='$bold_color$fg[grey]%}[%{$bold_color$fg[green]%}%n@%m%{$bold_color$fg[grey]%}:%{$(:
+			)$reset_color$fg[white]%}${SSH_TTY} %{$bold_color$fg[red]%}+${SHLVL}%{$(:
+			)$bold_color$fg[grey]%}] %{$bold_color$fg[yellow]%}%~%{$(:
+			)$reset_color$fg[yellow]%} $prompt_newline($SHLVL:%!)%{$(:
+			)$reset_color$fg[cyan]%} %(!.#.$) %{$reset_color%}'
+	else
+		# If root, print the prompt character in red. Otherwise, print the prompt in cyan.
+		PS1+='$bold_color$fg[grey]%}[%{$bold_color$fg[red]%}%n@%m%{$bold_color$fg[grey]%}:%{$(:
+			)$reset_color$fg[white]%}${SSH_TTY} %{$bold_color$fg[green]%}+${SHLVL}%{$(:
+			)$bold_color$fg[grey]%}] %{$bold_color$fg[yellow]%}%~%{$(:
+			)$reset_color$fg[yellow]%} $prompt_newline($SHLVL:%!)%{$(:
+			)$bold_color$fg[red]%} %(!.#.$) %{$reset_color%}'
+	fi ;;
+
+(*)
+	# ?????????? how did you hit this wtf
+	type prompt_clint_setup >/dev/null 2>&1 && prompt_clint_setup ;;
+esac
+
+## load VCS module
+autoload -Uz vcs_info
+if type vcs_info >/dev/null 2>&1; then
+	zstyle ':vcs_info:*' enable git cvs svn
+	zstyle ':vcs_info:*' disable bzr cdv darcs mtn svk tla
+	zstyle ':vcs_info:*' check-for-changes true
+	zstyle ':vcs_info:*:prompt:*' check-for-changes true
+	zstyle ':vcs_info:*:prompt:*' stagedstr "%{$fg[green]%}*%{$reset_color%}"
+	zstyle ':vcs_info:*:prompt:*' unstagedstr "%{$fg[red]%}*%{$reset_color%}"
+	zstyle ':vcs_info:*:prompt:*' branchformat "%r"
+	zstyle ':vcs_info:*:prompt:*' formats "%u%c%{$fg[green]%}[%b]%{$reset_color%}"
+	zstyle ':vcs_info:*:prompt:*' nvcsformats ""
+	zstyle ':vcs_info:*' actionformats \
+		'%F{5}(%f%s%F{5})%F{3}-%F{5}[%F{2}%b%F{3}|%F{1}%a%F{5}]%f '
+	zstyle ':vcs_info:*' formats \
+		'%F{5}(%f%s%F{5})%F{3}-%F{5}[%F{2}%b%F{5}]%f '
+	zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%b%F{1}:%F{3}%r'
+	zstyle ':vcs_info:git:*' actionformats \
+		'%F{3}-%F{5}(%F{7}%r/%S%F{2}[%F{2}%m%F{9}%u%F{6}%c%F{2}]%F{5})%f '
+	zstyle ':vcs_info:git:*' formats \
+		'%F{3}-%F{5}(%F{7}%r/%S%F{2}[%F{2}%m%F{9}%u%F{6}%c%F{2}]%F{5})%f '
+	precmd_functions=( vcs_info $precmd_functions )
+	RPS1='$(check_last_exit_code)%(?,%F{green},%F{red} ┐❨ツ❩┌ )%f$(git_prompt_string)${vcs_info_msg_0_}'
+else
+	RPS1='$(check_last_exit_code)%(?,%F{green},%F{red} ┐❨ツ❩┌ )%f$(git_prompt_string)'
+fi
+
+# prepend zcompiled functions/completions to fpath
+fpath[1,0]="${ZDOTDIR:-$HOME/.zsh.d}/zcomps.zwc"
+fpath[1,0]="${ZDOTDIR:-$HOME/.zsh.d}/zfuncs.zwc"
+autoload -U promptinit && promptinit
+autoload -U +X compinit && compinit -u
+autoload -U +X bashcompinit && bashcompinit -u
+# bash specific
+[[ -f /etc/profile.d/cnf.sh ]] && \
+	. /etc/profile.d/cnf.sh
+[[ -f /usr/share/bash-completion/completions/dkms ]] && \
+	. /usr/share/bash-completion/completions/dkms
+# zsh specific
+[[ -d "${ZDOTDIR:-$HOME/.zsh.d}"/plugins ]] && \
+	{ for i in "${ZDOTDIR:-$HOME/.zsh.d}"/plugins/enabled/*.zsh; do . "$i"; done; }
+[[ -f "${HOME}/perl5/perlbrew/etc/perlbrew-completion.bash" ]] && \
+	. "${HOME}/perl5/perlbrew/etc/perlbrew-completion.bash"
+[[ -f "${HOME}/.aliases" ]] && \
+	. "${HOME}/.aliases"
+# autoload functions/completions in *.zwc files
+() for 1 2 { autoload -Uwz "$1"; autoload -Uwz +X "$2"; } "${(M@z)fpath%%*.zwc}"
+
+news_short
+safetytoggle -n
+() {
+	# "Is the internet on fire?" status reports
+	local muhcow="$(print -l -- /usr/share/cows/*(.:r:t) | sort -R | head -1)"
+	host -t txt istheinternetonfire.com | cut -f 2 -d '"' | cowsay -f "$muhcow" -W 50
+}
+
+# autoload completion for systemctl subcommand compdefs
+[[ "$(type _systemctl)" =~ "autoload" ]] && autoload -Uz +X _systemctl
+type fasd &>/dev/null && eval "$(fasd --init auto)"
+
+if type filter-select &>/dev/null; then
+	filter-select -i
+	bindkey -M filterselect '^E' accept-search
+fi
+
+if type zplug >/dev/null 2>&1; then
+	# zplug "hlissner/zsh-autopair"
+	# zplug "kennethreitz/autoenv"
+	# zplug "jocelynmallon/zshmarks"
+	# zplug "StackExchange/blackbox"
+	# zplug "aeruder/zirc"
+	# zplug "tj/git-extras"
+	# zplug "stedolan/jq", from:gh-r, as:command, rename-to:jq
+	# zplug "b4b4r07/emoji-cli", on:"stedolan/jq"
+	zplug "oknowton/zsh-dwim"
+	zplug "zsh-users/zsh-autosuggestions"
+	zplug "zsh-users/zsh-syntax-highlighting"
+	zplug "zsh-users/zsh-history-substring-search"
+	zplug 'zplug/zplug', hook-build:'zplug --self-manage'
+	if ! zplug check --verbose; then
+		print -- "Install? [y/N]: "
+		if read -sq; then zplug install; fi
+	fi
+	zplug load --verbose
+fi
+
+zle -N zle-youtube-helper
+zle -N zle-fman
+zle -N zle-compdef
+zle -N zle-toggle-keymap
+zle -N zle-emacs-keymap
+zle -N zle-vi-keymap
+zle -N append-x-selection
+zle -N insert-x-selection
+zle -N yank-x-selection
+zle -N fzf-locate-widget
+zle -N insert-composed-char
+zle -N zle-backwards-delete-to-char
+zle -N zle-backwards-zap-to-char
+zle -N zle-zaw-help
+zle -N zle-less
+zle -N zle-vim
+zle -N zle-fh
+
+# FZF fuzzy completion
+export fzf_default_completion="expand-or-complete-prefix"
+# 'literal trigger' & fzf-completion keybind to start fuzzy completion
+export FZF_COMPLETION_TRIGGER='//'
+# export FZF_COMPLETION_TRIGGER='**'
+
+# bind P and N for EMACS mode
+bindkey -M emacs '^P' history-substring-search-up
+bindkey -M emacs '^N' history-substring-search-down
+# for inside tmux
+bindkey -M emacs "[1~" beginning-of-line
+bindkey -M emacs "[A" beginning-of-line
+bindkey -M emacs "[4~" end-of-line
+bindkey -M emacs "[B" end-of-line
+bindkey -M emacs "\C-k" kill-whole-line
+bindkey -M emacs "u" undo
+bindkey -M vicmd "u" vi-undo-change
+bindkey -M viins "u" vi-undo-change
+bindkey -M vicmd "u" undo
+## bind k and j for VI mode
+#bindkey -M vicmd 'k' history-substring-search-up
+#bindkey -M vicmd 'j' history-substring-search-down
+bindkey -M vicmd 'k' up-line-or-beginning-search
+bindkey -M vicmd 'j' down-line-or-beginning-search
+bindkey -M vicmd "[3~" delete-char
+bindkey -M viins "[3~" delete-char
+
+# oh god prepare yourself
+#
+# custom bindkey commands
+() for 1 {
+	# F11 inserts a literal '*'
+	bindkey -sM "$1" "[23~" "*"
+	bindkey -M "$1" "p" expand-absolute-path
+	bindkey -M "$1" "o" zle-less
+	# insert the last word from the previous history event at the cursor position
+	bindkey -M "$1" "\" insert-last-word
+	bindkey -M "$1" "E" tetris
+	bindkey -M "$1" "r" znt-history-widget
+	bindkey -M "$1" "t" znt-cd-widget
+	bindkey -M "$1" "k" znt-kill-widget
+	## Ctrl+x h will show the completion context
+	bindkey -M "$1" "\C-x\C-h" _complete_help
+	bindkey -M "$1" "\C-xh" _complete_help
+
+	# movement
+	bindkey -M "$1" "OA" up-line-or-beginning-search
+	bindkey -M "$1" "[A" up-line-or-beginning-search
+	bindkey -M "$1" "OB" down-line-or-beginning-search
+	bindkey -M "$1" "[B" down-line-or-beginning-search
+	bindkey -M "$1" '^[[A' up-line-or-beginning-search
+	bindkey -M "$1" '^[[B' down-line-or-beginning-search
+	bindkey -M "$1" "OD" backward-word
+	bindkey -M "$1" "[D" backward-word
+	bindkey -M "$1" "[1;5D" backward-word
+	bindkey -M "$1" "[1;3D" backward-word
+	bindkey -M "$1" "[1;2D" backward-word
+	bindkey -M "$1" "OC" forward-word
+	bindkey -M "$1" "[C" forward-word
+	bindkey -M "$1" "[1;5C" forward-word
+	bindkey -M "$1" "[1;3C" forward-word
+	bindkey -M "$1" "[1;2C" forward-word
+	bindkey -M "$1" "[7~" beginning-of-line
+	bindkey -M "$1" "[1;5B" beginning-of-line
+	bindkey -M "$1" "[1;3B" beginning-of-line
+	bindkey -M "$1" "[8~" end-of-line
+	bindkey -M "$1" "[1;5A" end-of-line
+	bindkey -M "$1" "[1;3A" end-of-line
+	bindkey -M "$1" "[1;2B" beginning-of-line
+	bindkey -M "$1" "[1;2A" end-of-line
+	# bind UP and DOWN arrow keys (compatibility fallback
+	# for Ubuntu 12.04, Fedora 21, and MacOSX 10.9 users)
+	bindkey -M "$1" "$terminfo[kcuu1]" history-substring-search-up
+	bindkey -M "$1" "$terminfo[kcud1]" history-substring-search-down
+	bindkey -M "$1" "[5~" history-substring-search-up
+	bindkey -M "$1" "[6~" history-substring-search-down
+	bindkey -M "$1" "-" history-substring-search-up
+	bindkey -M "$1" "=" history-substring-search-down
+	# Fixes from http://zsh.sourceforge.net/FAQ/zshfaq03.html#l25
+	bindkey -M "$1" "$(echotc kl)" backward-char
+	bindkey -M "$1" "$(echotc kr)" forward-char
+	bindkey -M "$1" "$(echotc ku)" up-line-or-beginning-search
+	bindkey -M "$1" "$(echotc kd)" down-line-or-beginning-search
+
+	bindkey -M "$1" "[3~" delete-char
+	bindkey -M "$1" "k" describe-key-briefly
+	bindkey -M "$1" "\C-xe" edit-command-line
+	bindkey -M "$1" "\C-x\C-e" edit-command-line
+	bindkey -M "$1" "y" zle-youtube-helper
+	bindkey -M "$1" "U" up-case-word
+	bindkey -M "$1" "" _history-complete-newer
+	bindkey -M "$1" "," zaw
+	bindkey -M "$1" "<" zle-zaw-help
+	bindkey -M "$1" "w" zle-backwards-delete-to-char
+	bindkey -M "$1" "e" delete-to-char
+	bindkey -M "$1" "OP" zle-less
+	bindkey -M "$1" "OQ" zle-vim
+	bindkey -M "$1" "OR" insert-unicode-char
+	bindkey -M "$1" "OS" zle-compdef
+	bindkey -M "$1" "[P" delete-char
+	bindkey -M "$1" "\C-r" redo
+	## Call fman() on current cmdline after word-splitting
+	bindkey -M "$1" "/" zle-fman
+	bindkey -M "$1" "?" where-is
+	bindkey -M "$1" "^Xi" insert-unicode-char
+	bindkey -M "$1" "\C-x\C-i" insert-unicode-char
+	bindkey -M "$1" ">" autosuggest-clear
+	## F5: Toggle keymap
+	# bindkey -M "$1" "k" zle-toggle-keymap
+	bindkey -M "$1" "[15~" zle-toggle-keymap
+	bindkey -M "$1" "[17~" yank-x-selection
+	bindkey -M "$1" "[18~" insert-x-selection
+	bindkey -M "$1" "[" yank-x-selection
+	bindkey -M "$1" "]" insert-x-selection
+	# bindkey -M "$1" "[18~" append-x-selection
+	# F9: Insert composed character
+	# bindkey -M emacs "[19~" insert-composed-char
+
+	bindkey -M "$1" ";" fzf-completion
+	bindkey -M "$1" "\C-i" fasd-complete
+	# bindkey -M "$1" "[Z" fzf-complete-f
+	bindkey -M "$1" "[Z" fasd-complete-d
+	bindkey -M "$1" "\C-i" "$fzf_default_completion"
+	bindkey -M "$1" "i" fzf-locate-widget
+	bindkey -M "$1" "r" fzf-history-widget
+	bindkey -M "$1" "\C-t" transpose-words
+	bindkey -M "$1" "t" fzf-file-widget
+	## A Zsh Do What I Mean key. Attempts to predict what you will want to do next.
+	## Usage: Type a command and hit control-u and zsh-dwim will attempt to transform your command.
+	if zle -la | grep -q dwim; then
+		bindkey -M "$1" "\C-u" dwim
+		bindkey -M "$1" "[19~" dwim
+	fi
+} emacs vicmd viins
+
+# more uglyness soz
+#
+# custom compdefs with generated and hardcoded arrays
+() {
+	local -a defargcmds asmcmds dbpkgs kmods pubkeys seckeys
+
+	defargcmds+=(as auracle autopep8 autopep8-python2 basename bash bsdtar)
+	defargcmds+=(calcc canto-curses canto-daemon canto-remote catdoc cd2raw)
+	defargcmds+=(cdcd cdr2raw cdrdao cd-read cdu cepl cgasm chromium)
+	defargcmds+=(col colordiff compton configure conky cower cpanm cppcheck)
+	defargcmds+=(cpulimit crontab ctags curl define dmidecode elftoc)
+	defargcmds+=(expac fasd file flac2all fusermount-glusterfs fusermount3)
+	defargcmds+=(fzf gnome-keyring-daemon gpg-agent help2man highlight)
+	defargcmds+=(highlight hping hsetroot install keyring kid3-cli)
+	defargcmds+=(kid3-qt ld lighttpd2 ln lrz lua lz4 maim more mpd muttprint)
+	defargcmds+=(mv named netstat netstat newsbeuter node nohup)
+	defargcmds+=(objconv objdump optipng pacconf pactree paste pstree)
+	defargcmds+=(qemu-img qemu-nbd reptyr resolvconf rfc rg rmdir)
+	defargcmds+=(rmlint rst2man rst2man2 saldl scan-build seq shred)
+	defargcmds+=(sox split stat st stjerm strings supybot swapon)
+	defargcmds+=(systool termite test tic tload transmission-cli)
+	defargcmds+=(transmission-create transmission-daemon transmission-edit)
+	defargcmds+=(transmission-get transmission-gtk transmission-qt)
+	defargcmds+=(transmission-remote transmission-remote-cli transmission-remote-cli)
+	defargcmds+=(transmission-remote-gtk transmission-show transset-df)
+	defargcmds+=(updatedb urxvtc urxvtcd urxvtd vanitygen vimpager x11vnc)
+	defargcmds+=(xbindkeys xsel youtube-dl)
+
+	asmcmds+=(${(o)$(cgasm -f '.*' | perl -alne '
+			BEGIN{ my @cmds; }
+			push @cmds, split(/ /, lc $F[0] =~ y|/| |r);
+			END{ print join " ", @cmds;}'
+		)})
+	dbpkgs+=(${(fo@)$(pacman -Qq)})
+	kmods+=(${${(f0@)$(find /usr/lib/modules/$(uname -r) -type f -name '*.ko.gz' 2>/dev/null)%.ko.gz}##*/})
+	pubkeys+=(${${(Mo)$(gpg2 -k --no-default-keyring --list-options no-show-photos):%<*>}//(<|>)/})
+	seckeys+=(${${(Mo)$(gpg2 -K --no-default-keyring --list-options no-show-photos):%<*>}//(<|>)/})
+
+	cgasm_str+=$'_arguments "*:arg:_default" ":assembly instruction:('
+	cgasm_str+="${asmcmds[*]}"
+	cgasm_str+=')" -- '
+	dgpg_str+=$'_arguments "*:arg:_default" ":secret keys:('
+	# dgpg_str+=$'_arguments "*:arg:_default" ":public key:('
+	dgpg_str+="${seckeys[*]}"
+	# dgpg_str+="${pubkeys[*]}"
+	dgpg_str+=$')" -- '
+	hi_str+=$'_arguments "*:file:_files" ":syntax:_files '
+	hi_str+=$'-W \'/usr/share/highlight/langDefs/\' '
+	hi_str+=$'-g \'*.lang(:r)\'" -- '
+	high_str+=$'_arguments "*:file:_files" ":theme:_files '
+	high_str+=$'-W \'/usr/share/highlight/themes\''
+	high_str+=$'-g \'*.theme(:r)\'" ":syntax:_files'
+	high_str+=$'-W \'/usr/share/highlight/langDefs\''
+	high_str+=$'-g \'*.lang(:r)\'" ":out format:'
+	high_str+=$'(html xhtml latex tex rtf odt ansi xterm256 truecolor bbcode pango svg)" -- '
+	pinfo_str+=$'_arguments "*:arg:_default" ":info page:_texinfo" -- '
+	qpc_str+=$'_arguments "*:packages:('
+	qpc_str+="${dbpkgs[*]}"
+	qpc_str+=$')" -- '
+	reptyr_str+=$'_arguments "*:arg:_default" ":processe:_pids" -- '
+	modprobe_str+=$'_arguments "*:arg:_default" ":modules:('
+	modprobe_str+="${kmods[*]}"
+	modprobe_str+=$')" -- '
+
+	() for 1 { compdef _gnu_generic "$1"; } $defargcmds
+
+	compdef "$cgasm_str" cgasm
+	compdef "$dgpg_str" dgpg
+	compdef "$hi_str" hi
+	compdef "$high_str" high
+	compdef "$modprobe_str" modprobe
+	compdef "$pinfo_str" pinfo
+	compdef "$qpc_str" qpc
+	compdef "$reptyr_str" reptyr
+}
+
+compdef _fman fman
+compdef _gem gem
+compdef _git fshow
+compdef _man cppman
+compdef _man tldr
+compdef _pacaur apacman
+compdef _pacaur pml
+compdef _pacaur pspc
+compdef _systemctl_status scrs
+compdef _systemctl_status pscrs
+compdef _systemctl_status uscrs
+compdef _systemctl_status puscrs
+compdef _texinfo info
+compdef _uscrs uscrs
+compdef _vim v
+compdef _pip pip
+compdef _au au
+compdef _au wau
+compdef _pwns pwns
+compdef azle=autoload
+compdef gnpm=npm
+compdef p=perl
+compdef run=gcc
+compdef xs=xsel
+
+# named directories
+hash -d audio="/media/microSDXC/audio"
+hash -d b="${HOME}/bin/"
+hash -d aur="${HOME}/code/aur"
+hash -d calibre="/media/microSDXC/calibre"
+hash -d code="${P:-/store/code/projects}/school"
+hash -d c="${CONF:-/store/dotfiles}"
+hash -d djzomg="/media/microSDXC/Music/djzomg"
+hash -d d="${CONF:-/store/dotfiles}/docs"
+hash -d efi="/boot/efi/EFI"
+hash -d euler="${HOME}/code/euler"
+hash -d g="${HOME}/git"
+hash -d inc="/usr/include"
+hash -d initcpio="/usr/lib/initcpio/install"
+hash -d magnets="${CONF:-/store/dotfiles}/magnets"
+hash -d man="${CONF:-/store/dotfiles}/man"
+hash -d music="/store/music"
+hash -d nginx="/etc/nginx"
+hash -d omz="/usr/share/oh-my-zsh"
+hash -d plugins="/usr/share/oh-my-zsh/plugins"
+hash -d p="${P:-/store/code/projects}"
+hash -d prose="/store/writing"
+hash -d repos="/store/repos"
+hash -d rfc="/usr/share/doc/rfc"
+hash -d s="/media/microSDXC/school"
+hash -d surfraw="/usr/lib/surfraw"
+hash -d stuff="/media/toshiba1TB"
+hash -d systemd="/etc/systemd/system"
+hash -d t="/store/torrents"
+hash -d tt="/media/toshiba1TB/torrents"
+hash -d vim="${HOME}/.vim"
+hash -d wanderlust="/hdd/wanderlust"
+hash -d words="${CONF:-/store/dotfiles}/unixstories"
+hash -d www="/srv/http"
+hash -d z="${ZDOTDIR:-$HOME/.zsh.d}"
+hash -d zf="${ZDOTDIR:-$HOME/.zsh.d}/zfunctions"
+hash -d zc="${ZDOTDIR:-$HOME/.zsh.d}/completions"
+hash -d zp="${ZDOTDIR:-$HOME/.zsh.d}/plugins"
+hash -d znc="/var/lib/znc/.znc/moddata/log/alyptik/freenode/"
+hash -d zsh="$ZSH"
+
+# Define word separators (for stuff like backward-word, forward-word, backward-kill-word,..)
+WORDCHARS=
+# WORDCHARS='_-*~'
+# WORDCHARS='*?_-.[]~=/&;!#$%^ (){}<>'
+
+# Completion tweaks
+zstyle ':completion:*:(ssh|scp|sftp|rsync):*'		hosts \
+	${${(Mu)${${${${(f@)$(cat ${HOME}/.ssh/{config,known_hosts})}%%,*}##*/}##*@}##*.*}%%:*}
+	# ${(Mu)${${(f@)$(<${HOME}/.ssh/known_hosts)}%%,*}%%*.*}
+zstyle ':acceptline'					nocompwarn true
+# allow one error for every two characters typed in approximate completer
+zstyle ':completion:*:approximate:'			max-errors 'reply=("$(( ($#PREFIX+$#SUFFIX)/2 ))" numeric)'
+# zstyle ':completion:*:approximate:'			max-errors 5 numeric
+# don't complete backup files as executables
+zstyle ':completion:*:complete:-command-::commands'	ignored-patterns '(aptitude-*|*\~)'
+# start menu completion only if it could find no unambiguous initial string
+zstyle ':completion:*:correct:*'			insert-unambiguous true
+zstyle ':completion:*:corrections'			format $'%{[0;31m%}%d (errors: %e)%{[0m%}'
+zstyle ':completion:*:correct:*'			original true
+# activate color-completion
+zstyle ':completion:*:default'				list-colors "${(s.:.)LS_COLORS}"
+# format on completion
+zstyle ':completion:*:descriptions'			format $'%{[0;31m%}completing %B%d%b%{[0m%}'
+# complete 'cd -<tab>' with menu
+zstyle ':completion:*:*:cd:*:directory-stack'		menu yes select
+# insert all expansions for expand completer
+zstyle ':completion:*:expand:*'				tag-order all-expansions
+zstyle ':completion:*:history-words'			list true
+# activate menu
+zstyle ':completion:*:history-words'			menu yes select
+# ignore duplicate entries
+zstyle ':completion:*:history-words'			remove-all-dups yes
+zstyle ':completion:*:history-words'			stop yes
+# match uppercase from lowercase
+# zstyle ':completion:*'				matcher-list 'm:{a-z}={A-Z}'
+# zstyle ':completion:*'				matcher-list 'm:{a-zA-Z}={A-Za-z}'
+# 0 -- vanilla completion (abc => abc)
+# 1 -- smart case completion (abc => Abc)
+# 2 -- word flex completion (abc => A-big-Car)
+# 3 -- full flex completion (abc => ABraCadabra)
+zstyle ':completion:*'					matcher-list \
+	'' \
+	'm:{a-z\-}={A-Z\_}' \
+	'r:[^[:alpha:]]||[[:alpha:]]=** r:|=* m:{a-z\-}={A-Z\_}' \
+	'r:|?=** m:{a-z\-}={A-Z\_}'
+# separate matches into groups
+zstyle ':completion:*:matches'				group 'yes'
+zstyle ':completion:*'					group-name ''
+zstyle ':completion:*'					menu select
+zstyle ':completion:*:messages'				format '%d'
+zstyle ':completion:*:options'				auto-description '%d'
+# describe options in full
+zstyle ':completion:*:options'				description 'yes'
+# on processes completion complete all user processes
+zstyle ':completion:*:processes'			command 'ps -au$USER'
+# offer indexes before parameters in subscripts
+zstyle ':completion:*:*:-subscript-:*'			tag-order indexes parameters
+# provide verbose completion information
+zstyle ':completion:*'					verbose true
+# recent (as of Dec 2007) zsh versions are able to provide descriptions
+# for commands (read: 1st word in the line) that it will list for the user
+# to choose from. The following disables that, because it's not exactly fast.
+zstyle ':completion:*:-command-:*:'			verbose true
+# set format for warnings
+zstyle ':completion:*:warnings'				format $'%{[0;31m%}No matches for:%{[0m%} %d'
+# define files to ignore for zcompile
+zstyle ':completion:*:*:zcompile:*'			ignored-patterns '(*~|*.sw[a-p])'
+# zstyle ':completion:*:*:zcompile:*'			ignored-patterns '(*~|*.zwc)'
+zstyle ':completion:correct:'				prompt 'correct to: %e'
+# Ignore completion functions for commands you don't have:
+# zstyle ':completion::(^approximate*):*:functions' ignored-patterns '_*'
+# Provide more processes in completion of programs like killall:
+zstyle ':completion:*:processes-names'			command 'ps c -u ${USER} -o command | uniq'
+zstyle ':completion:*:killall:*'			command 'ps -u ${USER} -o cmd'
+# complete manual by their section
+zstyle ':completion:*:manuals'				separate-sections true
+zstyle ':completion:*:manuals*'				insert-sections   true
+zstyle ':completion:*:man*'				menu yes select
+# provide .. as a completion
+# zstyle ':completion:*'					special-dirs ..
+
+# run rehash on completion so new installed program are found automatically:
+_force_rehash() {
+	(( CURRENT == 1 )) && rehash
+	return 1
+}
+
+# correction
+# try to be smart about when to use what completer...
+zstyle -e ':completion:*'				completer '
+	if [[ $_last_try != "$HISTNO$BUFFER$CURSOR" ]] ; then
+		_last_try="$HISTNO$BUFFER$CURSOR"
+		reply=(_complete _correct _approximate _expand _match _ignored _prefix _files)
+	else
+		if [[ $words[1] == (rm|mv|cp) ]] ; then
+			reply=(_complete _files)
+		else
+			reply=(_oldlist _expand _force_rehash _complete _ignored _correct _approximate _files)
+		fi
+	fi'
+
+# command for process lists, the local web server details and host completion
+zstyle ':completion:*:urls'				local 'www' 'public_html'
+
+# filter-select options
+zstyle ':filter-select:highlight'			matched fg=yellow,standout
+# use $LINES - 10 for filter-select
+zstyle ':filter-select'					max-lines 10
+# enable rotation for filter-select
+zstyle ':filter-select'					rotate-list yes
+# enable case-insensitive search
+zstyle ':filter-select'					case-insensitive yes
+# see below
+zstyle ':filter-select'					extended-search yes
+
+# cleanup
+kill -USR1 $$
+
+# end of .zshrc config
+#
+# all dankness must come to an end :(
+
+bashcompinit() {
+#autoload
+
+_bash_complete() {
+  local ret=1
+  local -a suf matches
+  local -x COMP_POINT COMP_CWORD
+  local -a COMP_WORDS COMPREPLY BASH_VERSINFO
+  local -x COMP_LINE="$words"
+  local -A savejobstates savejobtexts
+
+  (( COMP_POINT = 1 + ${#${(j. .)words[1,CURRENT]}} + $#QIPREFIX + $#IPREFIX + $#PREFIX ))
+  (( COMP_CWORD = CURRENT - 1))
+  COMP_WORDS=( $words )
+  BASH_VERSINFO=( 2 05b 0 1 release )
+
+  savejobstates=( ${(kv)jobstates} )
+  savejobtexts=( ${(kv)jobtexts} )
+
+  [[ ${argv[${argv[(I)nospace]:-0}-1]} = -o ]] && suf=( -S '' )
+
+  matches=( ${(f)"$(compgen $@ -- ${words[CURRENT]})"} )
+
+  if [[ -n $matches ]]; then
+    if [[ ${argv[${argv[(I)filenames]:-0}-1]} = -o ]]; then
+      compset -P '*/' && matches=( ${matches##*/} )
+      compset -S '/*' && matches=( ${matches%%/*} )
+      compadd -Q -f "${suf[@]}" -a matches && ret=0
+    else
+      compadd -Q "${suf[@]}" -a matches && ret=0
+    fi
+  fi
+
+  if (( ret )); then
+    if [[ ${argv[${argv[(I)default]:-0}-1]} = -o ]]; then
+      _default "${suf[@]}" && ret=0
+    elif [[ ${argv[${argv[(I)dirnames]:-0}-1]} = -o ]]; then
+      _directories "${suf[@]}" && ret=0
+    fi
+  fi
+
+  return ret
+}
+
+compgen() {
+  local opts prefix suffix job OPTARG OPTIND ret=1
+  local -a name res results jids
+  local -A shortopts
+
+  # words changes behavior: words[1] -> words[0]
+  emulate -L sh
+  setopt kshglob noshglob braceexpand nokshautoload
+
+  shortopts=(
+    a alias b builtin c command d directory e export f file
+    g group j job k keyword u user v variable
+  )
+
+  while getopts "o:A:G:C:F:P:S:W:X:abcdefgjkuv" name; do
+    case $name in
+      [abcdefgjkuv]) OPTARG="${shortopts[$name]}" ;&
+      A)
+        case $OPTARG in
+	  alias) results+=( "${(k)aliases[@]}" ) ;;
+	  arrayvar) results+=( "${(k@)parameters[(R)array*]}" ) ;;
+	  binding) results+=( "${(k)widgets[@]}" ) ;;
+	  builtin) results+=( "${(k)builtins[@]}" "${(k)dis_builtins[@]}" ) ;;
+	  command)
+	    results+=(
+	      "${(k)commands[@]}" "${(k)aliases[@]}" "${(k)builtins[@]}"
+	      "${(k)functions[@]}" "${(k)reswords[@]}"
+	    )
+	  ;;
+	  directory)
+	    setopt bareglobqual
+	    results+=( ${IPREFIX}${PREFIX}*${SUFFIX}${ISUFFIX}(N-/) )
+	    setopt nobareglobqual
+	  ;;
+	  disabled) results+=( "${(k)dis_builtins[@]}" ) ;;
+	  enabled) results+=( "${(k)builtins[@]}" ) ;;
+	  export) results+=( "${(k)parameters[(R)*export*]}" ) ;;
+	  file)
+	    setopt bareglobqual
+	    results+=( ${IPREFIX}${PREFIX}*${SUFFIX}${ISUFFIX}(N) )
+	    setopt nobareglobqual
+	  ;;
+	  function) results+=( "${(k)functions[@]}" ) ;;
+	  group)
+	    emulate zsh
+	    _groups -U -O res
+	    emulate sh
+	    setopt kshglob noshglob braceexpand
+	    results+=( "${res[@]}" )
+	  ;;
+	  hostname)
+	    emulate zsh
+	    _hosts -U -O res
+	    emulate sh
+	    setopt kshglob noshglob braceexpand
+	    results+=( "${res[@]}" )
+	  ;;
+	  job) results+=( "${savejobtexts[@]%% *}" );;
+	  keyword) results+=( "${(k)reswords[@]}" ) ;;
+	  running)
+	    jids=( "${(@k)savejobstates[(R)running*]}" )
+	    for job in "${jids[@]}"; do
+	      results+=( ${savejobtexts[$job]%% *} )
+	    done
+	  ;;
+	  stopped)
+	    jids=( "${(@k)savejobstates[(R)suspended*]}" )
+	    for job in "${jids[@]}"; do
+	      results+=( ${savejobtexts[$job]%% *} )
+	    done
+	  ;;
+	  setopt|shopt) results+=( "${(k)options[@]}" ) ;;
+	  signal) results+=( "SIG${^signals[@]}" ) ;;
+	  user) results+=( "${(k)userdirs[@]}" ) ;;
+      	  variable) results+=( "${(k)parameters[@]}" ) ;;
+	  helptopic) ;;
+	esac
+      ;;
+      F)
+        COMPREPLY=()
+        local -a args
+        args=( "${words[0]}" "${@[-1]}" "${words[CURRENT-2]}" )
+        (){
+          # There may be more things we need to add to this typeset to
+          # protect bash functions from compsys special variable names
+          typeset -h words
+          $OPTARG "${args[@]}"
+        }
+	results+=( "${COMPREPLY[@]}" )
+      ;;
+      G)
+        setopt nullglob
+        results+=( ${~OPTARG} )
+	unsetopt nullglob
+      ;;
+      W) results+=( ${(Q)~=OPTARG} ) ;;
+      C) results+=( $(eval $OPTARG) ) ;;
+      P) prefix="$OPTARG" ;;
+      S) suffix="$OPTARG" ;;
+      X)
+        if [[ ${OPTARG[0]} = '!' ]]; then
+	  results=( "${(M)results[@]:#${OPTARG#?}}" )
+	else
+ 	  results=( "${results[@]:#$OPTARG}" )
+	fi
+      ;;
+    esac
+  done
+  
+  # support for the last, `word' option to compgen. Zsh's matching does a
+  # better job but if you need to, comment this in and use compadd -U
+  # (( $# >= OPTIND)) && results=( "${(M)results[@]:#${@[-1]}*}" )
+
+  print -l -r -- "$prefix${^results[@]}$suffix"
+}
+
+complete() {
+  emulate -L zsh
+  local args void cmd print remove
+  args=( "$@" )
+  zparseopts -D -a void o: A: G: W: C: F: P: S: X: a b c d e f g j k u v \
+      p=print r=remove
+  if [[ -n $print ]]; then
+    printf 'complete %2$s %1$s\n' "${(@kv)_comps[(R)_bash*]#* }"
+  elif [[ -n $remove ]]; then
+    for cmd; do
+      unset "_comps[$cmd]"
+    done
+  else
+    compdef _bash_complete\ ${(j. .)${(q)args[1,-1-$#]}} "$@"
+  fi
+}
+
+unfunction bashcompinit
+autoload -Uz bashcompinit
+return 0
+}
+
+colors() {
+# Put standard ANSI color codes in shell parameters for easy use.
+# Note that some terminals do not support all combinations.
+
+emulate -L zsh
+
+typeset -Ag color colour
+
+color=(
+# Codes listed in this array are from ECMA-48, Section 8.3.117, p. 61.
+# Those that are commented out are not widely supported or aren't closely
+# enough related to color manipulation, but are included for completeness.
+
+# Attribute codes:
+  00 none                 # 20 gothic
+  01 bold                 # 21 double-underline
+  02 faint                  22 normal
+  03 standout               23 no-standout
+  04 underline              24 no-underline
+  05 blink                  25 no-blink
+# 06 fast-blink           # 26 proportional
+  07 reverse                27 no-reverse
+  08 conceal                28 no-conceal
+# 09 strikethrough        # 29 no-strikethrough
+
+# Font selection:
+# 10 font-default
+# 11 font-first
+# 12 font-second
+# 13 font-third
+# 14 font-fourth
+# 15 font-fifth
+# 16 font-sixth
+# 17 font-seventh
+# 18 font-eighth
+# 19 font-ninth
+
+# Text color codes:
+  30 black                  40 bg-black
+  31 red                    41 bg-red
+  32 green                  42 bg-green
+  33 yellow                 43 bg-yellow
+  34 blue                   44 bg-blue
+  35 magenta                45 bg-magenta
+  36 cyan                   46 bg-cyan
+  37 white                  47 bg-white
+# 38 iso-8316-6           # 48 bg-iso-8316-6
+  39 default                49 bg-default
+
+# Other codes:
+# 50 no-proportional
+# 51 border-rectangle
+# 52 border-circle
+# 53 overline
+# 54 no-border
+# 55 no-overline
+# 56 through 59 reserved
+
+# Ideogram markings:
+# 60 underline-or-right
+# 61 double-underline-or-right
+# 62 overline-or-left
+# 63 double-overline-or-left
+# 64 stress
+# 65 no-ideogram-marking
+)
+
+# A word about black and white:  The "normal" shade of white is really a
+# very pale grey on many terminals; to get truly white text, you have to
+# use bold white, and to get a truly white background you have to use
+# bold reverse white bg-xxx where xxx is your desired foreground color
+# (and which means the foreground is also bold).
+
+# Map in both directions; could do this with e.g. ${(k)colors[(i)normal]},
+# but it's clearer to include them all both ways.
+
+local k
+for k in ${(k)color}; do color[${color[$k]}]=$k; done
+
+# Add "fg-" keys for all the text colors, for clarity.
+
+for k in ${color[(I)3?]}; do color[fg-${color[$k]}]=$k; done
+
+# This is inaccurate, but the prompt theme system needs it.
+
+color[grey]=${color[black]}
+color[fg-grey]=${color[grey]}
+color[bg-grey]=${color[bg-black]}
+
+# Assistance for the color-blind.
+
+colour=(${(kv)color})	# A case where ksh namerefs would be useful ...
+
+# The following are terminal escape sequences used by colored prompt themes.
+
+local lc=$'\e[' rc=m	# Standard ANSI terminal escape values
+
+typeset -Hg reset_color bold_color
+reset_color="$lc${color[none]}$rc"
+bold_color="$lc${color[bold]}$rc"
+
+# Foreground
+
+typeset -AHg fg fg_bold fg_no_bold
+for k in ${(k)color[(I)fg-*]}; do
+    fg[${k#fg-}]="$lc${color[$k]}$rc"
+    fg_bold[${k#fg-}]="$lc${color[bold]};${color[$k]}$rc"
+    fg_no_bold[${k#fg-}]="$lc${color[normal]};${color[$k]}$rc"
+done
+
+# Background
+
+typeset -AHg bg bg_bold bg_no_bold
+for k in ${(k)color[(I)bg-*]}; do
+    bg[${k#bg-}]="$lc${color[$k]}$rc"
+    bg_bold[${k#bg-}]="$lc${color[bold]};${color[$k]}$rc"
+    bg_no_bold[${k#bg-}]="$lc${color[normal]};${color[$k]}$rc"
+done
+}
+
+compinit() {
+# Initialisation for new style completion. This mainly contains some helper
+# functions and setup. Everything else is split into different files that
+# will automatically be made autoloaded (see the end of this file).  The
+# names of the files that will be considered for autoloading are those that
+# begin with an underscores (like `_condition).
+#
+# The first line of each of these files is read and must indicate what
+# should be done with its contents:
+#
+#   `#compdef <names ...>'
+#     If the first line looks like this, the file is autoloaded as a
+#     function and that function will be called to generate the matches
+#     when completing for one of the commands whose <names> are given.
+#     The names may also be interspersed with `-T <assoc>' options
+#     specifying for which set of functions this should be added.
+#
+#   `#compdef -[pP] <patterns ...>'
+#     This defines a function that should be called to generate matches
+#     for commands whose name matches <pattern>. Note that only one pattern
+#     may be given.
+#
+#   `#compdef -k <style> [ <key-sequence> ... ]'
+#     This is used to bind special completions to all the given
+#     <key-sequence>(s). The <style> is the name of one of the built-in
+#     completion widgets (complete-word, delete-char-or-list,
+#     expand-or-complete, expand-or-complete-prefix, list-choices,
+#     menu-complete, menu-expand-or-complete, or reverse-menu-complete).
+#     This creates a widget behaving like <style> so that the
+#     completions are chosen as given in the rest of the file,
+#     rather than by the context.  The widget has the same name as
+#     the autoload file and can be bound using bindkey in the normal way.
+#
+#   `#compdef -K <widget-name> <style> <key-sequence> [ ... ]'
+#     This is similar to -k, except it takes any number of sets of
+#     three arguments.  In each set, the widget <widget-name> will
+#     be defined, which will behave as <style>, as with -k, and will
+#     be bound to <key-sequence>, exactly one of which must be defined.
+#     <widget-name> must be different for each:  this must begin with an
+#     underscore, else one will be added, and should not clash with other
+#     completion widgets (names based on the name of the function are the
+#     clearest), but is otherwise arbitrary.  It can be tested in the
+#     function by the parameter $WIDGET.
+#
+#   `#autoload [ <options> ]'
+#     This is for helper functions that are not used to
+#     generate matches, but should automatically be loaded
+#     when they are called. The <options> will be given to the
+#     autoload builtin when making the function autoloaded. Note
+#     that this need not include `-U' and `-z'.
+#
+# Note that no white space is allowed between the `#' and the rest of
+# the string.
+#
+# Functions that are used to generate matches should return zero if they
+# were able to add matches and non-zero otherwise.
+#
+# See the file `compdump' for how to speed up initialisation.
+
+# If we got the `-d'-flag, we will automatically dump the new state (at
+# the end).  This takes the dumpfile as an argument.  -d (with the
+# default dumpfile) is now the default; to turn off dumping use -D.
+
+# The -C flag bypasses both the check for rebuilding the dump file and the
+# usual call to compaudit; the -i flag causes insecure directories found by
+# compaudit to be ignored, and the -u flag causes all directories found by
+# compaudit to be used (without security checking).  Otherwise the user is
+# queried for whether to use or ignore the insecure directories (which
+# means compinit should not be called from non-interactive shells).
+
+emulate -L zsh
+setopt extendedglob
+
+typeset _i_dumpfile _i_files _i_line _i_done _i_dir _i_autodump=1
+typeset _i_tag _i_file _i_addfiles _i_fail=ask _i_check=yes _i_name
+
+while [[ $# -gt 0 && $1 = -[dDiuC] ]]; do
+  case "$1" in
+  -d)
+    _i_autodump=1
+    shift
+    if [[ $# -gt 0 && "$1" != -[dfQC] ]]; then
+      _i_dumpfile="$1"
+      shift
+    fi
+    ;;
+  -D)
+    _i_autodump=0
+    shift
+    ;;
+  -i)
+    _i_fail=ign
+    shift
+    ;;
+  -u)
+    _i_fail=use
+    shift
+    ;;
+  -C)
+    _i_check=
+    shift
+    ;;
+  esac
+done
+
+# The associative arrays containing the definitions for the commands and
+# services.
+
+typeset -gHA _comps _services _patcomps _postpatcomps
+
+# `_compautos' contains the names and options for autoloaded functions
+# that get options.
+
+typeset -gHA _compautos
+
+# The associative array use to report information about the last
+# completion to the outside.
+
+typeset -gHA _lastcomp
+
+# Remember dumpfile.
+if [[ -n $_i_dumpfile ]]; then
+  # Explicitly supplied dumpfile.
+  typeset -g _comp_dumpfile="$_i_dumpfile"
+else
+  typeset -g _comp_dumpfile="${ZDOTDIR:-$HOME}/.zcompdump"
+fi
+
+# The standard options set in completion functions.
+
+typeset -gHa _comp_options
+_comp_options=(
+       bareglobqual
+       extendedglob
+       glob
+       multibyte
+       multifuncdef
+       nullglob
+       rcexpandparam
+       unset
+    NO_allexport
+    NO_aliases
+    NO_cshnullglob
+    NO_cshjunkiequotes
+    NO_errexit
+    NO_errreturn
+    NO_globassign
+    NO_globsubst
+    NO_histsubstpattern
+    NO_ignorebraces
+    NO_ignoreclosebraces
+    NO_kshglob
+    NO_ksharrays
+    NO_kshtypeset
+    NO_markdirs
+    NO_octalzeroes
+    NO_posixbuiltins
+    NO_posixidentifiers
+    NO_shwordsplit
+    NO_shglob
+    NO_warnnestedvar
+    NO_warncreateglobal
+)
+
+# And this one should be `eval'ed at the beginning of every entry point
+# to the completion system.  It sets up what we currently consider a
+# sane environment.  That means we set the options above, make sure we
+# have a valid stdin descriptor (zle closes it before calling widgets)
+# and don't get confused by user's ZERR trap handlers.
+
+typeset -gH _comp_setup='local -A _comp_caller_options;
+             _comp_caller_options=(${(kv)options[@]});
+             setopt localoptions localtraps localpatterns ${_comp_options[@]};
+             local IFS=$'\'\ \\t\\r\\n\\0\'';
+             builtin enable -p \| \~ \( \? \* \[ \< \^ \# 2>&-;
+             exec </dev/null;
+             trap - ZERR;
+             local -a reply;
+             local REPLY'
+
+# These can hold names of functions that are to be called before/after all
+# matches have been generated.
+
+typeset -ga compprefuncs comppostfuncs
+compprefuncs=()
+comppostfuncs=()
+
+# Loading it now ensures that the `funcstack' parameter is always correct.
+
+: $funcstack
+
+# This function is used to register or delete completion functions. For
+# registering completion functions, it is invoked with the name of the
+# function as it's first argument (after the options). The other
+# arguments depend on what type of completion function is defined. If
+# none of the `-p' and `-k' options is given a function for a command is
+# defined. The arguments after the function name are then interpreted as
+# the names of the command for which the function generates matches.
+# With the `-p' option a function for a name pattern is defined. This 
+# function will be invoked when completing for a command whose name 
+# matches the pattern given as argument after the function name (in this
+# case only one argument is accepted).
+# The option `-P' is like `-p', but the function will be called after
+# trying to find a function defined for the command on the line if no
+# such function could be found.
+# With the `-k' option a function for a special completion keys is 
+# defined and immediately bound to those keys. Here, the extra arguments
+# are the name of one of the builtin completion widgets and any number
+# of key specifications as accepted by the `bindkey' builtin.
+# In any case the `-a' option may be given which makes the function
+# whose name is given as the first argument be autoloaded. When defining
+# a function for command names the `-n' option may be given and keeps
+# the definitions from overriding any previous definitions for the
+# commands; with `-k', the `-n' option prevents compdef from rebinding
+# a key sequence which is already bound.
+# For deleting definitions, the `-d' option must be given. Without the
+# `-p' option, this deletes definitions for functions for the commands
+# whose names are given as arguments. If combined with the `-p' option
+# it deletes the definitions for the patterns given as argument.
+# The `-d' option may not be combined with the `-k' option, i.e.
+# definitions for key function can not be removed.
+#
+# Examples:
+#
+#  compdef -a foo bar baz
+#    make the completion for the commands `bar' and `baz' use the
+#    function `foo' and make this function be autoloaded
+#
+#  compdef -p foo 'c*'
+#    make completion for all command whose name begins with a `c'
+#    generate matches by calling the function `foo' before generating
+#    matches defined for the command itself
+#
+#  compdef -k foo list-choices '^X^M' '\C-xm'
+#    make the function `foo' be invoked when typing `Control-X Control-M'
+#    or `Control-X m'; the function should generate matches and will
+#    behave like the `list-choices' builtin widget
+#
+#  compdef -d bar baz
+#   delete the definitions for the command names `bar' and `baz'
+
+compdef() {
+  local opt autol type func delete eval new i ret=0 cmd svc
+  local -a match mbegin mend
+
+  emulate -L zsh
+  setopt extendedglob
+
+  # Get the options.
+
+  if (( ! $# )); then
+    print -u2 "$0: I need arguments"
+    return 1
+  fi
+
+  while getopts "anpPkKde" opt; do
+    case "$opt" in
+    a)    autol=yes;;
+    n)    new=yes;;
+    [pPkK]) if [[ -n "$type" ]]; then
+            # Error if both `-p' and `-k' are given (or one of them
+	    # twice).
+            print -u2 "$0: type already set to $type"
+	    return 1
+	  fi
+	  if [[ "$opt" = p ]]; then
+	    type=pattern
+	  elif [[ "$opt" = P ]]; then
+	    type=postpattern
+	  elif [[ "$opt" = K ]]; then
+	    type=widgetkey
+	  else
+	    type=key
+	  fi
+	  ;;
+    d) delete=yes;;
+    e) eval=yes;;
+    esac
+  done
+  shift OPTIND-1
+
+  if (( ! $# )); then
+    print -u2 "$0: I need arguments"
+    return 1
+  fi
+
+  if [[ -z "$delete" ]]; then
+    # If the first word contains an equal sign, all words must contain one
+    # and we define which services to use for the commands.
+
+    if [[ -z "$eval" ]] && [[ "$1" = *\=* ]]; then
+      while (( $# )); do
+        if [[ "$1" = *\=* ]]; then
+	  cmd="${1%%\=*}"
+	  svc="${1#*\=}"
+          func="$_comps[${_services[(r)$svc]:-$svc}]"
+          [[ -n ${_services[$svc]} ]] &&
+              svc=${_services[$svc]}
+	  [[ -z "$func" ]] &&
+	      func="${${_patcomps[(K)$svc][1]}:-${_postpatcomps[(K)$svc][1]}}"
+          if [[ -n "$func" ]]; then
+	    _comps[$cmd]="$func"
+	    _services[$cmd]="$svc"
+	  else
+	    print -u2 "$0: unknown command or service: $svc"
+	    ret=1
+	  fi
+	else
+	  print -u2 "$0: invalid argument: $1"
+	  ret=1
+	fi
+        shift
+      done
+
+      return ret
+    fi
+
+    # Adding definitions, first get the name of the function name
+    # and probably do autoloading.
+
+    func="$1"
+    [[ -n "$autol" ]] && autoload -Uz "$func"
+    shift
+
+    case "$type" in
+    widgetkey)
+      while [[ -n $1 ]]; do
+	if [[ $# -lt 3 ]]; then
+	  print -u2 "$0: compdef -K requires <widget> <comp-widget> <key>"
+	  return 1
+	fi
+	[[ $1 = _* ]] || 1="_$1"
+	[[ $2 = .* ]] || 2=".$2"
+        [[ $2 = .menu-select ]] && zmodload -i zsh/complist
+	zle -C "$1" "$2" "$func"
+	if [[ -n $new ]]; then
+	  bindkey "$3" | IFS=$' \t' read -A opt
+	  [[ $opt[-1] = undefined-key ]] && bindkey "$3" "$1"
+	else
+	  bindkey "$3" "$1"
+	fi
+	shift 3
+      done
+      ;;
+    key)
+      if [[ $# -lt 2 ]]; then
+        print -u2 "$0: missing keys"
+	return 1
+      fi
+
+      # Define the widget.
+      if [[ $1 = .* ]]; then
+        [[ $1 = .menu-select ]] && zmodload -i zsh/complist
+	zle -C "$func" "$1" "$func"
+      else
+        [[ $1 = menu-select ]] && zmodload -i zsh/complist
+	zle -C "$func" ".$1" "$func"
+      fi
+      shift
+
+      # And bind the keys...
+      for i; do
+        if [[ -n $new ]]; then
+	   bindkey "$i" | IFS=$' \t' read -A opt
+	   [[ $opt[-1] = undefined-key ]] || continue
+	fi
+        bindkey "$i" "$func"
+      done
+      ;;
+    *)
+      # For commands store the function name in the
+      # associative array, command names as keys.
+      while (( $# )); do
+        if [[ "$1" = -N ]]; then
+          type=normal
+        elif [[ "$1" = -p ]]; then
+          type=pattern
+        elif [[ "$1" = -P ]]; then
+          type=postpattern
+        else
+          case "$type" in
+          pattern)
+	    if [[ $1 = (#b)(*)=(*) ]]; then
+	      _patcomps[$match[1]]="=$match[2]=$func"
+	    else
+	      _patcomps[$1]="$func"
+	    fi
+            ;;
+          postpattern)
+	    if [[ $1 = (#b)(*)=(*) ]]; then
+	      _postpatcomps[$match[1]]="=$match[2]=$func"
+	    else
+	      _postpatcomps[$1]="$func"
+	    fi
+            ;;
+          *)
+            if [[ "$1" = *\=* ]]; then
+	      cmd="${1%%\=*}"
+	      svc=yes
+            else
+	      cmd="$1"
+	      svc=
+            fi
+            if [[ -z "$new" || -z "${_comps[$1]}" ]]; then
+              _comps[$cmd]="$func"
+	      [[ -n "$svc" ]] && _services[$cmd]="${1#*\=}"
+	    fi
+            ;;
+          esac
+        fi
+        shift
+      done
+      ;;
+    esac
+  else
+    # Handle the `-d' option, deleting.
+
+    case "$type" in
+    pattern)
+      unset "_patcomps[$^@]"
+      ;;
+    postpattern)
+      unset "_postpatcomps[$^@]"
+      ;;
+    key)
+      # Oops, cannot do that yet.
+
+      print -u2 "$0: cannot restore key bindings"
+      return 1
+      ;;
+    *)
+      unset "_comps[$^@]"
+    esac
+  fi
+}
+
+# Now we automatically make the definition files autoloaded.
+
+typeset _i_wdirs _i_wfiles
+
+_i_wdirs=()
+_i_wfiles=()
+
+autoload -Uz compaudit
+if [[ -n "$_i_check" ]]; then
+  typeset _i_q
+  if ! eval compaudit; then
+    if [[ -n "$_i_q" ]]; then
+      if [[ "$_i_fail" = ask ]]; then
+        if ! read -q \
+"?zsh compinit: insecure $_i_q, run compaudit for list.
+Ignore insecure $_i_q and continue [y] or abort compinit [n]? "; then
+	  print -u2 "$0: initialization aborted"
+          unfunction compinit compdef
+          unset _comp_dumpfile _comp_secure compprefuncs comppostfuncs \
+                _comps _patcomps _postpatcomps _compautos _lastcomp
+
+          return 1
+        fi
+        _i_wfiles=()
+	_i_wdirs=()
+      else
+        (( $#_i_wfiles )) && _i_files=( "${(@)_i_files:#(${(j:|:)_i_wfiles%.zwc})}"  )
+        (( $#_i_wdirs ))  && _i_files=( "${(@)_i_files:#(${(j:|:)_i_wdirs%.zwc})/*}" )
+      fi
+    fi
+    typeset -g _comp_secure=yes
+  fi
+fi
+
+# Make sure compdump is available, even if we aren't going to use it.
+autoload -Uz compdump compinstall
+
+# If we have a dump file, load it.
+
+_i_done=''
+
+if [[ -f "$_comp_dumpfile" ]]; then
+  if [[ -n "$_i_check" ]]; then
+    IFS=$' \t' read -rA _i_line < "$_comp_dumpfile"
+    if [[ _i_autodump -eq 1 && $_i_line[2] -eq $#_i_files &&
+        $ZSH_VERSION = $_i_line[4] ]]
+    then
+      builtin . "$_comp_dumpfile"
+      _i_done=yes
+    fi
+  else
+    builtin . "$_comp_dumpfile"
+    _i_done=yes
+  fi
+fi
+if [[ -z "$_i_done" ]]; then
+  typeset -A _i_test
+
+  for _i_dir in $fpath; do
+    [[ $_i_dir = . ]] && continue
+    (( $_i_wdirs[(I)$_i_dir] )) && continue
+    for _i_file in $_i_dir/^([^_]*|*~|*.zwc)(N); do
+      _i_name="${_i_file:t}"
+      (( $+_i_test[$_i_name] + $_i_wfiles[(I)$_i_file] )) && continue
+      _i_test[$_i_name]=yes
+      IFS=$' \t' read -rA _i_line < $_i_file
+      _i_tag=$_i_line[1]
+      shift _i_line
+      case $_i_tag in
+      (\#compdef)
+	if [[ $_i_line[1] = -[pPkK](n|) ]]; then
+	  compdef ${_i_line[1]}na "${_i_name}" "${(@)_i_line[2,-1]}"
+	else
+	  compdef -na "${_i_name}" "${_i_line[@]}"
+	fi
+	;;
+      (\#autoload)
+	autoload -Uz "$_i_line[@]" ${_i_name}
+	[[ "$_i_line" != \ # ]] && _compautos[${_i_name}]="$_i_line"
+	;;
+      esac
+    done
+  done
+
+  # If autodumping was requested, do it now.
+
+  if [[ $_i_autodump = 1 ]]; then
+    compdump
+  fi
+fi
+
+# Rebind the standard widgets
+for _i_line in complete-word delete-char-or-list expand-or-complete \
+  expand-or-complete-prefix list-choices menu-complete \
+  menu-expand-or-complete reverse-menu-complete; do
+  zle -C $_i_line .$_i_line _main_complete
+done
+zle -la menu-select && zle -C menu-select .menu-select _main_complete
+
+# If the default completer set includes _expand, and tab is bound
+# to expand-or-complete, rebind it to complete-word instead.
+bindkey '^i' | IFS=$' \t' read -A _i_line
+if [[ ${_i_line[2]} = expand-or-complete ]] &&
+  zstyle -a ':completion:' completer _i_line &&
+  (( ${_i_line[(i)_expand]} <= ${#_i_line} )); then
+  bindkey '^i' complete-word
+fi
+
+unfunction compinit compaudit
+autoload -Uz compinit compaudit
+
+return 0
+}
+
+promptinit() {
+##
+## zsh prompt themes extension
+## by Adam Spiers <adam@spiers.net>
+##
+## Load with `autoload -Uz promptinit; promptinit'.
+## Type `prompt -h' for help.
+##
+
+typeset -gaU prompt_themes
+typeset -ga prompt_theme
+typeset -g prompt_newline
+prompt_themes=()
+
+promptinit () {
+  emulate -L zsh
+  setopt extendedglob
+  local ppath='' name theme
+  local -a match mbegin mend
+
+  # Autoload all prompt_*_setup functions in fpath
+  for theme in $^fpath/prompt_*_setup(N); do
+    if [[ $theme == */prompt_(#b)(*)_setup ]]; then
+      name="$match[1]"
+      if [[ -r "$theme" ]]; then
+        prompt_themes=($prompt_themes $name)
+        autoload -Uz prompt_${name}_setup
+      else
+        print "Couldn't read file $theme containing theme $name."
+      fi
+    else
+      print "Eh?  Mismatch between glob patterns in promptinit."
+    fi
+  done
+
+  # To manipulate precmd and preexec hooks...
+  autoload -Uz add-zsh-hook
+
+  # Variables common to all prompt styles
+  prompt_newline=$'\n%{\r%}'
+}
+
+prompt_preview_safely() {
+  emulate -L zsh
+  print -P "%b%f%k"
+  if [[ -z "$prompt_themes[(r)$1]" ]]; then
+    print "Unknown theme: $1"
+    return
+  fi
+
+  # This handles all the stuff from the default :prompt-theme cleanup
+  local +h PS1=$PS1 PS2=$PS2 PS3=$PS3 PS4=$PS4 RPS1=$RPS1 RPS2=$RPS2
+  local +h PROMPT=$PROMPT RPROMPT=$RPOMPT RPROMPT2=$RPROMPT2 PSVAR=$PSVAR
+  local -a precmd_functions preexec_functions prompt_preview_cleanup
+  local -aLl +h zle_highlight
+
+  {
+    # Save and clear current restore-point if any
+    zstyle -g prompt_preview_cleanup :prompt-theme cleanup
+    {
+      zstyle -d :prompt-theme cleanup
+
+      # The next line is a bit ugly.  It (perhaps unnecessarily)
+      # runs the prompt theme setup function to ensure that if
+      # the theme has a _preview function that it's been autoloaded.
+      prompt_${1}_setup
+
+      if typeset +f prompt_${1}_preview >&/dev/null; then
+        prompt_${1}_preview "$@[2,-1]"
+      else
+        prompt_preview_theme "$@"
+      fi
+    } always {
+      # Run any theme-specific cleanup, then reset restore point
+      zstyle -t :prompt-theme cleanup
+    }
+  } always {
+    (( $#prompt_preview_cleanup )) &&
+      zstyle -e :prompt-theme cleanup "${prompt_preview_cleanup[@]}"
+  }
+}
+
+set_prompt() {
+  emulate -L zsh
+  local opt preview theme usage old_theme
+
+  usage='Usage: prompt <options>
+Options:
+    -c              Show currently selected theme and parameters
+    -l              List currently available prompt themes
+    -p [<themes>]   Preview given themes (defaults to all)
+    -h [<theme>]    Display help (for given theme)
+    -s <theme>      Set and save theme
+    <theme>         Switch to new theme immediately (changes not saved)
+
+Use prompt -h <theme> for help on specific themes.'
+
+  getopts "chlps:" opt
+  case "$opt" in
+    (h|p)
+      setopt localtraps
+      if [[ -z "$prompt_theme[1]" ]]; then
+        # Not using a prompt theme; save settings
+        local +h PS1=$PS1 PS2=$PS2 PS3=$PS3 PS4=$PS4 RPS1=$RPS1 RPS2=$RPS2
+        local +h PROMPT=$PROMPT RPROMPT=$RPOMPT RPROMPT2=$RPROMPT2 PSVAR=$PSVAR
+        local -a precmd_functions preexec_functions
+      else
+        trap 'prompt_${prompt_theme[1]}_setup "${(@)prompt_theme[2,-1]}"' 0
+      fi
+      ;;
+  esac
+  case "$opt" in
+    c) if [[ -n $prompt_theme ]]; then
+         print -n "Current prompt theme"
+         (( $#prompt_theme > 1 )) && print -n " with parameters"
+         print " is:\n  $prompt_theme"
+       else
+         print "Current prompt is not a theme."
+       fi
+       return
+       ;;
+    h) if [[ -n "$2" && -n $prompt_themes[(r)$2] ]]; then
+         if functions prompt_$2_setup >/dev/null; then
+           # The next line is a bit ugly.  It (perhaps unnecessarily)
+           # runs the prompt theme setup function to ensure that if
+           # the theme has a _help function that it's been autoloaded.
+           prompt_$2_setup
+         fi
+         if functions prompt_$2_help >/dev/null; then
+           print "Help for $2 theme:\n"
+           prompt_$2_help
+         else
+           print "No help available for $2 theme."
+         fi
+         print "\nType \`prompt -p $2' to preview the theme, \`prompt $2'"
+         print "to try it out, and \`prompt -s $2' to use it in future sessions."
+       else
+         print "$usage"
+       fi
+       ;;
+    l) print Currently available prompt themes:
+       print $prompt_themes
+       return
+       ;;
+    p) preview=( $prompt_themes )
+       (( $#* > 1 )) && preview=( "$@[2,-1]" )
+       for theme in $preview; do
+         [[ "$theme" == "$prompt_theme[*]" ]] && continue
+         prompt_preview_safely "$=theme"
+       done
+       print -P "%b%f%k"
+       ;;
+    s) print "Set and save not yet implemented.  Please ensure your ~/.zshrc"
+       print "contains something similar to the following:\n"
+       print "  autoload -Uz promptinit"
+       print "  promptinit"
+       print "  prompt $*[2,-1]"
+       shift
+       ;&
+    *) if [[ "$1" == 'random' ]]; then
+         local random_themes
+         if (( $#* == 1 )); then
+           random_themes=( $prompt_themes )
+         else
+           random_themes=( "$@[2,-1]" )
+         fi
+         local i=$(( ( $RANDOM % $#random_themes ) + 1 ))
+         argv=( "${=random_themes[$i]}" )
+       fi
+       if [[ -z "$1" || -z $prompt_themes[(r)$1] ]]; then
+         print "$usage"
+         return
+       fi
+
+       # Reset some commonly altered bits to the default
+       local hook
+       for hook in chpwd precmd preexec periodic zshaddhistory zshexit; do
+         add-zsh-hook -D "${hook}" "prompt_*_${hook}"
+       done
+       typeset -ga zle_highlight=( ${zle_highlight:#default:*} )
+       (( ${#zle_highlight} )) || unset zle_highlight
+
+       prompt_$1_setup "$@[2,-1]" && prompt_theme=( "$@" )
+       ;;
+  esac
+}
+
+prompt_cleanup () {
+  local -a cleanup_hooks
+  if zstyle -g cleanup_hooks :prompt-theme cleanup
+  then
+    cleanup_hooks+=(';' "$@")
+    zstyle -e :prompt-theme cleanup "${cleanup_hooks[@]}"
+  elif (( $+prompt_preview_cleanup == 0 ))
+  then
+    print -u2 "prompt_cleanup: no prompt theme active"
+    return 1
+  fi
+}
+
+prompt () {
+  local -a prompt_opts theme_active
+
+  zstyle -g theme_active :prompt-theme cleanup || {
+    # This is done here rather than in set_prompt so that it
+    # is safe and sane for set_prompt to setopt localoptions,
+    # which will be cleared before we arrive back here again.
+    # This is also why we pass around the prompt_opts array.
+    [[ -o promptbang ]] && prompt_opts+=(bang)
+    [[ -o promptcr ]] && prompt_opts+=(cr)
+    [[ -o promptpercent ]] && prompt_opts+=(percent)
+    [[ -o promptsp ]] && prompt_opts+=(sp)
+    [[ -o promptsubst ]] && prompt_opts+=(subst)
+    zstyle -e :prompt-theme cleanup \
+        'zstyle -d :prompt-theme cleanup;' \
+	'prompt_default_setup;' \
+        ${PS1+PS1="${(q)PS1}"} \
+        ${PS2+PS2="${(q)PS2}"} \
+        ${PS3+PS3="${(q)PS3}"} \
+        ${PS4+PS4="${(q)PS4}"} \
+        ${RPS1+RPS1="${(q)RPS1}"} \
+        ${RPS2+RPS2="${(q)RPS2}"} \
+        ${RPROMPT+RPROMPT="${(q)RPROMPT}"} \
+        ${RPROMPT2+RPROMPT2="${(q)RPROMPT2}"} \
+        ${PSVAR+PSVAR="${(q)PSVAR}"} \
+        "precmd_functions=(${(q)precmd_functions[@]})" \
+        "preexec_functions=(${(q)preexec_functions[@]})" \
+        "prompt_opts=( ${prompt_opts[*]} )" \
+        'reply=(yes)'
+  }
+  set_prompt "$@"
+
+  (( ${#prompt_opts} )) &&
+      setopt noprompt{bang,cr,percent,sp,subst} "prompt${^prompt_opts[@]}"
+
+  true
+}
+
+prompt_preview_theme () {
+  emulate -L zsh
+
+  # Check for proper state handling
+  (( $+prompt_preview_cleanup )) || {
+    prompt_preview_safely "$@"
+    return
+  }
+
+  # Minimal preview for prompts that don't supply one
+  local -a prompt_opts
+  print -n "$1 theme"
+  (( $#* > 1 )) && print -n " with parameters \`$*[2,-1]'"
+  print ":"
+  prompt_${1}_setup "$@[2,-1]"
+  (( ${#prompt_opts} )) &&
+      setopt noprompt{bang,cr,percent,sp,subst} "prompt${^prompt_opts[@]}"
+  [[ -n ${precmd_functions[(r)prompt_${1}_precmd]} ]] &&
+    prompt_${1}_precmd
+  [[ -o promptcr ]] && print -n $'\r'; :
+  print -P "${PS1}command arg1 arg2 ... argn"
+  [[ -n ${preexec_functions[(r)prompt_${1}_preexec]} ]] &&
+    prompt_${1}_preexec
+}
+
+[[ -o kshautoload ]] || promptinit "$@"
+}
+
+_systemctl() {
+#compdef systemctl
+
+(( $+functions[_systemctl_command] )) || _systemctl_command()
+{
+  local -a _systemctl_cmds
+  _systemctl_cmds=(
+    "list-sockets:List sockets"
+    "list-timers:List timers"
+    "list-units:List units"
+    "start:Start (activate) one or more units"
+    "stop:Stop (deactivate) one or more units"
+    "reload:Reload one or more units"
+    "restart:Start or restart one or more units"
+    "condrestart:Restart one or more units if active"
+    "try-restart:Restart one or more units if active"
+    "reload-or-restart:Reload one or more units if possible, otherwise start or restart"
+    "force-reload:Reload one or more units if possible, otherwise restart if active"
+    "hibernate:Hibernate the system"
+    "hybrid-sleep:Hibernate and suspend the system"
+    "try-reload-or-restart:Reload one or more units if possible, otherwise restart if active"
+    "isolate:Start one unit and stop all others"
+    "kill:Send signal to processes of a unit"
+    "is-active:Check whether units are active"
+    "is-failed:Check whether units are failed"
+    "status:Show runtime status of one or more units"
+    "show:Show properties of one or more units/jobs or the manager"
+    "cat:Show the source unit files and drop-ins"
+    "reset-failed:Reset failed state for all, one, or more units"
+    "list-unit-files:List installed unit files"
+    "enable:Enable one or more unit files"
+    "disable:Disable one or more unit files"
+    "add-wants:Add Wants= dependencies to a unit"
+    "add-requires:Add Requires= dependencies to a unit"
+    "reenable:Reenable one or more unit files"
+    "preset:Enable/disable one or more unit files based on preset configuration"
+    "set-default:Set the default target"
+    "get-default:Query the default target"
+    "edit:Edit one or more unit files"
+    "is-system-running:Query overall status of the system"
+    "help:Show documentation for specified units"
+    "list-dependencies:Show unit dependency tree"
+    "mask:Mask one or more units"
+    "unmask:Unmask one or more units"
+    "link:Link one or more units files into the search path"
+    "is-enabled:Check whether unit files are enabled"
+    "list-jobs:List jobs"
+    "cancel:Cancel all, one, or more jobs"
+    "show-environment:Dump environment"
+    "set-environment:Set one or more environment variables"
+    "unset-environment:Unset one or more environment variables"
+    "daemon-reload:Reload systemd manager configuration"
+    "daemon-reexec:Reexecute systemd manager"
+    "default:Enter system default mode"
+    "rescue:Enter system rescue mode"
+    "emergency:Enter system emergency mode"
+    "halt:Shut down and halt the system"
+    "suspend:Suspend the system"
+    "poweroff:Shut down and power-off the system"
+    "reboot:Shut down and reboot the system"
+    "kexec:Shut down and reboot the system with kexec"
+    "exit:Ask for user instance termination"
+    "switch-root:Change root directory"
+    "revert:Revert unit files to their vendor versions"
+  )
+
+  if (( CURRENT == 1 )); then
+    _describe -t commands 'systemctl command' _systemctl_cmds || compadd "$@"
+  else
+    local curcontext="$curcontext" expl
+
+    cmd="${${_systemctl_cmds[(r)$words[1]:*]%%:*}}"
+    # Deal with any aliases
+    case $cmd in
+      condrestart) cmd="try-restart";;
+      force-reload) cmd="try-reload-or-restart";;
+    esac
+
+    if (( $#cmd )); then
+      curcontext="${curcontext%:*:*}:systemctl-${cmd}:"
+
+      local update_policy
+      zstyle -s ":completion:${curcontext}:" cache-policy update_policy
+      if [[ -z "$update_policy" ]]; then
+        zstyle ":completion:${curcontext}:" cache-policy _systemctl_caching_policy
+      fi
+
+      _call_function ret _systemctl_$cmd || _message 'no more arguments'
+    else
+      _message "unknown systemctl command: $words[1]"
+    fi
+    return ret
+  fi
+}
+
+__systemctl()
+{
+  systemctl $_sys_service_mgr --full --no-legend --no-pager "$@" 2>/dev/null
+}
+
+
+# Fills the unit list
+_systemctl_all_units()
+{
+  if ( [[ ${+_sys_all_units} -eq 0 ]] || _cache_invalid SYS_ALL_UNITS$_sys_service_mgr ) ||
+    ! _retrieve_cache SYS_ALL_UNITS$_sys_service_mgr;
+  then
+    _sys_all_units=( ${${(f)"$(__systemctl list-units --all)"}%% *} )
+    _store_cache SYS_ALL_UNITS$_sys_service_mgr _sys_all_units
+  fi
+}
+
+# Fills the unit list including all file units
+_systemctl_really_all_units()
+{
+  local -a all_unit_files;
+  local -a really_all_units;
+  if ( [[ ${+_sys_really_all_units} -eq 0 ]] || _cache_invalid SYS_REALLY_ALL_UNITS$_sys_service_mgr ) ||
+    ! _retrieve_cache SYS_REALLY_ALL_UNITS$_sys_service_mgr;
+  then
+    all_unit_files=( ${${(f)"$(__systemctl list-unit-files)"}%% *} )
+    _systemctl_all_units
+    really_all_units=($_sys_all_units $all_unit_files)
+    _sys_really_all_units=(${(u)really_all_units})
+    _store_cache SYS_REALLY_ALL_UNITS$_sys_service_mgr _sys_really_all_units
+  fi
+}
+
+_filter_units_by_property() {
+  local property=$1 value=$2; shift 2
+  local -a units; units=("${(q-)@}")
+  local -A props
+  props=(${(f)"$(_call_program units "$service $_sys_service_mgr show --no-pager --property=\"Id,$property\" -- ${units} 2>/dev/null")"})
+  echo -E - "${(@g:o:)${(k@)props[(Re)$property=$value]}#Id=}"
+}
+
+_systemctl_get_template_names() { echo -E - ${^${(M)${(f)"$(__systemctl list-unit-files "*$PREFIX*$SUFFIX*" )"}##*@.[^[:space:]]##}%%@.*}\@ }
+
+
+_systemctl_active_units()  {_sys_active_units=(  ${${(f)"$(__systemctl list-units "*$PREFIX*$SUFFIX*" )"}%% *} )}
+
+_systemctl_startable_units(){
+    _sys_startable_units=( $( _filter_units_by_property ActiveState inactive $(
+                          _filter_units_by_property CanStart yes $(
+                          __systemctl $mode list-unit-files --state enabled,disabled,static "*$PREFIX*$SUFFIX*" | \
+                               { while read -r a b; do [[ $a =~ @\. ]] || echo -E - " $a"; done; }
+                          __systemctl $mode list-units --state inactive,failed "*$PREFIX*$SUFFIX*" | \
+                               { while read -r a b; do echo -E - " $a"; done; } )) ) )
+}
+
+_systemctl_restartable_units(){
+    _sys_restartable_units=( $(_filter_units_by_property CanStart yes $(
+                          __systemctl $mode list-unit-files --state enabled,disabled,static "*$PREFIX*$SUFFIX*" | \
+                               { while read -r a b; do [[ $a =~ @\. ]] || echo -E - " $a"; done; }
+                          __systemctl $mode list-units "*$PREFIX*$SUFFIX*" | \
+                               { while read -r a b; do echo -E - " $a"; done; } )) )
+}
+
+_systemctl_failed_units()  {_sys_failed_units=( ${${(f)"$(__systemctl list-units --state=failed "*$PREFIX*$SUFFIX*" )"}%% *} ) }
+_systemctl_unit_state() { typeset -gA _sys_unit_state; _sys_unit_state=( $(__systemctl list-unit-files "*$PREFIX*$SUFFIX*" ) ) }
+
+local fun
+# Completion functions for ALL_UNITS
+for fun in is-active is-failed is-enabled status show cat mask preset help list-dependencies edit revert add-wants add-requires ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    _systemctl_really_all_units
+    _wanted systemd-units expl unit \
+      compadd "$@" -a - _sys_really_all_units
+  }
+done
+
+# Completion functions for ENABLED_UNITS
+(( $+functions[_systemctl_disable] )) || _systemctl_disable()
+{
+    local _sys_unit_state; _systemctl_unit_state
+    _wanted systemd-units expl 'enabled unit' \
+      compadd "$@" - ${(k)_sys_unit_state[(R)enabled]}
+}
+
+(( $+functions[_systemctl_reenable] )) || _systemctl_reenable()
+{
+    local _sys_unit_state; _systemctl_unit_state
+    _wanted systemd-units expl 'enabled/disabled unit' \
+      compadd "$@" - ${(k)_sys_unit_state[(R)(enabled|disabled)]} $(_systemctl_get_template_names)
+}
+
+# Completion functions for DISABLED_UNITS
+(( $+functions[_systemctl_enable] )) || _systemctl_enable()
+{
+  local _sys_unit_state; _systemctl_unit_state
+  _wanted systemd-units expl 'disabled unit' \
+    compadd "$@" - ${(k)_sys_unit_state[(R)disabled]} $(_systemctl_get_template_names)
+}
+
+# Completion functions for FAILED_UNITS
+(( $+functions[_systemctl_reset-failed] )) || _systemctl_reset-failed()
+{
+  local _sys_failed_units; _systemctl_failed_units
+  _wanted systemd-units expl 'failed unit' \
+    compadd "$@" -a - _sys_failed_units || _message "no failed unit found"
+}
+
+# Completion functions for STARTABLE_UNITS
+(( $+functions[_systemctl_start] )) || _systemctl_start()
+{
+   local _sys_startable_units; _systemctl_startable_units
+   _wanted systemd-units expl 'startable unit' \
+     compadd "$@" - ${_sys_startable_units[*]} $(_systemctl_get_template_names)
+}
+
+# Completion functions for STOPPABLE_UNITS
+for fun in stop kill try-restart condrestart ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    local _sys_active_units; _systemctl_active_units
+    _wanted systemd-units expl 'stoppable unit' \
+      compadd "$@" - $( _filter_units_by_property CanStop yes \
+        ${_sys_active_units[*]} )
+  }
+done
+
+# Completion functions for ISOLATABLE_UNITS
+(( $+functions[_systemctl_isolate] )) || _systemctl_isolate()
+{
+  _systemctl_all_units
+  _wanted systemd-units expl 'isolatable unit' \
+    compadd "$@" - $( _filter_units_by_property AllowIsolate yes \
+      ${_sys_all_units[*]} )
+}
+
+# Completion functions for RELOADABLE_UNITS
+for fun in reload try-reload-or-restart force-reload ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    local _sys_active_units; _systemctl_active_units
+    _wanted systemd-units expl 'reloadable unit' \
+      compadd "$@" - $( _filter_units_by_property CanReload yes \
+        ${_sys_active_units[*]} )
+  }
+done
+
+# Completion functions for RESTARTABLE_UNITS
+for fun in restart reload-or-restart ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    local _sys_restartable_units; _systemctl_restartable_units
+    _wanted systemd-units expl 'restartable unit' \
+      compadd "$@" - ${_sys_restartable_units[*]} $(_systemctl_get_template_names)
+  }
+done
+
+# Completion functions for MASKED_UNITS
+(( $+functions[_systemctl_unmask] )) || _systemctl_unmask()
+{
+  local _sys_unit_state; _systemctl_unit_state
+  _wanted systemd-units expl 'masked unit' \
+    compadd "$@" - ${(k)_sys_unit_state[(R)masked]} || _message "no masked units found"
+}
+
+# Completion functions for JOBS
+(( $+functions[_systemctl_cancel] )) || _systemctl_cancel()
+{
+  _wanted systemd-jobs expl job \
+    compadd "$@" - ${${(f)"$(__systemctl list-jobs)"}%% *} ||
+      _message "no jobs found"
+}
+
+# Completion functions for TARGETS
+(( $+functions[_systemctl_set-default] )) || _systemctl_set-default()
+{
+  _wanted systemd-targets expl target \
+    compadd "$@" - ${${(f)"$(__systemctl list-unit-files --type target --all)"}%% *} ||
+      _message "no targets found"
+}
+
+# Completion functions for ENVS
+for fun in set-environment unset-environment ; do
+  (( $+functions[_systemctl_$fun] )) || _systemctl_$fun()
+  {
+    local fun=$0 ; fun=${fun##_systemctl_}
+    local suf
+    if [[ "${fun}" = "set-environment" ]]; then
+      suf='-S='
+    fi
+    _wanted systemd-environment expl 'environment variable' \
+      compadd "$@" ${suf} - ${${(f)"$(systemctl show-environment)"}%%=*}
+  }
+done
+
+(( $+functions[_systemctl_link] )) || _systemctl_link() {
+   _sd_unit_files
+}
+
+(( $+functions[_systemctl_switch-root] )) || _systemctl_switch-root() {
+   _files
+}
+
+# no systemctl completion for:
+#    [STANDALONE]='daemon-reexec daemon-reload default
+#                  emergency exit halt kexec list-jobs list-units
+#                  list-unit-files poweroff reboot rescue show-environment'
+
+_systemctl_caching_policy()
+{
+  local _sysunits
+  local -a oldcache
+
+  # rebuild if cache is more than a day old
+  oldcache=( "$1"(mh+1) )
+  (( $#oldcache )) && return 0
+
+  _sysunits=(${${(f)"$(__systemctl --all)"}%% *})
+
+  if (( $#_sysunits )); then
+    for unit in $_sysunits; do
+      [[ "$unit" -nt "$1" ]] && return 0
+    done
+  fi
+
+  return 1
+}
+
+_unit_states() {
+    local -a _states
+    _states=("${(fo)$(__systemctl --state=help)}")
+    _values -s , "${_states[@]}"
+}
+
+_unit_types() {
+    local -a _types
+    _types=("${(fo)$(__systemctl -t help)}")
+    _values -s , "${_types[@]}"
+}
+
+_unit_properties() {
+  if ( [[ ${+_sys_all_properties} -eq 0 ]] || _cache_invalid SYS_ALL_PROPERTIES$_sys_service_mgr ) ||
+    ! _retrieve_cache SYS_ALL_PROPERTIES$_sys_service_mgr;
+  then
+    _sys_all_properties=( ${${(M)${(f)"$(__systemctl show --all;
+    /usr/lib/systemd/systemd --dump-configuration-items)"}##[[:alnum:]]##=*}%%=*}
+    )
+    _store_cache SYS_ALL_PROPERTIES$_sys_service_mgr _sys_all_properties
+  fi
+  _values -s , "${_sys_all_properties[@]}"
+}
+
+_job_modes() {
+    local -a _modes
+    _modes=(fail replace replace-irreversibly isolate ignore-dependencies ignore-requirements flush)
+    _values -s , "${_modes[@]}"
+}
+
+# Build arguments for "systemctl" to be used in completion.
+local -a _modes; _modes=("--user" "--system")
+# Use the last mode (they are exclusive and the last one is used).
+local _sys_service_mgr=${${words:*_modes}[(R)(${(j.|.)_modes})]}
+_arguments -s \
+    {-h,--help}'[Show help]' \
+    '--version[Show package version]' \
+    {-t+,--type=}'[List only units of a particular type]:unit type:_unit_types' \
+    '--state=[Display units in the specified state]:unit state:_unit_states' \
+    '--job-mode=[Specify how to deal with other jobs]:mode:_job_modes' \
+    {-p+,--property=}'[Show only properties by specific name]:unit property:_unit_properties' \
+    {-a,--all}'[Show all units/properties, including dead/empty ones]' \
+    '--reverse[Show reverse dependencies]' \
+    '--after[Show units ordered after]' \
+    '--before[Show units ordered before]' \
+    {-l,--full}"[Don't ellipsize unit names on output]" \
+    '--show-types[When showing sockets, show socket type]' \
+    {-i,--ignore-inhibitors}'[When executing a job, ignore jobs dependencies]' \
+    {-q,--quiet}'[Suppress output]' \
+    '--no-block[Do not wait until operation finished]' \
+    '--no-legend[Do not print a legend, i.e. the column headers and the footer with hints]' \
+    '--no-pager[Do not pipe output into a pager]' \
+    '--system[Connect to system manager]' \
+    '--user[Connect to user service manager]' \
+    "--no-wall[Don't send wall message before halt/power-off/reboot]" \
+    '--global[Enable/disable unit files globally]' \
+    "--no-reload[When enabling/disabling unit files, don't reload daemon configuration]" \
+    '--no-ask-password[Do not ask for system passwords]' \
+    '--kill-who=[Who to send signal to]:killwho:(main control all)' \
+    {-s+,--signal=}'[Which signal to send]:signal:_signals' \
+    {-f,--force}'[When enabling unit files, override existing symlinks. When shutting down, execute action immediately]' \
+    '--root=[Enable unit files in the specified root directory]:directory:_directories' \
+    '--runtime[Enable unit files only temporarily until next reboot]' \
+    {-H+,--host=}'[Operate on remote host]:userathost:_sd_hosts_or_user_at_host' \
+    {-P,--privileged}'[Acquire privileges before execution]' \
+    {-n+,--lines=}'[Journal entries to show]:number of entries' \
+    {-o+,--output=}'[Change journal output mode]:modes:_sd_outputmodes' \
+    '--firmware-setup[Tell the firmware to show the setup menu on next boot]' \
+    '--plain[When used with list-dependencies, print output as a list]' \
+    '--failed[Show failed units]' \
+    '*::systemctl command:_systemctl_command'
+}
+
+vcs_info() {
+## vim:ft=zsh:foldmethod=marker
+##
+## vcs_info - provide version control information
+##
+## Written by Frank Terbeck <ft@bewatermyfriend.org>
+##
+## This file and all corresponding files in Functions/VCS_Info/ are
+## distributed under the same BSD-ish license as zsh itself.
+##
+
+setopt localoptions noksharrays extendedglob NO_shwordsplit
+local file func sys
+local -a static_functions msgs
+local -i maxexports
+
+static_functions=(
+    VCS_INFO_adjust
+    VCS_INFO_bydir_detect
+    VCS_INFO_check_com
+    VCS_INFO_formats
+    VCS_INFO_get_cmd
+    VCS_INFO_hexdump
+    VCS_INFO_hook
+    VCS_INFO_set-patch-format
+    VCS_INFO_maxexports
+    VCS_INFO_nvcsformats
+    VCS_INFO_patch2subject
+    VCS_INFO_quilt
+    VCS_INFO_realpath
+    VCS_INFO_reposub
+    VCS_INFO_set
+
+    vcs_info_hookadd
+    vcs_info_hookdel
+    vcs_info_lastmsg
+    vcs_info_printsys
+    vcs_info_setsys
+)
+
+for func in ${static_functions} ; do
+    autoload -Uz ${func}
+done
+
+[[ -n ${(Mk)parameters:#vcs_info_msg_<->_} ]] && unset ${parameters[(I)vcs_info_msg_<->_]}
+VCS_INFO_maxexports
+VCS_INFO_set --nvcs '-preinit-'
+vcs_info_setsys
+
+# and now, finally create the real vcs_info function
+vcs_info () {
+    emulate -L zsh
+    setopt extendedglob NO_warn_create_global
+
+    [[ -r . ]] || return 0
+
+    local pat
+    local -i found retval
+    local -a enabled disabled dps
+    local usercontext vcs rrn quiltmode
+    local -x LC_MESSAGES
+    local -i maxexports
+    local -a msgs
+    local -A vcs_comm hook_com backend_misc user_data
+
+    LC_MESSAGES=C
+    if [[ -n ${LC_ALL} ]]; then
+        local -x LANG
+        LANG=${LC_ALL}
+        local -x LC_ALL
+    fi
+    vcs='-init-'; rrn='-all-'; quiltmode='addon'
+    usercontext=${1:-default}
+
+    VCS_INFO_hook "start-up"
+    retval=$?
+    if (( retval == 1 )); then
+        return 0
+    elif (( retval == 2 )); then
+        # This needs `max-exports' set. We're still setting it again later
+        # for more specific contexts.
+        VCS_INFO_maxexports
+        VCS_INFO_set --nvcs
+        return 0
+    fi
+
+    zstyle -a ":vcs_info:${vcs}:${usercontext}:${rrn}" "enable" enabled
+    (( ${#enabled} == 0 )) && enabled=( all )
+
+    if [[ -n ${(M)enabled:#(#i)none} ]] ; then
+        [[ -n ${vcs_info_msg_0_} ]] && VCS_INFO_set --nvcs
+        return 0
+    fi
+
+    if [[ -n ${(M)enabled:#(#i)all} ]] ; then
+        enabled=( ${VCS_INFO_backends} )
+        zstyle -a ":vcs_info:${vcs}:${usercontext}:${rrn}" "disable" disabled
+    fi
+
+    zstyle -a ":vcs_info:${vcs}:${usercontext}:${rrn}" "disable-patterns" dps
+
+    for pat in ${dps} ; do
+        if [[ ${PWD} == ${~pat} ]] ; then
+            VCS_INFO_maxexports
+            [[ -n ${vcs_info_msg_0_} ]] && VCS_INFO_set --nvcs
+            return 0
+        fi
+    done
+
+    VCS_INFO_maxexports
+
+    (( found = 0 ))
+    for vcs in ${enabled} ; do
+        [[ -n ${(M)disabled:#${vcs}} ]] && continue
+        if (( ${+functions[VCS_INFO_detect_${vcs}]} == 0 )) ; then
+            printf 'vcs_info: configured unknown backend: '\''%s'\''\n' ${vcs}
+            printf 'vcs_info: use '\''vcs_info_printsys'\'' to find supported systems.\n'
+            continue
+        fi
+        vcs_comm=()
+        VCS_INFO_get_cmd
+        VCS_INFO_detect_${vcs} && (( found = 1 )) && break
+    done
+
+    (( found == 0 )) && {
+        vcs='-quilt-'; quiltmode='standalone'
+        VCS_INFO_quilt standalone || VCS_INFO_set --nvcs
+        return 0
+    }
+
+    VCS_INFO_hook "pre-get-data"
+    retval=$?
+    if (( retval == 1 )); then
+        return 0
+    elif (( retval == 2 )); then
+        VCS_INFO_set --nvcs
+        return 0
+    fi
+
+    VCS_INFO_get_data_${vcs} || {
+        VCS_INFO_set --nvcs
+        return 1
+    }
+
+    VCS_INFO_set
+    return 0
+}
+
+vcs_info "$@"
+}
diff --git a/.zsh.d/zsdoc/data/extended/.zwidgets b/.zsh.d/zsdoc/data/extended/.zwidgets
new file mode 100644
index 000000000..1150000c8
--- /dev/null
+++ b/.zsh.d/zsdoc/data/extended/.zwidgets
@@ -0,0 +1,386 @@
+#!/usr/bin/env zsh
+#
+# .zwidgets
+#
+# ZLE shell function section
+
+# inline calculator `= 4 * 2`
+function = () { print -r -- "$(($@))"; }
+aliases[=]='noglob ='
+
+function zle-fman {
+	local -a cmdline mansects
+	local cmd glob section
+	[[ -z "$MANSECT" ]] && \
+		mansects=(${${(R)${(M)$(print -- /usr/share/man/man* 2>/dev/null)%man*}#man}/\//}) || \
+		mansects=(${(s|:|)MANSECT[@]})
+	cmdline=("${(z)=BUFFER}")
+	if [[ -z "$BUFFER" ]]; then
+		LBUFFER="fman zshall "
+		return
+	fi
+	case "${cmdline[1]}" in
+	(${~${(j:|:)mansects[@]}})
+		section="${cmdline[1]}"
+		shift cmdline
+		cmd="${cmdline[1]}" ;;
+	(*)
+		# Brute force search because “man -w”
+		# breaks when stdin isn't a terminal
+		cmd="${cmdline[1]}"
+		for i in ${^manpath}/man*/${(q)cmd}.*(N); do
+			test -f "$i" && section="${${i%/*}##*/man}" && break
+		done ;;
+	esac
+	[[ "$cmd" == zsh ]] && cmd="zshall"
+	# Setting “section=zshall” is a bit misleading but
+	# this approach removes the need for “if” nesting
+	(( ${#cmdline[@]} > 1 )) && \
+		BUFFER="fman ${section:-zshall} $cmd '${cmdline[@]:1}'" || \
+		BUFFER="fman ${section:-zshall} '$cmd'"
+	zle redisplay
+	# zle accept-line
+}
+
+function zle-zaw-help {
+	[[ -n "$BUFFER" ]] && zle push-input
+	BUFFER="man zaw"
+	zle accept-line
+}
+
+function zle-less {
+	local -a args
+	[[ -z "$BUFFER" ]] && args=("${(z)=history[$((HISTCMD-1))]}") || args=("${(z)=BUFFER}")
+	# eval needed to resolve static named directories
+	until ( [[ ! "${args[1]}" =~ ^..?$ ]] && eval "[[ -e ${args[1]} ]]" ); do
+		# Prevent infinite loop
+		((${#args} > 1)) || return
+		shift args
+	done
+	BUFFER="less -JRMXs ${args[1]}"
+	zle accept-line
+}
+
+function zle-vim {
+	local -a args
+	[[ -z "$BUFFER" ]] && args=("${(z)=history[$((HISTCMD-1))]}") || args=("${(z)=BUFFER}")
+	# eval needed to resolve static named directories
+	until ( [[ ! "${args[1]}" =~ ^..?$ ]] && eval "[[ -e ${args[1]} ]]" ); do
+		# Prevent infinite loop
+		((${#args} > 1)) || return
+		shift args
+	done
+	BUFFER="vim ${args[1]}"
+	zle accept-line
+}
+
+function zle-compdef {
+	local cmd
+	if [[ -z "$BUFFER" ]]; then
+		LBUFFER="compdef _gnu_generic "
+	else
+		# isolate the actual command
+		cmd="${${${BUFFER#*_[[:blank:]]}##(*)(;|&|\(|\)|\{|\}|\`|do|then|else|time|sudo)}%%[[:blank:]]*}"
+		zle push-input
+		BUFFER="compdef _gnu_generic $cmd"
+		zle accept-line
+	fi
+}
+
+function zle-backwards-delete-to-char {
+	[[ -z "$BUFFER" ]] && return
+	read -k 1 -s -r
+	LBUFFER="${LBUFFER%${REPLY}*}"
+
+}
+
+function zle-backwards-zap-to-char {
+	[[ -z "$BUFFER" ]] && return
+	read -k 1 -s -r
+	LBUFFER="${LBUFFER%${REPLY}*}$REPLY"
+}
+
+# X clipboard functions
+function insert-x-selection { LBUFFER="${LBUFFER}$(xsel -op </dev/null 2>/dev/null)"; }
+function append-x-selection { RBUFFER="$(xsel -op </dev/null 2>/dev/null)${RBUFFER}"; }
+function yank-x-selection { print -rn -- "$CUTBUFFER" | xsel -ib; }
+
+function zle-keymap-select {
+	setescapes
+	case "$KEYMAP" in
+	vicmd)
+		printf "$cblock"; printf "$cred" ;;
+	emacs|$_emacs)
+		printf "$cblock"; printf "$cyellow" ;;
+	viins|$_vi)
+		printf "$cline"; printf "$cgrey" ;;
+	esac
+	zle -R
+}
+
+function zle-line-init {
+	setescapes
+	case "$KEYMAP" in
+	vicmd)
+		printf "$cblock"; printf "$cred" ;;
+	emacs|$_emacs)
+		printf "$cblock"; printf "$cyellow" ;;
+	viins|$_vi)
+		printf "$cline"; printf "$cgrey" ;;
+	esac
+	# It should be noted that the O / [ confusion can occur with other keys such as Home and End
+	# http://zsh.sourceforge.net/FAQ/zshfaq03.html#l25
+	# It should be noted that the O / [ confusion can occur with other
+	# keys such as Home and End …
+	#
+	# http://zsh.sourceforge.net/FAQ/zshfaq03.html#l25
+	#
+	# echoti smkx
+	zle -R
+}
+
+function zle-line-finish {
+	setescapes
+	case "$KEYMAP" in
+	vicmd)
+		printf "$cblock"; printf "$cred" ;;
+	emacs|$_emacs)
+		printf "$cblock"; printf "$cyellow" ;;
+	viins|$_vi)
+		printf "$cline"; printf "$cgrey" ;;
+	esac
+	# It should be noted that the O / [ confusion can occur with other
+	# keys such as Home and End …
+	#
+	# http://zsh.sourceforge.net/FAQ/zshfaq03.html#l25
+	#
+	# echoti rmkx
+	zle -R
+}
+
+function zle-toggle-keymap {
+	setescapes
+	case "$_km" in
+	vi)
+		bindkey -e; printf "$cblock"; printf "$cyellow"; _km=emacs; _vi=; _emacs=main ;;
+	emacs)
+		bindkey -v; printf "$cline"; printf "$cgrey"; _km=vi; _vi=main; _emacs= ;;
+	esac
+	zle -R
+}
+
+function zle-emacs-keymap {
+	setescapes
+	bindkey -e; printf "$cblock"; printf "$cyellow"; _km=emacs; _vi=; _emacs=main
+}
+
+function zle-vi-keymap {
+	setescapes
+	bindkey -v; printf "$cline"; printf "$cgrey"; _km=vi; _vi=main; _emacs=
+}
+
+# ALT-I - Paste the selected entry from locate output into the command line
+function fzf-locate-widget {
+	local selected
+	# if selected=$(locate / | fzf -q "$LBUFFER"); then
+	selected=$(locate / | \
+		FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse $FZF_DEFAULT_OPTS $FZF_ALT_C_OPTS" \
+		$(__fzfcmd) -q "$LBUFFER")
+	LBUFFER=$selected
+	zle redisplay
+}
+
+function zle-fh { print -z -- "$(fc -l 1 | fzf +s --tac | sed 's/ *[0-9]* *//')"; }
+
+function zle-youtube-helper {
+	[[ -z "$BUFFER" ]] && return
+	local -a links
+	local i
+	links=("${(z)=BUFFER}")
+	# links=("${=$(<<<$links sed -r 's/([^ '\'']*)/'\''\1'\''/g')}")
+	links=("${links[@]//(#m)*/'$MATCH'}")
+	#BUFFER="youtube-dl -f 22 $links"
+	BUFFER="youtube-dl $links"
+	CURSOR="${#BUFFER}"
+}
+
+# .zwidgets
+#
+# Non-ZLE shell function section
+
+# Make history entries from other zsh instances immediately visible
+function zshreadhist () { fc -p "$HISTFILE"; }
+
+# Set term escape strings
+function setescapes () {
+	[[ "$TERM" =~ ^linux.*$ ]] && return
+	local i
+	typeset -g cblock cline cred cgrey cyellow
+	cblock='[1 q'
+	cline='[5 q'
+	# cred=']12;#ff0000'
+	# cgrey=']12;#a0a0a0'
+	cgrey=']12;Grey'
+	cred=']12;Red'
+	cyellow=']12;#b58900'
+	if (pstree -s "$$" | grep -wq '\(stjerm\|qterminal\)' || [[ "$TERM" =~ linux ]]); then
+		cblock= cline=
+		return
+	elif pstree -s "$$" | grep -wq 'screen'; then
+		for i in cblock cline cred cgrey cyellow; do
+			eval "$i="'\033P'"\${$i}"'\033\\'
+		done
+	elif ([[ -n "$TMUX" ]] && [[ -z "$STY" ]]); then
+		for i in cblock cline cred cgrey cyellow; do
+			eval "$i="'\033Ptmux\;\033'"\${$i}"'\033\\'
+		done
+	fi
+}
+
+# Function to capture exit code of later command.
+function check_last_exit_code () {
+	local LAST_EXIT_CODE=$?
+	local EXIT_CODE_PROMPT=' '
+	if [[ ${LAST_EXIT_CODE} -ne 0 ]]; then
+	EXIT_CODE_PROMPT+="%{$fg[yellow]%}«%{$reset_color%}"
+	EXIT_CODE_PROMPT+="%{$fg_bold[yellow]%}$LAST_EXIT_CODE%{$reset_color%}"
+	EXIT_CODE_PROMPT+="%{$fg[yellow]%}»%{$reset_color%}"
+	fi
+	print -n -- "$EXIT_CODE_PROMPT"
+}
+
+# Show Git branch/tag, or name-rev if on detached head
+function parse_git_branch () {
+	(git symbolic-ref -q HEAD || git name-rev --name-only --no-undefined --always HEAD) 2>/dev/null
+}
+
+# Show different symbols as appropriate for various Git repository states
+function parse_git_state () {
+	# Compose GIT_STATE via multiple conditional appends.
+	local GIT_STATE GIT_DIR NUM_AHEAD NUM_BEHIND
+
+	GIT_DIR="$(git rev-parse --git-dir 2> /dev/null)"
+	NUM_AHEAD="$(git log --oneline @{u}.. 2> /dev/null | wc -l | tr -d ' ')"
+	if [[ "$NUM_AHEAD" -gt 0 ]]; then
+		GIT_STATE="$GIT_STATE${GIT_PROMPT_AHEAD//NUM/$NUM_AHEAD}"
+	fi
+		NUM_BEHIND="$(git log --oneline ..@{u} 2> /dev/null | wc -l | tr -d ' ')"
+	if [[ "$NUM_BEHIND" -gt 0 ]]; then
+		GIT_STATE="$GIT_STATE${GIT_PROMPT_BEHIND//NUM/$NUM_BEHIND}"
+	fi
+	if [[ -e "$GIT_DIR/MERGE_HEAD" ]]; then
+		GIT_STATE="$GIT_STATE$GIT_PROMPT_MERGING"
+	fi
+	if [[ -n "$(git ls-files --other --exclude-standard 2> /dev/null)" ]]; then
+		GIT_STATE="$GIT_STATE$GIT_PROMPT_UNTRACKED"
+	fi
+	if ! git diff --quiet 2>/dev/null; then
+		GIT_STATE="$GIT_STATE$GIT_PROMPT_MODIFIED"
+	fi
+	if ! git diff --cached --quiet 2>/dev/null; then
+		GIT_STATE="$GIT_STATE$GIT_PROMPT_STAGED"
+	fi
+	if [[ -n "$GIT_STATE" ]]; then
+		print -n -- "$GIT_PROMPT_PREFIX$GIT_STATE$GIT_PROMPT_SUFFIX"
+	fi
+}
+
+# If inside a Git repository, print its branch and state
+function git_prompt_string () {
+	local git_where="$(parse_git_branch)"
+	[[ -n "$git_where" ]] && print -n -- "$GIT_PROMPT_SYMBOL$(parse_git_state)$GIT_PROMPT_PREFIX%{$fg[yellow]%}${git_where#(refs/heads/|tags/)}$GIT_PROMPT_SUFFIX"
+}
+
+# Arch latest news
+# The characters "£, §" are used as metacharacters. They should not be encountered in a feed...
+function news_short () {
+	print -n -- "$(print -- $(curl -m 5 -s ${1:-'https://www.archlinux.org/feeds/news/'} | \
+		sed -e ':a;N;$!ba;s/
+/ /g') | \
+			sed -e '
+			s/&amp;/\&/g
+			s/&lt;\|&#60;/</g
+			s/&gt;\|&#62;/>/g
+			s/<\/a>/£/g
+			s/href\=\"g/§/
+			s/<title>/\e[01;29m \
+   ::\e[01;31m /g; s/<\/title>/ \[00m:: \[00m\n/g
+			s/<link>/ [[ \e[01;36m/g; s/<\/link>/\e[00m ]]\e[00m/g
+			s/<description>/\n\n\e[00;37m/g; s/<\/description>/\e[00m\n\n/g
+			s/<p\( [^>]*\)\?>\|<br\s*\/\?>/
+/g
+			s/<b\( [^>]*\)\?>\|<strong\( [^>]*\)\?>/\e[01;30m/g; s/<\/b>\|<\/strong>/\e[00;37m/g
+			s/<i\( [^>]*\)\?>\|<em\( [^>]*\)\?>/\e[41;37m/g; s/<\/i>\|<\/em>/\e[00;37m/g
+			s/<u\( [^>]*\)\?>/\e[4;37m/g; s/<\/u>/\e[00;37m/g
+			s/<code\( [^>]*\)\?>/\e[00m/g; s/<\/code>/\e[00;37m/g
+			s/<a[^§|t]*§\([^\"]*\)\"[^>]*>\([^£]*\)[^£]*£/\e[01;31m\2\e[00;37m \[01;34m[\e[00;37m \[04m\1\e[00;37m\e[01;34m ]]\e[00;37m/g
+			s/<li\( [^>]*\)\?>/
+ \[01;34m*\e[00;37m /g
+			s/<!\[CDATA\[\|\]\]>//g
+			s/\|>\s*<//g
+			s/ *<[^>]\+> */ /g
+			s/[<>£§]//g
+		')
+
+" | \
+		grep --line-buffered -E '^(   :| \[)' | \
+		sed 's/^.*\(:.*::\)/:\1/g' | \
+		awk '{ line[NR] = $0 } END { for (i = NR; i > 0; i -= 2) { print line[i-1]; print line[i] } }'
+}
+
+function news_long () {
+	print -n -- "$(print -- $(curl -m 5 -s ${1:-'https://www.archlinux.org/feeds/news/'} | \
+		sed -e ':a;N;$!ba;s/
+/ /g') | \
+			sed -e '
+			s/&amp;/\&/g
+			s/&lt;\|&#60;/</g
+			s/&gt;\|&#62;/>/g
+			s/<\/a>/£/g
+			s/href\=\"g/§/
+			s/<title>/\e[01;29m \
+   ::\e[01;31m /g; s/<\/title>/ \[00m:: \[00m\n/g
+			s/<link>/ [[ \e[01;36m/g; s/<\/link>/\e[00m ]]\e[00m/g
+			s/<description>/\n\n\e[00;37m/g; s/<\/description>/\e[00m\n\n/g
+			s/<p\( [^>]*\)\?>\|<br\s*\/\?>/
+/g
+			s/<b\( [^>]*\)\?>\|<strong\( [^>]*\)\?>/\e[01;30m/g; s/<\/b>\|<\/strong>/\e[00;37m/g
+			s/<i\( [^>]*\)\?>\|<em\( [^>]*\)\?>/\e[41;37m/g; s/<\/i>\|<\/em>/\e[00;37m/g
+			s/<u\( [^>]*\)\?>/\e[4;37m/g; s/<\/u>/\e[00;37m/g
+			s/<code\( [^>]*\)\?>/\e[00m/g; s/<\/code>/\e[00;37m/g
+			s/<a[^§|t]*§\([^\"]*\)\"[^>]*>\([^£]*\)[^£]*£/\e[01;31m\2\e[00;37m \[01;34m[\e[00;37m \[04m\1\e[00;37m\e[01;34m ]]\e[00;37m/g
+			s/<li\( [^>]*\)\?>/
+ \[01;34m*\e[00;37m /g
+			s/<!\[CDATA\[\|\]\]>//g
+			s/\|>\s*<//g
+			s/ *<[^>]\+> */ /g
+			s/[<>£§]//g
+		')
+
+" | \
+		grep --line-buffered '' | \
+		awk '{ line[NR] = $0 } END { for (i = NR; i > 0; i--) { print line[i]; } }' | \
+		sed '/^$/d'
+}
+
+function cleanup () {
+	[[ -t 9 ]] || return
+	## cleanup env and temp files
+	if (exec </dev/stdin; read -u 0) <&2; then
+		perl -e 'print "
+
+" . "—"x72 . "
+"' >> "/store/zsh-log-${UID}.log"
+		date +'%a %d %b %I:%M:%S%P %Z %Y-%m-%d' >> "/store/zsh-log-${UID}.log"
+		printf "
+[31m%s
+" 'zshrc: the following errors were detected:'
+		( exec </dev/stdin; cat | sed 's/^.*$/	&/' | tee -a /store/zsh-log-${UID}.log ) <&2
+		printf "[0m"
+		perl -e 'print "—"x72 . "
+
+"' >> "/store/zsh-log-${UID}.log"
+	fi
+	exec 2>&9
+	exec 9>&-
+}
diff --git a/.zsh.d/zsdoc/data/features/.zshenv/Script_Body_/export b/.zsh.d/zsdoc/data/features/.zshenv/Script_Body_/export
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zshenv/Script_Body_/export
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/alias b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/alias
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/alias
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/autoload b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/autoload
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/autoload
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/bindkey b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/bindkey
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/bindkey
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/eval b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/eval
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/eval
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/export b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/export
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/export
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/read b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/read
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/read
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/trap b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/trap
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/trap
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/type b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/type
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/type
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/unalias b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/unalias
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/unalias
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/zle b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/zle
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/zle
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/zmodload b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/zmodload
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/zmodload
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/zstyle b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/zstyle
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zshrc/Script_Body_/zstyle
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/cleanup/read b/.zsh.d/zsdoc/data/features/.zwidgets/cleanup/read
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/cleanup/read
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/fzf-locate-widget/zle b/.zsh.d/zsdoc/data/features/.zwidgets/fzf-locate-widget/zle
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/fzf-locate-widget/zle
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/setescapes/eval b/.zsh.d/zsdoc/data/features/.zwidgets/setescapes/eval
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/setescapes/eval
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-backwards-delete-to-char/read b/.zsh.d/zsdoc/data/features/.zwidgets/zle-backwards-delete-to-char/read
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-backwards-delete-to-char/read
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-backwards-zap-to-char/read b/.zsh.d/zsdoc/data/features/.zwidgets/zle-backwards-zap-to-char/read
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-backwards-zap-to-char/read
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-compdef/zle b/.zsh.d/zsdoc/data/features/.zwidgets/zle-compdef/zle
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-compdef/zle
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-emacs-keymap/bindkey b/.zsh.d/zsdoc/data/features/.zwidgets/zle-emacs-keymap/bindkey
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-emacs-keymap/bindkey
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-fman/zle b/.zsh.d/zsdoc/data/features/.zwidgets/zle-fman/zle
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-fman/zle
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-keymap-select/zle b/.zsh.d/zsdoc/data/features/.zwidgets/zle-keymap-select/zle
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-keymap-select/zle
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-less/eval b/.zsh.d/zsdoc/data/features/.zwidgets/zle-less/eval
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-less/eval
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-less/zle b/.zsh.d/zsdoc/data/features/.zwidgets/zle-less/zle
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-less/zle
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-line-finish/zle b/.zsh.d/zsdoc/data/features/.zwidgets/zle-line-finish/zle
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-line-finish/zle
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-line-init/zle b/.zsh.d/zsdoc/data/features/.zwidgets/zle-line-init/zle
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-line-init/zle
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-toggle-keymap/bindkey b/.zsh.d/zsdoc/data/features/.zwidgets/zle-toggle-keymap/bindkey
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-toggle-keymap/bindkey
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-toggle-keymap/zle b/.zsh.d/zsdoc/data/features/.zwidgets/zle-toggle-keymap/zle
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-toggle-keymap/zle
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-vi-keymap/bindkey b/.zsh.d/zsdoc/data/features/.zwidgets/zle-vi-keymap/bindkey
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-vi-keymap/bindkey
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-vim/eval b/.zsh.d/zsdoc/data/features/.zwidgets/zle-vim/eval
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-vim/eval
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-vim/zle b/.zsh.d/zsdoc/data/features/.zwidgets/zle-vim/zle
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-vim/zle
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/features/.zwidgets/zle-zaw-help/zle b/.zsh.d/zsdoc/data/features/.zwidgets/zle-zaw-help/zle
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.zsh.d/zsdoc/data/features/.zwidgets/zle-zaw-help/zle
@@ -0,0 +1 @@
+
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/= b/.zsh.d/zsdoc/data/functions/.zwidgets/=
new file mode 100644
index 000000000..9544b49da
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/=
@@ -0,0 +1 @@
+print -r -- "$(($@))";
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/append-x-selection b/.zsh.d/zsdoc/data/functions/.zwidgets/append-x-selection
new file mode 100644
index 000000000..94f2a2dba
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/append-x-selection
@@ -0,0 +1 @@
+RBUFFER="$(xsel -op </dev/null 2>/dev/null)${RBUFFER}";
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/check_last_exit_code b/.zsh.d/zsdoc/data/functions/.zwidgets/check_last_exit_code
new file mode 100644
index 000000000..af574172f
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/check_last_exit_code
@@ -0,0 +1,8 @@
+local LAST_EXIT_CODE=$?
+local EXIT_CODE_PROMPT=' '
+if [[ ${LAST_EXIT_CODE} -ne 0 ]]; then
+EXIT_CODE_PROMPT+="%{$fg[yellow]%}«%{$reset_color%}"
+EXIT_CODE_PROMPT+="%{$fg_bold[yellow]%}$LAST_EXIT_CODE%{$reset_color%}"
+EXIT_CODE_PROMPT+="%{$fg[yellow]%}»%{$reset_color%}"
+fi
+print -n -- "$EXIT_CODE_PROMPT"
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/cleanup b/.zsh.d/zsdoc/data/functions/.zwidgets/cleanup
new file mode 100644
index 000000000..3df3482ca
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/cleanup
@@ -0,0 +1,11 @@
+[[ -t 9 ]] || return
+if (exec </dev/stdin; read -u 0) <&2; then
+	perl -e 'print "\n\n" . "—"x72 . "\n"' >> "/store/zsh-log-${UID}.log"
+	date +'%a %d %b %I:%M:%S%P %Z %Y-%m-%d' >> "/store/zsh-log-${UID}.log"
+	printf "\n\033[31m%s\n" 'zshrc: the following errors were detected:'
+	( exec </dev/stdin; cat | sed 's/^.*$/\t&/' | tee -a /store/zsh-log-${UID}.log ) <&2
+	printf "\033[0m"
+	perl -e 'print "—"x72 . "\n\n"' >> "/store/zsh-log-${UID}.log"
+fi
+exec 2>&9
+exec 9>&-
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/fzf-locate-widget b/.zsh.d/zsdoc/data/functions/.zwidgets/fzf-locate-widget
new file mode 100644
index 000000000..aa6b43a50
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/fzf-locate-widget
@@ -0,0 +1,6 @@
+local selected
+selected=$(locate / | \
+	FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse $FZF_DEFAULT_OPTS $FZF_ALT_C_OPTS" \
+	$(__fzfcmd) -q "$LBUFFER")
+LBUFFER=$selected
+zle redisplay
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/git_prompt_string b/.zsh.d/zsdoc/data/functions/.zwidgets/git_prompt_string
new file mode 100644
index 000000000..68e340d00
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/git_prompt_string
@@ -0,0 +1,2 @@
+local git_where="$(parse_git_branch)"
+[[ -n "$git_where" ]] && print -n -- "$GIT_PROMPT_SYMBOL$(parse_git_state)$GIT_PROMPT_PREFIX%{$fg[yellow]%}${git_where#(refs/heads/|tags/)}$GIT_PROMPT_SUFFIX"
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/insert-x-selection b/.zsh.d/zsdoc/data/functions/.zwidgets/insert-x-selection
new file mode 100644
index 000000000..d099d34ba
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/insert-x-selection
@@ -0,0 +1 @@
+LBUFFER="${LBUFFER}$(xsel -op </dev/null 2>/dev/null)";
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/news_long b/.zsh.d/zsdoc/data/functions/.zwidgets/news_long
new file mode 100644
index 000000000..c0f63646b
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/news_long
@@ -0,0 +1,26 @@
+print -n -- "$(print -- $(curl -m 5 -s ${1:-'https://www.archlinux.org/feeds/news/'} | \
+	sed -e ':a;N;$!ba;s/\n/ /g') | \
+		sed -e '
+		s/&amp;/\&/g
+		s/&lt;\|&#60;/</g
+		s/&gt;\|&#62;/>/g
+		s/<\/a>/£/g
+		s/href\=\"g/§/
+		s/<title>/\\e[01;29m \\\n   ::\\e[01;31m /g; s/<\/title>/ \\\e[00m:: \\\e[00m\\n/g
+		s/<link>/ [[ \\e[01;36m/g; s/<\/link>/\\e[00m ]]\\e[00m/g
+		s/<description>/\\n\\n\\e[00;37m/g; s/<\/description>/\\e[00m\\n\\n/g
+		s/<p\( [^>]*\)\?>\|<br\s*\/\?>/\n/g
+		s/<b\( [^>]*\)\?>\|<strong\( [^>]*\)\?>/\\e[01;30m/g; s/<\/b>\|<\/strong>/\\e[00;37m/g
+		s/<i\( [^>]*\)\?>\|<em\( [^>]*\)\?>/\\e[41;37m/g; s/<\/i>\|<\/em>/\\e[00;37m/g
+		s/<u\( [^>]*\)\?>/\\e[4;37m/g; s/<\/u>/\\e[00;37m/g
+		s/<code\( [^>]*\)\?>/\\e[00m/g; s/<\/code>/\\e[00;37m/g
+		s/<a[^§|t]*§\([^\"]*\)\"[^>]*>\([^£]*\)[^£]*£/\\e[01;31m\2\\e[00;37m \\\e[01;34m[\\e[00;37m \\\e[04m\1\\e[00;37m\\e[01;34m ]]\\e[00;37m/g
+		s/<li\( [^>]*\)\?>/\n \\\e[01;34m*\\e[00;37m /g
+		s/<!\[CDATA\[\|\]\]>//g
+		s/\|>\s*<//g
+		s/ *<[^>]\+> */ /g
+		s/[<>£§]//g
+	')\n\n" | \
+	grep --line-buffered '' | \
+	awk '{ line[NR] = $0 } END { for (i = NR; i > 0; i--) { print line[i]; } }' | \
+	sed '/^$/d'
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/news_short b/.zsh.d/zsdoc/data/functions/.zwidgets/news_short
new file mode 100644
index 000000000..a971566af
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/news_short
@@ -0,0 +1,26 @@
+print -n -- "$(print -- $(curl -m 5 -s ${1:-'https://www.archlinux.org/feeds/news/'} | \
+	sed -e ':a;N;$!ba;s/\n/ /g') | \
+		sed -e '
+		s/&amp;/\&/g
+		s/&lt;\|&#60;/</g
+		s/&gt;\|&#62;/>/g
+		s/<\/a>/£/g
+		s/href\=\"g/§/
+		s/<title>/\\e[01;29m \\\n   ::\\e[01;31m /g; s/<\/title>/ \\\e[00m:: \\\e[00m\\n/g
+		s/<link>/ [[ \\e[01;36m/g; s/<\/link>/\\e[00m ]]\\e[00m/g
+		s/<description>/\\n\\n\\e[00;37m/g; s/<\/description>/\\e[00m\\n\\n/g
+		s/<p\( [^>]*\)\?>\|<br\s*\/\?>/\n/g
+		s/<b\( [^>]*\)\?>\|<strong\( [^>]*\)\?>/\\e[01;30m/g; s/<\/b>\|<\/strong>/\\e[00;37m/g
+		s/<i\( [^>]*\)\?>\|<em\( [^>]*\)\?>/\\e[41;37m/g; s/<\/i>\|<\/em>/\\e[00;37m/g
+		s/<u\( [^>]*\)\?>/\\e[4;37m/g; s/<\/u>/\\e[00;37m/g
+		s/<code\( [^>]*\)\?>/\\e[00m/g; s/<\/code>/\\e[00;37m/g
+		s/<a[^§|t]*§\([^\"]*\)\"[^>]*>\([^£]*\)[^£]*£/\\e[01;31m\2\\e[00;37m \\\e[01;34m[\\e[00;37m \\\e[04m\1\\e[00;37m\\e[01;34m ]]\\e[00;37m/g
+		s/<li\( [^>]*\)\?>/\n \\\e[01;34m*\\e[00;37m /g
+		s/<!\[CDATA\[\|\]\]>//g
+		s/\|>\s*<//g
+		s/ *<[^>]\+> */ /g
+		s/[<>£§]//g
+	')\n\n" | \
+	grep --line-buffered -E '^(   :| \[)' | \
+	sed 's/^.*\(:.*::\)/:\1/g' | \
+	awk '{ line[NR] = $0 } END { for (i = NR; i > 0; i -= 2) { print line[i-1]; print line[i] } }'
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/parse_git_branch b/.zsh.d/zsdoc/data/functions/.zwidgets/parse_git_branch
new file mode 100644
index 000000000..d72ef5d69
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/parse_git_branch
@@ -0,0 +1 @@
+(git symbolic-ref -q HEAD || git name-rev --name-only --no-undefined --always HEAD) 2>/dev/null
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/parse_git_state b/.zsh.d/zsdoc/data/functions/.zwidgets/parse_git_state
new file mode 100644
index 000000000..402b6d2d9
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/parse_git_state
@@ -0,0 +1,26 @@
+local GIT_STATE GIT_DIR NUM_AHEAD NUM_BEHIND
+
+GIT_DIR="$(git rev-parse --git-dir 2> /dev/null)"
+NUM_AHEAD="$(git log --oneline @{u}.. 2> /dev/null | wc -l | tr -d ' ')"
+if [[ "$NUM_AHEAD" -gt 0 ]]; then
+	GIT_STATE="$GIT_STATE${GIT_PROMPT_AHEAD//NUM/$NUM_AHEAD}"
+fi
+	NUM_BEHIND="$(git log --oneline ..@{u} 2> /dev/null | wc -l | tr -d ' ')"
+if [[ "$NUM_BEHIND" -gt 0 ]]; then
+	GIT_STATE="$GIT_STATE${GIT_PROMPT_BEHIND//NUM/$NUM_BEHIND}"
+fi
+if [[ -e "$GIT_DIR/MERGE_HEAD" ]]; then
+	GIT_STATE="$GIT_STATE$GIT_PROMPT_MERGING"
+fi
+if [[ -n "$(git ls-files --other --exclude-standard 2> /dev/null)" ]]; then
+	GIT_STATE="$GIT_STATE$GIT_PROMPT_UNTRACKED"
+fi
+if ! git diff --quiet 2>/dev/null; then
+	GIT_STATE="$GIT_STATE$GIT_PROMPT_MODIFIED"
+fi
+if ! git diff --cached --quiet 2>/dev/null; then
+	GIT_STATE="$GIT_STATE$GIT_PROMPT_STAGED"
+fi
+if [[ -n "$GIT_STATE" ]]; then
+	print -n -- "$GIT_PROMPT_PREFIX$GIT_STATE$GIT_PROMPT_SUFFIX"
+fi
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/setescapes b/.zsh.d/zsdoc/data/functions/.zwidgets/setescapes
new file mode 100644
index 000000000..43ee602c7
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/setescapes
@@ -0,0 +1,20 @@
+[[ "$TERM" =~ ^linux.*$ ]] && return
+local i
+typeset -g cblock cline cred cgrey cyellow
+cblock='\033[1 q'
+cline='\033[5 q'
+cgrey='\033]12;Grey\007'
+cred='\033]12;Red\007'
+cyellow='\033]12;#b58900\007'
+if (pstree -s "$$" | grep -wq '\(stjerm\|qterminal\)' || [[ "$TERM" =~ linux ]]); then
+	cblock= cline=
+	return
+elif pstree -s "$$" | grep -wq 'screen'; then
+	for i in cblock cline cred cgrey cyellow; do
+		eval "$i="'\\033P'"\${$i}"'\\033\\\\'
+	done
+elif ([[ -n "$TMUX" ]] && [[ -z "$STY" ]]); then
+	for i in cblock cline cred cgrey cyellow; do
+		eval "$i="'\\033Ptmux\;\\033'"\${$i}"'\\033\\\\'
+	done
+fi
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/yank-x-selection b/.zsh.d/zsdoc/data/functions/.zwidgets/yank-x-selection
new file mode 100644
index 000000000..aea0eb5ef
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/yank-x-selection
@@ -0,0 +1 @@
+print -rn -- "$CUTBUFFER" | xsel -ib;
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-backwards-delete-to-char b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-backwards-delete-to-char
new file mode 100644
index 000000000..6c7d0b13e
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-backwards-delete-to-char
@@ -0,0 +1,3 @@
+[[ -z "$BUFFER" ]] && return
+read -k 1 -s -r
+LBUFFER="${LBUFFER%${REPLY}*}"
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-backwards-zap-to-char b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-backwards-zap-to-char
new file mode 100644
index 000000000..30c6f1704
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-backwards-zap-to-char
@@ -0,0 +1,3 @@
+[[ -z "$BUFFER" ]] && return
+read -k 1 -s -r
+LBUFFER="${LBUFFER%${REPLY}*}$REPLY"
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-compdef b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-compdef
new file mode 100644
index 000000000..cf826a0c6
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-compdef
@@ -0,0 +1,9 @@
+local cmd
+if [[ -z "$BUFFER" ]]; then
+	LBUFFER="compdef _gnu_generic "
+else
+	cmd="${${${BUFFER#*_[[:blank:]]}##(*)(;|&|\(|\)|\{|\}|\`|do|then|else|time|sudo)}%%[[:blank:]]*}"
+	zle push-input
+	BUFFER="compdef _gnu_generic $cmd"
+	zle accept-line
+fi
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-emacs-keymap b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-emacs-keymap
new file mode 100644
index 000000000..53d32968b
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-emacs-keymap
@@ -0,0 +1,2 @@
+setescapes
+bindkey -e; printf "$cblock"; printf "$cyellow"; _km=emacs; _vi=; _emacs=main
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-fh b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-fh
new file mode 100644
index 000000000..666c089d1
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-fh
@@ -0,0 +1 @@
+print -z -- "$(fc -l 1 | fzf +s --tac | sed 's/ *[0-9]* *//')";
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-fman b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-fman
new file mode 100644
index 000000000..488615710
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-fman
@@ -0,0 +1,26 @@
+local -a cmdline mansects
+local cmd glob section
+[[ -z "$MANSECT" ]] && \
+	mansects=(${${(R)${(M)$(print -- /usr/share/man/man* 2>/dev/null)%man*}#man}/\//}) || \
+	mansects=(${(s|:|)MANSECT[@]})
+cmdline=("${(z)=BUFFER}")
+if [[ -z "$BUFFER" ]]; then
+	LBUFFER="fman zshall "
+	return
+fi
+case "${cmdline[1]}" in
+(${~${(j:|:)mansects[@]}})
+	section="${cmdline[1]}"
+	shift cmdline
+	cmd="${cmdline[1]}" ;;
+(*)
+	cmd="${cmdline[1]}"
+	for i in ${^manpath}/man*/${(q)cmd}.*(N); do
+		test -f "$i" && section="${${i%/*}##*/man}" && break
+	done ;;
+esac
+[[ "$cmd" == zsh ]] && cmd="zshall"
+(( ${#cmdline[@]} > 1 )) && \
+	BUFFER="fman ${section:-zshall} $cmd '${cmdline[@]:1}'" || \
+	BUFFER="fman ${section:-zshall} '$cmd'"
+zle redisplay
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-keymap-select b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-keymap-select
new file mode 100644
index 000000000..83ce5a2ca
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-keymap-select
@@ -0,0 +1,10 @@
+setescapes
+case "$KEYMAP" in
+vicmd)
+	printf "$cblock"; printf "$cred" ;;
+emacs|$_emacs)
+	printf "$cblock"; printf "$cyellow" ;;
+viins|$_vi)
+	printf "$cline"; printf "$cgrey" ;;
+esac
+zle -R
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-less b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-less
new file mode 100644
index 000000000..a7770f5e7
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-less
@@ -0,0 +1,8 @@
+local -a args
+[[ -z "$BUFFER" ]] && args=("${(z)=history[$((HISTCMD-1))]}") || args=("${(z)=BUFFER}")
+until ( [[ ! "${args[1]}" =~ ^..?$ ]] && eval "[[ -e ${args[1]} ]]" ); do
+	((${#args} > 1)) || return
+	shift args
+done
+BUFFER="less -JRMXs ${args[1]}"
+zle accept-line
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-line-finish b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-line-finish
new file mode 100644
index 000000000..83ce5a2ca
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-line-finish
@@ -0,0 +1,10 @@
+setescapes
+case "$KEYMAP" in
+vicmd)
+	printf "$cblock"; printf "$cred" ;;
+emacs|$_emacs)
+	printf "$cblock"; printf "$cyellow" ;;
+viins|$_vi)
+	printf "$cline"; printf "$cgrey" ;;
+esac
+zle -R
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-line-init b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-line-init
new file mode 100644
index 000000000..83ce5a2ca
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-line-init
@@ -0,0 +1,10 @@
+setescapes
+case "$KEYMAP" in
+vicmd)
+	printf "$cblock"; printf "$cred" ;;
+emacs|$_emacs)
+	printf "$cblock"; printf "$cyellow" ;;
+viins|$_vi)
+	printf "$cline"; printf "$cgrey" ;;
+esac
+zle -R
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-toggle-keymap b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-toggle-keymap
new file mode 100644
index 000000000..a4bf3c10f
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-toggle-keymap
@@ -0,0 +1,8 @@
+setescapes
+case "$_km" in
+vi)
+	bindkey -e; printf "$cblock"; printf "$cyellow"; _km=emacs; _vi=; _emacs=main ;;
+emacs)
+	bindkey -v; printf "$cline"; printf "$cgrey"; _km=vi; _vi=main; _emacs= ;;
+esac
+zle -R
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-vi-keymap b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-vi-keymap
new file mode 100644
index 000000000..b36ac2b4b
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-vi-keymap
@@ -0,0 +1,2 @@
+setescapes
+bindkey -v; printf "$cline"; printf "$cgrey"; _km=vi; _vi=main; _emacs=
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-vim b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-vim
new file mode 100644
index 000000000..0cb98f505
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-vim
@@ -0,0 +1,8 @@
+local -a args
+[[ -z "$BUFFER" ]] && args=("${(z)=history[$((HISTCMD-1))]}") || args=("${(z)=BUFFER}")
+until ( [[ ! "${args[1]}" =~ ^..?$ ]] && eval "[[ -e ${args[1]} ]]" ); do
+	((${#args} > 1)) || return
+	shift args
+done
+BUFFER="vim ${args[1]}"
+zle accept-line
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-youtube-helper b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-youtube-helper
new file mode 100644
index 000000000..fb545a462
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-youtube-helper
@@ -0,0 +1,7 @@
+[[ -z "$BUFFER" ]] && return
+local -a links
+local i
+links=("${(z)=BUFFER}")
+links=("${links[@]//(#m)*/'$MATCH'}")
+BUFFER="youtube-dl $links"
+CURSOR="${#BUFFER}"
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zle-zaw-help b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-zaw-help
new file mode 100644
index 000000000..b20b0acf9
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zle-zaw-help
@@ -0,0 +1,3 @@
+[[ -n "$BUFFER" ]] && zle push-input
+BUFFER="man zaw"
+zle accept-line
diff --git a/.zsh.d/zsdoc/data/functions/.zwidgets/zshreadhist b/.zsh.d/zsdoc/data/functions/.zwidgets/zshreadhist
new file mode 100644
index 000000000..5c6d7e22c
--- /dev/null
+++ b/.zsh.d/zsdoc/data/functions/.zwidgets/zshreadhist
@@ -0,0 +1 @@
+fc -p "$HISTFILE";
diff --git a/bash_autocompletion.sh b/bash_autocompletion.sh
new file mode 100644
index 000000000..f9a22220f
--- /dev/null
+++ b/bash_autocompletion.sh
@@ -0,0 +1,192 @@
+#!/bin/bash
+
+if [ -z "$BASH" ]; then
+	autoload bashcompinit
+	bashcompinit
+fi
+
+_r2 () {
+	local cur
+	COMPREPLY=()
+	cur=${COMP_WORDS[COMP_CWORD]}
+	prv=${COMP_WORDS[COMP_CWORD-1]}
+	case "$prv" in
+	-a)
+		COMPREPLY=( $(compgen -W "$(rasm2 -qL)" -- $cur))
+		return 0
+		;;
+	-b)
+		COMPREPLY=( $(compgen -W "8 16 32 64" -- $cur ))
+		return 0
+		;;
+	-k)
+		COMPREPLY=( $(compgen -W "$(r2 -qc 'e asm.os=?' --)" -- $cur ))
+		return 0
+		;;
+	-e)
+		COMPREPLY=( $(compgen -W "$(r2 -qceq --)" -- $cur ))
+		return 0
+		;;
+	-F)
+		COMPREPLY=( $(compgen -W "$(rabin2 -qL)" -- $cur ))
+		return 0
+		;;
+	-H)
+		COMPREPLY=( $(compgen -W "$(r2 -H |cut -d = -f 1)" -- $cur))
+		return 0
+		;;
+	-p)
+		COMPREPLY=( $(compgen -W "$(r2 -p?)" -- $cur ))
+		return 0
+		;;
+	-D)
+		COMPREPLY=( $(compgen -W "$(r2 -D?)" -- $cur ))
+		return 0
+		;;
+	esac
+
+	case "$cur" in
+	-*)
+		COMPREPLY=( $( compgen -W '-0 -a -A -b -B -c -C -d -D -e -f -F -h -hh -H -i -I -k -l -L -m -M -n -nn -N -o -q -p -P -R -s -S -t -u -v -V -w -z -zz' -- $cur))
+		;;
+	*)
+		COMPREPLY=( $(compgen -f -- $cur))
+		;;
+	esac
+
+	return 0
+}
+
+complete -F _r2 -o filenames r2
+complete -F _r2 -o filenames radare2
+
+_rasm2 () {
+	local cur
+	COMPREPLY=()
+	cur=${COMP_WORDS[COMP_CWORD]}
+	prv=${COMP_WORDS[COMP_CWORD-1]}
+	case "$prv" in
+	-a)
+		COMPREPLY=( $(compgen -W "$(rasm2 -qL)" -- $cur))
+		return 0
+		;;
+	-b)
+		COMPREPLY=( $(compgen -W "8 16 32 64" -- $cur ))
+		return 0
+		;;
+	-c)
+		# TODO. grab -a and get asm.cpu=? output
+		return 0
+		;;
+	-k)
+		COMPREPLY=( $(compgen -W "$(r2 -qc 'e asm.os=?' --)" -- $cur ))
+		return 0
+		;;
+	-s)
+		COMPREPLY=( $(compgen -W "$(rasm2 -s?)" -- $cur ))
+		return 0
+		;;
+	esac
+
+	case "$cur" in
+	-*)
+		COMPREPLY=( $( compgen -W '-a -A -b -c -C -d -D -e -E -f -F -h -i -k-l -L -o -O -s -B -v -w -q' -- $cur))
+		;;
+	*)
+		COMPREPLY=( $(compgen -f -- $cur))
+		;;
+	esac
+
+	return 0
+}
+
+complete -F _rasm2 -o filenames rasm2
+
+_rabin2 () {
+	local cur
+	COMPREPLY=()
+	cur=${COMP_WORDS[COMP_CWORD]}
+	prv=${COMP_WORDS[COMP_CWORD-1]}
+	case "$prv" in
+	-a)
+		COMPREPLY=( $(compgen -W "$(rasm2 -qL)" -- $cur))
+		return 0
+		;;
+	-b)
+		COMPREPLY=( $(compgen -W "8 16 32 64" -- $cur ))
+		return 0
+		;;
+	-c)
+		# TODO. grab -a and get asm.cpu=? output
+		return 0
+		;;
+	-k)
+		COMPREPLY=( $(compgen -W "$(r2 -qc 'e asm.os=?' --)" -- $cur ))
+		return 0
+		;;
+	-s)
+		COMPREPLY=( $(compgen -W "$(r2 -qc 'e asm.syntax=?' --)" -- $cur ))
+		return 0
+		;;
+	esac
+
+	case "$cur" in
+	-*)
+		COMPREPLY=( $( compgen -W '-a -A -b -c -C -d -D -e -E -f -F -h -i -k-l -L -o -O -s -B -v -w -q' -- $cur))
+		;;
+	*)
+		COMPREPLY=( $(compgen -f -- $cur))
+		;;
+	esac
+
+	return 0
+}
+
+complete -F _rabin2 -o filenames rabin2
+
+_rafind2 () {
+	local cur
+	COMPREPLY=()
+	cur=${COMP_WORDS[COMP_CWORD]}
+	case "$cur" in
+	-*)
+		COMPREPLY=( $( compgen -W '-a -b -e -f -h -m -M -n -r -s -S -t -v -x -X -z -Z' -- $cur))
+		;;
+	*)
+		COMPREPLY=( $(compgen -f -- $cur))
+		;;
+	esac
+
+	return 0
+}
+
+complete -F _rafind2 -o filenames rafind2
+
+_radiff2() {
+	local cur
+	COMPREPLY=()
+	cur=${COMP_WORDS[COMP_CWORD]}
+	prv=${COMP_WORDS[COMP_CWORD-1]}
+	case "$prv" in
+	-a)
+		COMPREPLY=( $(compgen -W "$(rasm2 -qL)" -- $cur))
+		return 0
+		;;
+	-b)
+		COMPREPLY=( $(compgen -W "8 16 32 64" -- $cur ))
+		return 0
+		;;
+	esac
+	case "$cur" in
+	-*)
+		COMPREPLY=( $( compgen -W '-a -A -AA -AAA -b -c -C -d -D -g -j -n -O -p -r -s -ss -S -t -x -v -V' -- $cur))
+		;;
+	*)
+		COMPREPLY=( $(compgen -f -- $cur))
+		;;
+	esac
+
+	return 0
+}
+
+complete -F _radiff2 -o filenames radiff2
diff --git a/gtk-3.0/bookmarks b/gtk-3.0/bookmarks
index f1b73ebde..82a5d4792 100644
--- a/gtk-3.0/bookmarks
+++ b/gtk-3.0/bookmarks
@@ -1,11 +1,11 @@
 file:///store/code/projects/arduino arduino
+file:///run/media/alyptik/microSDXC/ebooks/magnets magnets
 file:///store store
 file:///store/config config
-file:///run/media/alyptik/microSDXC/school/ics170 ics170
+file:///store/code code
 file:///run/media/alyptik/microSDXC/school school
+file:///run/media/alyptik/microSDXC/school/ics170 ics170
 file:///mnt/shared shared
-file:///store/code code
-file:///run/media/alyptik/microSDXC/ebooks/magnets magnets
 file:///run/media/alyptik/microSDXC/calibre calibre
 file:///run/media/alyptik/microSDXC/math math
 file:///run/media/alyptik/toshiba1TB/torrents/Recreational%20Mathematics Recreational Mathematics
diff --git a/man/man7/cepl.7 b/man/man7/cepl.7
index f64216e1a..08fd4b5c5 100755
--- a/man/man7/cepl.7
+++ b/man/man7/cepl.7
@@ -1,17 +1,17 @@
-.TH CEPL: "7" "June 2017" "cepl: CEPL v4\&.6\&.0" "User Commands"
+.TH CEPL: "7" "June 2017" "cepl: CEPL v4\&.7\&.0" "User Commands"
 
 .SH "NAME"
-cepl \- a C11 Read-Eval-Print Loop
+cepl \- a C11 Read\-Eval\-Print Loop
 
 .SH "SYNOPSIS"
 .sp
 .nf
-\fIcepl\fR [\-hptvw] [\-c\fI<compiler>\fR] [\-l\fI<library name>\fR] [\-I\fI<include dir>\fR] [\-o\fI<output\&.c>\fR] [\-a\fI<assembler\&.s\fR>]
+\fIcepl\fR [\-hptvw] [\-c\fI<compiler>\fR] [\-l\fI<library name>\fR] [\-I\fI<include dir>\fR] [\-o\fI<output\&.c>\fR] [(\-a|\-i)\fI<assembler\&.s\fR>]
 .fi
 
 .SH "DESCRIPTION"
 .sp
-C11 (\fBISO/IEC 9899:2011\fR) read–eval–print loop (\fBREPL\fR) currently supporting multiple compilers, readline key-bindings/tab-completion, variable tracking, and incremental undo\&.
+C11 (\fBISO/IEC 9899:2011\fR) read\-eval\-print loop (\fBREPL\fR) currently supporting multiple compilers, readline key\-bindings/tab\-completion, variable tracking, and incremental undo\&.
 .fi
 
 .SH "USAGE"
@@ -25,10 +25,12 @@ Command line options:
 .fi
 
 .HP
-\fB\-a\fR,\fB\-\-asm\fR:		Name of the file to output assembler code to
+\fB\-a\fR,\fB\-\-att\fR:	Name of the file to output AT\&T\-dialect assembler code to
 .HP
 \fB\-h\fR,\fB\-\-help\fR:	Show help/usage information
 .HP
+\fB\-i\fR,\fB\-\-intel\fR:	Name of the file to output Intel\-dialect assembler code to
+.HP
 \fB\-o\fR,\fB\-\-output\fR:	Name of the file to write C code to
 .HP
 \fB\-p\fR,\fB\-\-parse\fR:	Disable addition of dynamic library symbols to readline completion
@@ -37,7 +39,7 @@ Command line options:
 .HP
 \fB\-v\fR,\fB\-\-version\fR:	Show version information
 .HP
-\fB\-w\fR,\fB\-\-warnings\fR:	Compile with \fB\-pedantic\-errors\fR \fB\-Wall\fR \fB\-Wextra\fR flags
+\fB\-w\fR,\fB\-\-warnings\fR:	Compile with \fB\-pedantic\fR \fB\-Wall\fR \fB\-Wextra\fR flags
 .HP
 \fB\-c\fR,\fB\-\-compiler\fR:	Specify alternate compiler
 .HP
@@ -52,13 +54,13 @@ Input lines prefixed with a \fB;\fR are used to control internal state\&.
 .fi
 
 .HP
-\fB;a[sm]\fR:		Toggle -a (output assembler code) flag
+\fB;a[tt]\fR:		Toggle -a (output AT\&T\-dialect asembler code) flag
 .HP
 \fB;f[unction]\fR:	Define a function (e\&.g\&. \fB;f void bork(void) { puts("wark"); }\fR)
 .HP
 \fB;h[elp]\fR:		Show help
 .HP
-\fB;i[nclude]\fR:	Define an include (e\&.g\&. \fB;i #include <pthread\&.h>\fR)
+\fB;i[ntel]\fR:		Toggle -i (output Intel\-dialect asembler code) flag
 .HP
 \fB;m[acro]\fR:		Define a macro (e\&.g\&. \fB;m #define SWAP2(X) ((((X) >> 8) & 0xff) | (((X) & 0xff) << 8))\fR)
 .HP
diff --git a/maxp.pa b/maxp.pa
new file mode 100644
index 000000000..03b055aa7
--- /dev/null
+++ b/maxp.pa
@@ -0,0 +1,21 @@
+➜ ~ cat .config/pulse/default.pa 
+load-module module-native-protocol-unix
+load-module module-x11-bell
+load-module module-x11-publish
+#load-module module-x11-xsmp
+
+.fail
+	#load-module module-alsa-card card_name=usb device_id=U0x41e0x30d3 sink_name=usb.out source_name=usb.in tsched=0 fragment_size=512 fragments=4 fixed_latency_range=yes ignore_dB=yes
+	load-module module-alsa-card card_name=internal device_id=0 sink_name=internal.out source_name=internal.in tsched=0 fragment_size=512 fragments=2 fixed_latency_range=yes
+	load-module module-ladspa-sink sink_name=eq.internal.out master=internal.out plugin=mbeq_1197 label=mbeq control=-2,-2,-10,-12,-12,-12,-12,-12,-12,-11,-11,-10,-8,-7,-7
+	load-module module-alsa-card name=hdmi sink_name=hdmi.out device_id=1 tsched=0
+	
+	set-card-profile alsa_card.hdmi off
+
+	set-default-sink eq.internal.out
+	set-default-source internal.in
+.nofail
+
+load-module module-rescue-streams
+load-module module-always-sink
+load-module module-suspend-on-idle
\ No newline at end of file
diff --git a/vimrc b/vimrc
index 5b710e3b5..e97a8b9df 100644
--- a/vimrc
+++ b/vimrc
@@ -201,6 +201,7 @@ endif
 
 " colorscheme solarized
 " colorscheme seoul256
+" colorscheme pablo
 colorscheme gruvbox
 syntax on
 syntax enable
@@ -216,6 +217,10 @@ let &colorcolumn=join(range(81,250), ',')
 highlight ColorColumn guibg=#282828
 " so listchars are only visible on the current line
 highlight SpecialKey guifg=#282828
+" my own indentation for C using the coding styles
+set smartindent cindent
+" set cino=:0,+0,(2,J0,{1,}0,>4,)1,m2
+set foldmethod=marker
 set shell=/bin/zsh
 set background=dark
 set keywordprg=man\ -s
@@ -829,6 +834,10 @@ au BufNewFile,BufRead makepkg.conf* set filetype=sh
 au BufNewFile,BufRead *.conf* setf cfg
 au BufNewFile,BufRead /etc/* setf cfg
 au BufNewFile,BufRead *.\(pde\|ino\) set filetype=arduino
+au BufNewFile,BufRead *.vala setf cs
+au BufNewFile,BufRead *.vapi setf cs
+au BufNewFile,BufRead *.gtkaml setf cs
+au BufNewFile,BufRead *.gtkon setf cs
 
 " Fallback
 "au BufNewFile,BufRead * setf erlang
@@ -1542,10 +1551,34 @@ nnoremap -- [c
 nnoremap == ]c
 nnoremap =- :diffget<CR>]c
 nnoremap -= :diffput<CR>]c
-nnoremap <F4> :diffget<CR>]c
-nnoremap <F5> :diffput<CR>]c
-vnoremap <F4> :'<,'>diffget<CR>]c
-vnoremap <F5> :'<,'>diffput<CR>]c
+" nnoremap <F4> :diffget<CR>]c
+" nnoremap <F5> :diffput<CR>]c
+" vnoremap <F4> :'<,'>diffget<CR>]c
+" vnoremap <F5> :'<,'>diffput<CR>]c
+nnoremap <F4> :cprevious<CR>
+vnoremap <F4> :cprevious<CR>
+nnoremap <F5> :cnext<CR>
+vnoremap <F5> :cnext<CR>
+" nnoremap <C-F10> <C-w>=
+" vnoremap <C-F10> <C-w>=
+
+" pancake's exposee for vim:
+let g:fs=0
+function! Exposee()
+	if (g:fs == 0)
+		res 1000
+		vertical res 1000
+		let g:fs=1
+	else
+		exe "normal \<C-W>="
+		let g:fs=0
+	endif
+endfun
+nnoremap <F11> :call Exposee()<CR>
+vnoremap <F11> :call Exposee()<CR>
+nnoremap <C-F11> :make<CR>
+vnoremap <C-F11> :make<CR>
+
 noremap <Esc><F4> [c
 noremap <Esc><F5> ]c
 " nnoremap <F4> :ls<CR>
