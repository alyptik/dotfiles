.\" .\" *********************************************************************
.\" .\" *                                                                   *
.\" .\" *             Copyright 2009\-2016, Intel Corporation               *
.\" .\" *                                                                   *
.\" .\" *                       All Rights Reserved.                        *
.\" .\" *                                                                   *
.\" .\" *********************************************************************
.TH  fpp 1 "Intel Corporation" "Copyright(C) 2009\-2016" "Intel(R) Fortran Preprocessor Options" 
.SS NAME
.PP
fpp \- the Fortran language preprocessor for the
Intel(R) Fortran Compiler 
.NL
.SS SYNOPSIS
.PP
fpp [ options ] [ input\-file [ output\-file ] ] 
.NL
.SH DESCRIPTION \- fpp
.PP
.B fpp
is the source file preprocessor for the Intel(R) Fortran Compiler. It is invoked automatically by the compiler when compiling a source file that has the suffix 
.F, 
.F90, 
.fpp, 
.FPP, 
.FOR, 
.FTN. (on Linux* and OS X*) or 
.fpp (on Windows*, where case is ignored) or if the compiler is executed with the option 
\-fpp. 
.PP
.B fpp
optionally accepts two filenames as arguments: input\-file and output\-file. They are, respectively, the input file read and the output file written by 
.B fpp
. By default, standard input and output are used. 
.PP
.B fpp
can perform certain textual transformations on input\-file and also on files specified by 
#include directives in input\-file. 
.PP
This man page is intended for Linux* and OS X* users. 
.SH OPTIONS
.PP
To see lists of compiler options by functionality, specify a category for option \-help on the command line. For a list of the categories you can specify, see 
\-help below. 
.SS Option Alphabetic Summary
.PP
This section includes an alphabetic listing of available fpp options. 
.NL
.SH OPTIONS
.PP
.TP 18
\fBPreprocessor Option 
\fR
.NL
.NL
\fBDescription 
\fR
.NL
.NL
.TP 18
B
.NL
Specifies that C++\-style comments should
not be recognized. 
.NL
.TP 18
C
.NL
Specifies that C\-style comments should not
be recognized. This is the same as specifying 
.B c_com=no
. 
.NL
.TP 18
c_com={yes|no}
.NL
Determines whether C\-style comments are
recognized. If you specify 
.B c_com=no
or 
.B C
C\-style comments are not recognized. By
default, C\-style comments are recognized; that is, 
.B c_com=yes
. 
.NL
.TP 18
D\fIname\fR
.NL
Defines the preprocessor variable 
\fIname\fR as 1 (one). This is the same as if a 
.B Dname=1
option appeared on the fpp command
line. This is the same as specifying the following line in the source file
processed by fpp: 
.PP
#define name 1
.PP
.NL
.TP 18
D\fIname\fR=\fIval\fR
.NL
Defines 
\fIname\fR as if by a #define directive. This is
the same as specifying the following line in the source file processed by fpp: 
.PP
#define name var
.PP
.TP 18
The
D\fIname\fR=\fIval\fR will be ignored if there are
any non\-alphabetic, non\-numeric characters in 
\fIname\fR. 
.TP 18
The 
D option has lower precedence than the 
U option. That is, if the same name is used in
both a 
U option and a 
D option, the name will be undefined regardless
of the order of the options. 
.NL
.TP 18
e
.NL
For fixed\-form source files, tells the
compiler to accept extended source lines, up to 132 characters long. 
.NL
.TP 18
e80
.NL
For fixed\-form source files, tells the
compiler to accept extended source lines, up to 80 characters long. 
.NL
.TP 18
f_com={yes|no}
.NL
Determines whether Fortran\-style end\-of\-line comments are
recognized or ignored by fpp. If you specify 
.B f_com=no
Fortran style end\-of\-line comments
are processed as part of the preprocessor directive. 
.TP 18
By default, Fortran style end\-of\-line comments are identified
by fpp on preprocessor lines and are then ignored by fpp; that is, 
.B f_com=yes
. For example: 
.PP
#define max 100 ! max number
do i = 1, max + 1
.PP
.TP 18
If you specify 
.B f_com=yes
fpp will output the following: 
.PP
do i = 1, 100 + 1
.PP
.TP 18
If you specify 
.B f_com=no
fpp will output the following: 
.PP
do i = 1, 100 ! max number + 1
.PP
.NL
.TP 18
f77
.NL
Tells the compiler to assume FORTRAN 77
language input source. 
.NL
.TP 18
f90
.NL
Tells the compiler to assume Fortran 90
language input source. 
.NL
.TP 18
fixed
.NL
Tells the compiler to assume fixed format
in the source file. 
.NL
.TP 18
free
.NL
Tells the compiler to assume free format in
the source file. 
.NL
.TP 18
help
.NL
Displays information about fpp options. 
.NL
.TP 18
I\fIdir\fR
.NL
Inserts directory 
\fIdir\fR into the search path for files with
names not beginning with "/". The #include 
\fIdir\fR is inserted ahead of the standard list
of "include" directories so that #include files with names enclosed in
double\-quotes (") are searched for first in the directory of the file with the
#include line, then in directories named with 
I options, and lastly, in directories from the
standard list. For #include files with names enclosed in angle\-brackets (<
>), the directory of the file with the #include line is not searched. 
.NL
.TP 18
M
.NL
Generates make dependencies. 
.NL
.TP 18
m
.NL
Expands macros everywhere. This is the same
as specifying 
.B macro=yes
. 
.NL
.TP 18
macro={yes|no_com|no}
.NL
Determines the behavior of macro expansion.
If you specify 
.B macro=no_com
macro expansion is turned off
in comments. If you specify 
.B macro=no
no macro expansion occurs
anywhere. By default, macros are expanded everywhere; that is, 
.B macro=yes
. 
.NL
.TP 18
macro_expand={vc|cpp}
.NL
Determines the mode of macro expansion. If
you specify 
.B macro_expand=vc
macros are expanded in
Microsoft Visual C/C++ order. If you specify 
.B macro_expand=cpp
macros are expanded in GNU
CPP order. 
.NL
.TP 18
MF=\fIfile\fR
.NL
Makes fpp append dependencies to 
\fIfile\fR. 
.NL
.TP 18
noB
.NL
Specifies that C++\-style comments should be
recognized. 
.NL
.TP 18
noC
.NL
Specifies that C\-style comments should be
recognized. This is the same as 
.B c_com=yes
. 
.NL
.TP 18
noJ
.NL
Specifies that F90\-style comments should be
recognized in a #define line. This is the same as 
.B f_com=no
. 
.NL
.TP 18
no\-fort\-cont
.NL
Specifies that IDL\-style format should be
recognized. This option is only for the IDE. 
.TP 18
Note that macro arguments in IDL may have a
C\-like continuation character 
\ which is different from the Fortran
continuation character 
&. The fpp preprocessor should recognize
the C\-like continuation character and process some other non\-Fortran tokens so
that the IDL processor can recognize them. 
.NL
.TP 18
P
.NL
Tells the compiler that line\-numbering directives should not
be added to the output file. This line\-numbering directive appears as 
.TP 18
.PP
#line\-number file\-name
.PP
.NL
.TP 18
U\fIname\fR
.NL
Removes any initial definition of name, where name is an fpp
variable that is predefined on a particular preprocessor. The following shows
an example of symbols that may be predefined, depending upon the architecture
of the system: 
.TP 18
Operating System: 
__APPLE__, 
__unix, and 
__linux
.TP 18
Hardware: 
__i386, 
__x86_64
.NL
.TP 18
undef
.NL
Removes initial definitions for all
predefined symbols. 
.NL
.TP 18
V
.NL
Displays the fpp version number. 
.NL
.TP 18
w[0]
.NL
Prevents warnings from being output. By
default, warnings are output to standard error stream
(stderr). 
.NL
.TP 18
what
.NL
Displays detailed version information. 
.NL
.TP 18
Xu
.NL
Converts uppercase letters to lowercase,
except within character\-string constants. The default is to leave the case as
is. 
.NL
.TP 18
Xw
.NL
Tells the compiler that in fixed\-format
source files, the blank or space symbol " " is insignificant. By default, the
space symbol is the delimiter of tokens for this format. 
.NL
.TP 18
Y\fIdir\fR
.NL
Adds directory 
\fIdir\fR to the end of the system include paths. 
.NL
.SH USAGE
.SS fpp Source Files
.PP
A source file can contain fpp tokens in the
following forms: 
.NL
.IP \(bu 2
fpp preprocessor directive names 
For more information on fpp preprocessor
directives, see 
\fB Using fpp Preprocessor Directives\fR. 
.IP \(bu 2
symbolic names including Fortran keywords 
fpp permits the same characters in names as
Fortran. For more information on symbolic names, see 
\fB Using Predefined Preprocessor Symbols\fR. 
.IP \(bu 2
constants 
Integer, real, double, and quadruple precision
real, binary, octal, hexadecimal (including alternate notation), character, and
Hollerith constants are allowed. 
.IP \(bu 2
special characters, space, tab, and newline
characters 
.IP \(bu 2
comments, including: 
.RS
.IP \(bu 2
Fortran language comments. A fixed form
source line containing one of the symbols C, c, *, d, or D in the first
position is considered a comment line. The ! symbol is interpreted as the
beginning of a comment extending to the end of the line except when the !
occurs within a constant\-expression in an #if or #elif directive. Within such
comments, macro expansions are not performed, but they can be switched on by 
\-f\-com=no. 
.IP \(bu 2
fpp comments between 
/* and 
*/. They are excluded from the output and
macro expansions are not performed within these symbols. fpp comments can be
nested: for each 
/* there must be a corresponding 
*/. fpp comments are useful for excluding from
the compilation large portions of source instead of commenting every line with
a Fortran comment symbol. 
.IP \(bu 2
C++ \-like line comments that begin with 
// (double\-slash). 
.RE
.PP
A string that is a token can occupy several lines,
but only if its input includes continued line characters using the Fortran
continuation character 
&. fpp will not merge such lines into one line. 
.NL
.PP
Identifiers are always placed on one line by fpp.
For example, if an input identifier occupies several lines, it will be merged
by fpp into one line. 
.NL
.SS fpp Output
.PP
Output consists of a modified copy of the input,
plus lines of the form: 
.NL
.PP
#line_number  file_name
.PP
.PP
These are inserted to indicate the original source
line number and filename of the output line that follows. Use the fpp
preprocessor option 
P to disable the
generation of these lines. 
.NL
.SH DIRECTIVES
.PP
The syntax and semantics for fpp directives are the same as for cpp directives. 
.PP
All fpp directives start with the number sign (#) as the first character on a line. White space (BLANK or TAB characters) can appear after the initial "#" for indentation 
.PP
fpp directives (beginning with the # symbol in the first position of lines) can be placed anywhere in source code, in particular, before a Fortran continuation line. However, 
fpp directives within a macro call may not be divided among several lines by means of continuation symbols. 
.PP
fpp permits three kinds of comments: 
.IP 1) 4n 
Fortran language comments. 
.IP
A comment line is a fixed\-format source line containing one of the symbols "C", "c", "*", "d", or "D" in the first position. In fixed or free\-form source, the "!" symbol is interpreted as the beginning of a comment extending to the end of the line, except when the "!" occurs within a constant\-expression in a #if or #elif directive. Within such comments, macro expansions are not performed, but they can be switched on by option 
\-f_com=no
.IP 2) 4n 
fpp comments enclosed in the "/*" and "*/" parasymbols. 
.IP
They are excluded from the output, and macro expansions are not performed within these symbols. 
fpp comments can be nested. For each "/*" there must be a corresponding "*/". 
fpp comments are useful when you want to exclude large portions of source from the compilation instead of commenting every line with a Fortran comment symbol. 
.IP 3) 4n 
C++\-like line comments which begin with "//" (double slash). 
.PP
fpp directives can be grouped according to their purpose. 
.SS Preprocessor directives for string
substitution
.PP
The following fpp preprocessor directives cause
substitutions in your program: 
.NL
.TP 18
\fBPreprocessor Directive 
\fR
.NL
.NL
\fBResult 
\fR
.NL
.NL
.TP 18
__FILE__
.NL
Replaces a string with the input file
name (a character string literal). 
.NL
.TP 18
__LINE__
.NL
Replaces a string with the current line
number in the input file (an integer constant). 
.NL
.TP 18
__DATE__
.NL
Replaces a string with the date that fpp
processed the input file (a character string literal in the form 
Mmm dd yyyy). 
.NL
.TP 18
__TIME__
.NL
Replaces a string with the time that fpp
processed the input file (a character string literal in the form 
hh:mm:ss). 
.NL
.TP 18
__TIMESTAMP__
.NL
Replaces a string with the timestamp that
fpp processed the input file (a character string literal in the form "day date
time year", where 
\fIday\fR is a 3\-letter abbreviation, 
\fIdate\fR is 
Mmm dd, 
\fItime\fR is 
hh:mm:ss and 
\fIyear\fR is 
yyyy). 
.NL
.SS Preprocessor directive for inclusion of
external files
.PP
To include external files, preprocessor directive
#include can be specified in one of the following forms: 
.NL
.PP
#include "\fIfilename\fR"
.PP
.PP
#include <\fIfilename\fR>
.PP
.PP
#include reads in the contents of the named file
into the specified or default location in the source. The lines read in from
the file are processed by fpp just as if they were part of the current file. 
.NL
.PP
When the <\fIfilename\fR> notation is used, 
\fIfilename\fR is only searched for in the standard "include"
directories. For more information, see the fpp 
\-I and the 
\-Y options in 
\fB Using Fortran Preprocessor Options\fR. No additional tokens are
allowed on the directive line after the final \[aq]"\[aq] or ">". 
.NL
.PP
For 
#include
"\fIfilename\fR", filenames are searched for in the following order: 
.NL
.IP \(bu 2
In the directory in which the source file
resides 
.IP \(bu 2
In the directories specified by the 
\-I or 
\-Y option 
.IP \(bu 2
In the default directory 
.PP
For 
#include
<\fIfilename\fR>, filenames are searched for in the following
order: 
.NL
.IP \(bu 2
In the directories specified by the 
\-I or 
\-Y option 
.IP \(bu 2
In the default directory 
.SS Preprocessor directive for line
control
.PP
The preprocessor directive #line\-number generates
line control information for the Fortran compiler. It takes the following form:
.NL
.PP
#line\-number "\fIfilename\fR"
.PP
.PP
#line\-number is an integer constant that is the
line number of the next line. "\fIfilename\fR" is the name of the file
containing the line. If "\fIfilename\fR" is not provided, the current filename
is assumed. 
.NL
.SS Preprocessor directive for fpp variable and
macro definitions
.PP
The preprocessor directive #define can be used to
define both simple string variables and more complicated macros. It can take
two forms. 
.NL
.IP \(bu 2
Definition of an fpp variable: 
.IP
#define \fIname\fR \fItoken\-string\fRIn the above, occurrences of 
\fIname\fR in the source file will be replaced by 
\fItoken\-string\fR. 
.IP \(bu 2
Definition of an fpp macro: 
.IP
#define \fIname\fR(\fIargument\fR[,\fIargument\fR] ... ) \fItoken\-string\fRIn the above, occurrences of the macro 
\fIname\fR followed by the comma\-separated list of actual
arguments within parentheses will be replaced by 
\fItoken\-string\fR. Each occurrence
of 
\fIargument\fR
in 
\fItoken\-string\fR is replaced by the
token sequence representing the corresponding "actual" argument in the macro
call. 
An error occurs if the number of macro call
arguments is not the same as the number of arguments in the corresponding macro
definition. For example, consider this macro definition: 
.IP
#define INTSUB(m, n, o) call mysub(m, n, o)Any use of the macro 
INTSUB must have three arguments. In macro
definitions, spaces between the macro name and the open parenthesis "(" are
prohibited to prevent the directive from being interpreted as an fpp variable
definition with the rest of the line beginning with the open parenthesis "("
being interpreted as its token\-string. 
An fpp variable or macro definition can be of
any length and is limited only by the newline symbol. It can be defined in
multiple lines by continuing it to the next line with the insertion of "\". For
example: 
.IP
#define long_macro_name(x,\
y) x*yThe occurrence of a newline without a
macro\-continuation signifies the end of the macro definition. 
.PP
The scope of a definition begins from the #define
and encloses all the source lines (and source lines from #include files) to the
end of the current file, except for: 
.NL
.IP \(bu 2
Files included by Fortran INCLUDE statements 
.IP \(bu 2
fpp and Fortran comments 
.IP \(bu 2
Fortran IMPLICIT statements that specify a
single letter 
.IP \(bu 2
Fortran FORMAT statements 
.IP \(bu 2
Numeric, typeless, and character constants 
.SS Preprocessor directive for undefining a
macro
.PP
The preprocessor directive #undef takes the
following form: 
.NL
.PP
#undef \fIname\fR
.PP
.PP
This preprocessor directive removes any definition
for 
\fIname\fR produced by the 
D options, the #define preprocessor directives, or by
default. No additional tokens are permitted on the directive line after 
\fIname\fR. 
.NL
.PP
If 
\fIname\fR has not been previously defined, then #undef has no effect.
.NL
.SS Preprocessor directive for macro
expansion
.PP
If, during expansion of a macro, the column width
of a line exceeds column 72 (for fixed format) or column 132 (for free format),
fpp inserts appropriate Fortran continuation lines. 
.NL
.PP
For fixed format, there is a limit on macro
expansions in label fields (positions 1\-5): 
.NL
.IP \(bu 2
A macro call (together with possible arguments)
should not extend beyond column 5. 
.IP \(bu 2
A macro call whose name begins with one of the
Fortran comment symbols is considered to be part of a comment. 
.IP \(bu 2
A macro expansion may produce text extending
beyond column 5. In this case, a warning will be issued. 
.PP
In fixed format, when the fpp option\-Xw has been specified, an
ambiguity may occur if a macro call occurs in a statement position and a macro
name begins or coincides with a Fortran keyword. For example, consider the
following: 
.NL
.PP
#define callp(x)   call f(x)
.PP
call p(0)
.PP
.PP
fpp cannot determine how to interpret the 
callp token sequence above. It could be considered to
be a macro name. The current implementation does the following: 
.NL
.IP \(bu 2
The longer identifier is chosen
(callp in this case) 
.IP \(bu 2
From this identifier the longest macro name or
keyword is extracted 
.IP \(bu 2
If a macro name has been extracted a macro
expansion is performed. If the name begins with some keyword, fpp issues an
appropriate warning 
.IP \(bu 2
The rest of the identifier is considered as a
whole identifier 
.PP
In the previous example, the macro expansion is
performed and the following warning is produced: 
.NL
.PP
warning: possibly incorrect substitution of macro callp
.PP
.PP
This situation appears only when preprocessing
fixed\-format source code and when the space symbol is not interpreted as a
token delimiter. 
.NL
.PP
In the following case, a macro name coincides with
a beginning of a keyword: 
.NL
.PP
#define INT  INTEGER*8
.PP
INTEGER k
.PP
.PP
The INTEGER keyword will be found earlier than the
INT macro name. There will be no warning when preprocessing such a macro
definition. 
.NL
.SS Preprocessor directives for conditional
selection of source text
.PP
The following three preprocessor directives are
conditional constructs that you can use to select source text. 
.NL
.IP \(bu 2
#if preprocessor directive 
When #if is specified, subsequent lines up to
the matching #else, #elif, or #endif preprocessor directive appear in the
output only if 
\fIcondition\fR evaluates to .TRUE.. The following shows an
example: 
.IP
#if \fIcondition_1\fR
\fIblock_1\fR
#elif \fIcondition_2\fR
\fIblock_2\fR
#elif ...
#else
\fIblock_n\fR
#endif
.IP \(bu 2
#ifdef preprocessor directive 
When #ifdef is specified, subsequent lines up
to the matching #else, #elif, or #endif preprocessor directive appear in the
output only if 
\fIname\fR has been defined, either by a #define preprocessor
directive or by the 
D compiler option, with no intervening #undef
preprocessor directive. No additional tokens are permitted on the preprocessor
directive line after 
\fIname\fR. The following shows an example: 
.IP
#ifdef \fIname\fR
\fIblock_1\fR
#elif \fIcondition\fR
\fIblock_2\fR
#elif ...
#else
\fIblock_n\fR
#endif
.IP \(bu 2
#ifndef preprocessor directive 
When #ifndef is specified, subsequent lines up to
the matching #else, #elif, or #endif preprocessor directive appear in the
output only if 
\fIname\fR has not been defined, or if its definition has been
removed with an #undef preprocessor directive. No additional tokens are
permitted on the directive line after 
\fIname\fR. The following shows an example: 
.IP
#ifndef \fIname\fR
\fIblock_1\fR
#elif \fIcondition\fR
\fIblock_2\fR
#elif ...
#else
\fIblock_n\fR
#endif
.PP
The #else, #elif, or #endif preprocessor directives
are optional. They can be used in the above preprocessor directives. 
.NL
.PP
Subsequent lines up to the matching #else, #elif,
or #endif appear in the output only if all of the following occur: 
.NL
.IP \(bu 2
The condition in the preceding #if directive
evaluates to .FALSE. or the name in the preceding #ifdef directive is not
defined, or the name in the preceding #ifndef directive is defined. 
.IP \(bu 2
The conditions in all of the preceding #elif
directives evaluate to .FALSE. 
.IP \(bu 2
The condition in the current #elif evaluates to
.TRUE. 
.PP
Any condition allowed in an #if directive is
allowed in an #elif directive. Any number of #elif directives may appear
between an #if, #ifdef, or #ifndef directive and a matching #else or #endif
directive. 
.NL
.PP
\fB Conditional
expressions\fR
.NL
.PP
\fIcondition_1\fR, 
\fIcondition_2\fR, etc. are logical expressions involving fpp
constants, macros, and intrinsic functions. The following items are permitted
in conditional expressions: 
.NL
.IP \(bu 2
C language operations: <, >, ==, !=,
>=, <=, +, \-, /, *, %, <<, >>, &, ~, |, &&, and
|| 
They are interpreted by fpp in accordance to
the C language semantics. This facility is provided for compatibility with
"old" Fortran programs using cpp. 
.IP \(bu 2
Fortran language operations: .AND., .OR.,
.NEQV., .XOR., .EQV., .NOT., .GT., .LT., .LE., .GE., .NE., .EQ., ** (power). 
.IP \(bu 2
Fortran logical constants: .TRUE. , .FALSE. 
.IP \(bu 2
The fpp intrinsic function 
"defined":
defined(name) or 
defined name which
returns .TRUE. if name is defined as an fpp variable or a macro. It returns
.FALSE. if the name is not defined. 
.PP
#ifdef is shorthand for 
#if defined(name) and
#ifndef is shorthand for 
#if .not.
defined(name). 
.NL
.PP
Only these items, integer constants, and names can
be used within a constant expression. A name that has not been defined with the
\-D option, a
#define preprocessor directive, or defined by default, has a value of 0. The C
operation 
!= (not equal) can be used in
the #if or #elif preprocessor directive, but not in the #define preprocessor
directive, where the symbol 
! is considered to be the
Fortran comment symbol by default. 
.NL
.SH TECHNICAL SUPPORT
.PP
You can find product documentation for many released products at
http://software.intel.com/en\-us/intel\-software\-technical\-documentation/. 
.SS Product Website and Support 
.PP
To find technical support information, to register
your product, or to contact Intel, please visit:
https://software.intel.com/en\-us/support/. 
.NL
.PP
At this site, you will find comprehensive product
information, including: 
.NL
.IP \(bu 2
Links to each product, where you will find
technical information such as white papers, support, articles, and user forums 
.IP \(bu 2
Links to news and events 
.SS Release Notes
.PP
For detailed information on system requirements, late changes to the
products, supported architectures, operating systems, and Integrated
Development Environments (IDE) see the Release Notes for this product. 
.NL
.SS Forums
.PP
You can find helpful information in the Intel Software user forums.
You can also submit questions to the forums. To see the list of the available
forums, go to https://software.intel.com/en\-us/forum/. 
.NL
.SH SEE ALSO
.PP
ifort(1), ld(1) 
.PP
The Intel(R) Fortran
Compiler Documentation has additional reference material on features of the
Intel(R) Fortran Compiler. 
.SH Legal Information
.PP
No license (express or implied, by estoppel or otherwise) to any
intellectual property rights is granted by this document. 
.NL
.PP
Intel disclaims all express and implied warranties, including without
limitation, the implied warranties of merchantability, fitness for a particular
purpose, and non\-infringement, as well as any warranty arising from course of
performance, course of dealing, or usage in trade. 
.NL
.PP
This document contains information on products, services and/or
processes in development. All information provided here is subject to change
without notice. Contact your Intel representative to obtain the latest
forecast, schedule, specifications and roadmaps. 
.NL
.PP
The products and services described may contain defects or errors
which may cause deviations from published specifications. Current characterized
errata are available on request. 
.NL
.PP
Copies of documents which have an order number and are referenced in this
document, or other Intel literature, may be obtained by calling 1\-800\-548\-4725,
or go to: http://www.intel.com/design/literature.htm 
.PP
Intel\[aq]s compilers may or may not optimize to the same degree for
non\-Intel microprocessors for optimizations that are not unique to Intel
microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction
sets and other optimizations. Intel does not guarantee the availability,
functionality, or effectiveness of any optimization on microprocessors not
manufactured by Intel. Microprocessor\-dependent optimizations in this product
are intended for use with Intel microprocessors. Certain optimizations not
specific to Intel microarchitecture are reserved for Intel microprocessors.
Please refer to the applicable product User and Reference Guides for more
information regarding the specific instruction sets covered by this notice.
Notice revision #20110804 
.PP
Intel, the Intel logo, Intel Atom, Intel Core, Intel Cilk, Intel VTune,
MMX, Pentium, Xeon, and Intel Xeon Phi are trademarks of Intel Corporation in
the U.S. and/or other countries. 
.PP
* Other names and brands may be claimed as the
property of others. 
.PP
(C) 2016, Intel Corporation. 
.PP
Portions Copyright (C) 2001, Hewlett\-Packard Development Company, L.P. 
