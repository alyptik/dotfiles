.\" .\" *********************************************************************
.\" .\" *                                                                   *
.\" .\" *             Copyright 1996\-2016, Intel Corporation               *
.\" .\" *                                                                   *
.\" .\" *                       All Rights Reserved.                        *
.\" .\" *                                                                   *
.\" .\" *********************************************************************
.TH  ICC 1 "Intel Corporation" "Copyright(C) 1996\-2016" "Intel(R) C/C++ Compiler Options" 
.PP
This Intel(R) C++ Compiler [ICC] man page describes
all the options to use with the compiler \- standard as well as its derivatives.
.NL
.PP
The standard compiler options are described in the
OPTIONS section. The derived compiler options are described in the section
entitled Compiler Options for Intel(R) C++ Compiler Standard Edition for
Embedded Systems with Bi\-Endian Technology. 
.NL
.PP
icc \- invokes the Intel(R) C Compiler 
.NL
.PP
icpc \- invokes the Intel(R) C++ Compiler 
.NL
.SH SYNOPSIS
.PP
icc/icpc [options] file1 [file2 ...] 
.NL
.PP
where: 
.IP \(bu 2
options represents zero or more compiler
options. 
.IP \(bu 2
fileN represents a C/C++ source (.C, .c, .cc,
.cp, .cpp, .cxx, .c++, .i), assembly (.s), object (.o), static library (.a), or
other linkable file. 
.NL
.PP
.B NOTE:
The icpc command uses the same compiler options
as the icc command. Invoking the compiler using icpc compiles .c and .i files
as C++. Invoking the compiler using icc compiles .c and .i files as C. Using
icpc always links in C++ libraries. Using icc only links in C++ libraries if
C++ source is provided on the command line. 
.SH Description \- icc/icpc
.PP
The Intel(R) C++ Compiler is designed to process C
and C++ programs on Intel(R) architecture\- based systems. You can preprocess,
compile, assemble, and link these programs. 
.PP
This document explains how information and
instructions apply differently to supported architectures (see your Release
Notes). 
If a description does not explicitly state an architecture restriction,
assume that the description is applicable to all supported architectures. See
the Intel(R) C++ compiler documentation for more detailed information than what
is presented here. 
.PP
When there is a restriction, you will see "Architecture Restrictions",
which will show the relevant restriction. 
.PP
This man page is intended for Linux* and OS X* users. However,
sometimes you will see shortcuts for option names. You may see either or both
of the following shortcuts: 
.IP \(bu 2
If you see 
[Q]option\-name, it means that the name of the option is the
same on Linux*, OS X*, and Windows*, except that the Windows form starts with a
Q. For example, if you see [Q]ip, the Linux and OS X form of
the option is 
\-ip and the Windows form of the option is 
/Qip. 
.IP \(bu 2
If you see 
[q or Q]option\-name, it means that the name of the option is
very similar except that the Linux* and OS X* forms start with a q and the
Windows form starts with a Q. For example, if you see 
[q or Q]opt\-report, the Linux and OS X form of the option
is 
\-qopt\-report and the Windows form of the option is 
/Qopt\-report. 
.PP
Otherwise, Linux* and OS X* compiler option names are shown with an
initial "\-". 
.SS  GNU* gcc* Interoperability
.PP
C++ compilers are interoperable if they can link
object files and libraries generated by one compiler with object files and
libraries generated by the second compiler, and the resulting executable runs
successfully. Some GNU* gcc* versions are not interoperable, some versions are
interoperable. By default, the Intel(R) C++ Compiler will generate code that is
interoperable with the version of gcc* it finds on your system. 
.NL
.PP
The Intel(R) C++ Compiler options that affect GNU*
gcc* interoperability include: 
.IP \(bu 2
\-cxxlib
.IP \(bu 2
\-gcc\-name
.IP \(bu 2
\-gxx\-name
.IP \(bu 2
\-fabi\-version
.IP \(bu 2
\-no\-gcc (see gcc Predefined Macros
for more information) 
.NL
.PP
The Intel(R) C++ Compiler is interoperable with GNU*
gcc* compiler versions greater than or equal to 3.2. See the Intel(R) C++
Compiler Documentation for more information. 
.NL
.SH Feature Requirements
.PP
Some features may require that other products also be installed. 
.PP
To use these tools and features, you need licensed versions of the
tools and you must have an appropriate supported version of the relevant
product edition. For more information, check your product release notes. 
.PP
The following table shows components (tools) and some of the products
with which they are included. 
.TP 18
\fBComponent 
\fR
.NL
.NL
\fBIncluded with these Products 
\fR
.NL
.NL
.TP 18
Intel(R) VTune(TM) Amplifier 
.NL
Intel(R) Parallel Studio Professional
Edition, Intel(R) Parallel Studio Cluster Edition 
.NL
.TP 18
Intel(R) Inspector 
.NL
Intel(R) Parallel Studio Professional
Edition, Intel(R) Parallel Studio Cluster Edition 
.NL
.TP 18
Intel(R) Trace Analyzer and Collector 
.NL
Intel(R) Parallel Studio Cluster Edition 
.NL
.PP
The following table lists dependent features and their corresponding
required products. 
.PP
For certain compiler options, compilation may fail if
the option is specified but the required product is not installed. In this
case, remove the option from the command line and recompile. 
.PP
For more information about requirements for a
particular product, see http://www.intel.com/software/products/. 
.IP \(bu 2
Feature: Performance Guide 
Requirement: Intel(R) VTune(TM) Amplifier 
The Performance Guide is deprecated and will be removed in a future
release. 
Note that the Microsoft Visual Studio* IDE menus have been disabled
for the Performance Guide. To re\-enable them, set the environment variable
__INTEL_PERFORMANCE_GUIDE and restart Visual Studio. 
.IP \(bu 2
Feature: Thread Checking 
Requirement: Intel(R) Inspector 
.IP \(bu 2
Feature: Trace Analyzing and Collecting 
Requirement: Intel(R) Trace Analyzer and Collector 
Compiler options related to this feature may require a set\-up
script. For further information, see the documentation supplied with the
required product. 
.IP \(bu 2
Feature: Pointer Checker 
Requirement: Intel(R) Parallel Studio Professional Edition or Intel(R)
Parallel Studio Cluster Edition 
.IP \(bu 2
Feature: Privatization of static data for the MPC unified parallel
runtime 
Requirement: Appropriate elements of the MultiProcessor Computing
(MPC) framework 
You need to install the MPC unified parallel runtime. For more
information, see http://mpc.hpcframework.com/ 
.PP
You should also refer to the Release Notes for this product for detailed
information about system requirements, late changes to the products, supported
architectures, operating systems, and Integrated Development Environments. 
.SH OPTIONS
.SS Option Alphabetic Summary
.PP
This section contains
descriptions of available Intel(R) C++ Compiler options. The options are listed
in alphabetical order. 
.NL
.PP
The Intel(R) C++
Compiler user documentation contains other option information, such as lists of
deprecated and removed options. 
.NL
.TP
.B
\-Aname[(value)]
.RS
.TP
Specifies an identifier for an assertion.
.NL
.TP
\fBArguments:\fR 
.TP 18
name
.NL
Is the identifier for the assertion.
.TP 18
value
.NL
Is an optional value for the assertion. If a value
is specified, it must be within quotes, including the parentheses delimiting
it.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Assertions have no identifiers or symbol names.
.TP
\fBDescription:\fR 
.PP
This option specifies an identifier (symbol name) for an
assertion. It is equivalent to an #assert preprocessing directive.
.NL
.PP
Note that this option is not the positive form of the C++
/QA\- option.
.NL
.PP
On Linux* systems, because GCC has deprecated assertions,
this option has no effect.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-alias\-const
.TP
.B
\-no\-alias\-const
.RS
.TP
Determines whether the compiler assumes a parameter of type pointer\-to\-const does not alias with a parameter of type pointer\-to\-non\-const.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-alias\-const 
.NL
The compiler uses standard C/C++ rules for the interpretation of const.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler assumes a parameter of type pointer\-to\-const does not alias with a parameter of type pointer\-to\-non\-const. It implies an additional attribute for const. 
.NL
.PP
This functionality complies with the input/output buffer rule, which assumes that input and output buffer arguments do not overlap.  This option allows the compiler to do some additional optimizations with those parameters.
.NL
.PP
In C99, you can also get the same result if you additionally declare your pointer parameters with the restrict keyword.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-align
.TP
.B
\-noalign
.RS
.TP
Determines whether variables and arrays are naturally aligned. 
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on IA\-32 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-noalign
.NL
Variables and arrays are aligned according to the gcc model, which means they are aligned to 4\-byte boundaries.
.TP
\fBDescription:\fR 
.PP
This option determines whether variables and arrays are naturally aligned. Option \-align forces the following natural alignment:
.NL
.TP 18
\fBType\fR
.NL
.NL
\fBAlignment\fR
.NL
.NL
.TP 18
double
.NL
8 bytes
.NL
.TP 18
long long
.NL
8 bytes
.NL
.TP 18
long double
.NL
16 bytes
.NL
.PP
If you are not interacting with system libraries or other libraries that are compiled without \-align, this option can improve performance by reducing misaligned accesses. 
.NL
.PP
This option can also be specified as \-m[no\-]align\-double. The options are equivalent.
.NL
.PP
.B CAUTION:
If you are interacting with compatible libraries, this option can improve performance by reducing misaligned accesses. However, If you are interacting with noncompatible libraries or libraries that are compiled without option \-align, your application may not perform as expected.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ansi
.TP
.B
.RS
.TP
Enables language compatibility with the
gcc option ansi.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
GNU C++ is more strongly supported than ANSI C.
.TP
\fBDescription:\fR 
.PP
This option enables language compatibility with the gcc
option 
\-ansi and provides the
same level of ANSI standard conformance as that option.
.NL
.PP
This option sets option 
fmath\-errno.
.NL
.PP
If you want strict ANSI conformance, use the 
\fI\-strict\-ansi\fR option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ansi\-alias
.TP
.B
\-no\-ansi\-alias
.RS
.TP
Enables or disables the use of ANSI
aliasing rules in optimizations. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
.NL
ANSI aliasing rules are disabled in optimizations.
.TP 18
Linux* and OS X* systems:
\-ansi\-alias
.NL
ANSI aliasing rules are enabled in optimizations. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to assume that the program
adheres to ISO C Standard aliasability rules. 
.NL
.PP
If your program adheres to the ANSI aliasability rules, this option allows
the compiler to optimize more aggressively. If your program does not adhere to
these rules, this option may cause the compiler to generate incorrect code. 
.NL
.PP
If you are compiling on a Linux* or an OS X* system and
your program does not adhere to the ANSI aliasability rules, you can specify 
\-no\-ansi\-alias to ensure program correctness. 
.NL
.PP
When you specify the 
[Q]ansi\-alias option, the ansi\-alias checker is enabled by
default. To disable the ansi\-alias checker, you must specify 
\-no\-ansi\-alias\-check (Linux* and OS X*) or 
/Qansi\-alias\-check\- (Windows*). 
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: 
\-fstrict\-aliasing
.NL
.PP
Windows: None 
.NL
.RE
.TP
.B
\-ansi\-alias\-check
.TP
.B
\-no\-ansi\-alias\-check
.RS
.TP
Enables or disables the ansi\-alias
checker. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology 
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-ansi\-alias\-check 
.NL
The ansi\-alias checker is disabled unless option 
\-ansi\-alias\-check or 
/Qansi\-alias\-check has been specified. 
.TP
\fBDescription:\fR 
.PP
This option enables or disables the ansi\-alias checker. The ansi\-alias
checker checks the source code for potential violations of ANSI aliasing rules
and disables unsafe optimizations related to the code for those statements that
are identified as potential violations. 
.NL
.PP
You can use option 
–Wstrict\-aliasing to identify potential violations. 
.NL
.PP
If the 
[Q]ansi\-alias option has been specified, the ansi\-alias
checker is enabled by default. You can use the negative form of the option (see
Syntax above) to disable the checker. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-auto\-ilp32
.RS
.TP
Instructs the compiler to analyze the
program to determine if there are 64\-bit pointers that can be safely shrunk
into 32\-bit pointers and if there are 64\-bit longs (on Linux* systems) that can
be safely shrunk into 32\-bit longs.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The optimization is not attempted.
.TP
\fBDescription:\fR 
.PP
This option instructs the compiler to analyze the program
to determine if there are 64\-bit pointers that can be safely shrunk into 32\-bit
pointers and if there are 64\-bit longs (on Linux* systems) that can be safely
shrunk into 32\-bit longs. 
.NL
.PP
On OS X* systems, you must also specify option 
\-no\-pie for the optimization to occur.
.NL
.PP
For this option to be effective, the compiler must be
able to optimize using the 
[Q]ipo option and must be
able to analyze all library calls or external calls the program makes. This
option has no effect on Linux* systems unless you specify setting SSE3 or
higher for option 
\-x.
.NL
.PP
This option requires that the size of the program
executable never exceeds 232 bytes and
all data values can be represented within 32 bits. If the program can run
correctly in a 32\-bit system, these requirements are implicitly satisfied. If
the program violates these size restrictions, unpredictable behavior may occur.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-auto\-p32
.RS
.TP
Instructs the compiler to analyze the program to determine if there are 64\-bit pointers that can be safely shrunk to 32\-bit pointers.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The optimization is not performed.
.TP
\fBDescription:\fR 
.PP
This option instructs the compiler to analyze
and transform the program so that 64\-bit pointers are shrunk to
32\-bit pointers, wherever it is legal and safe to do so.
.NL
.PP
On OS X* systems, you must also specify option \-no\-pie for the optimization to occur.
.NL
.PP
For this option to be effective, the compiler
must be able to optimize using the \-ipo  option and it must be able to analyze all
library calls or external calls the program makes. This option has no effect unless you specify setting SSE3 or higher for option \-x.
.NL
.PP
The application cannot exceed a 32\-bit address
space; otherwise, unpredictable results can occur.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-axcode
.RS
.TP
Tells the compiler to generate multiple,
feature\-specific auto\-dispatch code paths for Intel(R) processors if there is a
performance benefit. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIcode\fR
.NL
Indicates to the compiler a feature set that it may
target, including which instruction sets it may generate. The following
descriptions refer to Intel(R) Streaming SIMD Extensions (Intel(R) SSE) and
Supplemental Streaming SIMD Extensions (SSSE). Possible values are: 
.RS
.TP 15
COMMON\-AVX512
May generate Intel(R) Advanced Vector
Extensions 512 (Intel(R) AVX\-512) Foundation instructions, Intel(R) AVX\-512
Conflict Detection instructions, as well as the instructions enabled with
CORE\-AVX2. 
.TP 15
MIC\-AVX512
May generate Intel(R) Advanced Vector
Extensions 512 (Intel(R) AVX\-512) Foundation instructions, Intel(R) AVX\-512
Conflict Detection instructions, Intel(R) AVX\-512 Exponential and Reciprocal
instructions, Intel(R) AVX\-512 Prefetch instructions for Intel(R) processors, and
the instructions enabled with CORE\-AVX2. 
.IP
This keyword is only
available on Windows* and Linux*. 
.TP 15
CORE\-AVX512
May generate Intel(R) Advanced Vector
Extensions 512 (Intel(R) AVX\-512) Foundation instructions, Intel(R) AVX\-512
Conflict Detection instructions, Intel(R) AVX\-512 Doubleword and Quadword
instructions, Intel(R) AVX\-512 Byte and Word instructions and Intel(R) AVX\-512
Vector Length extensions, as well as the instructions enabled with CORE\-AVX2. 
.TP 15
CORE\-AVX2
May generate Intel(R) Advanced Vector
Extensions 2 (Intel(R) AVX2), Intel(R) AVX, SSE4.2, SSE4.1, SSE3, SSE2, SSE, and
SSSE3 instructions for Intel(R) processors. 
.TP 15
CORE\-AVX\-I
May generate 
Float\-16 conversion
instructions and 
the RDRND instruction, Intel(R) Advanced Vector Extensions
(Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions
for Intel(R) processors. 
.TP 15
AVX
May generate Intel(R) Advanced Vector
Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3
instructions for Intel(R) processors. 
.TP 15
SSE4.2
May generate Intel(R) SSE4.2, SSE4.1, SSE3,
SSE2, SSE, and SSSE3 instructions for Intel processors. 
.TP 15
SSE4.1
May generate Intel(R) SSE4.1, SSE3, SSE2, SSE,
and SSSE3 instructions for Intel(R) processors. 
.TP 15
SSSE3
May generate SSSE3 instructions and Intel(R)
SSE3, SSE2, and SSE instructions for Intel(R) processors. For OS X* systems, this
value is only supported on Intel(R) 64 architecture. This replaces value T, which
is deprecated. 
.TP 15
SSE3
May generate Intel(R) SSE3, SSE2, and SSE
instructions for Intel(R) processors. For OS X* systems, this value is only
supported on IA\-32 architecture. 
.TP 15
SSE2
May generate Intel(R) SSE2 and SSE instructions
for Intel(R) processors. This value is not available on OS X* systems. 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No auto\-dispatch code is generated.
Feature\-specific code is generated and is controlled by the setting of the
following compiler options: 
.RS
.IP \(bu 2
Linux*: 
\-m and 
\-x
.IP \(bu 2
OS X*: 
\-x
.RE
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate multiple,
feature\-specific auto\-dispatch code paths for Intel(R) processors if there is a
performance benefit. It also generates a baseline code path. The Intel
feature\-specific auto\-dispatch path is usually more optimized than the baseline
path. Other options, such as 
O3, control how much optimization is performed on the baseline
path. 
.NL
.PP
The baseline code path is determined by the architecture
specified by options 
\-m or 
\-x (Linux* and OS X*) or
options 
/arch or 
/Qx (Windows*). While
there are defaults for the 
[Q]x option that depend
on the operating system being used, you can specify an architecture and
optimization level for the baseline code that is higher or lower than the
default. The specified architecture becomes the effective minimum architecture
for the baseline code path. 
.NL
.PP
If you specify both the 
[Q]ax and 
[Q]x options, the
baseline code will only execute on Intel(R) processors compatible with the
setting specified for the 
[Q]x. 
.NL
.PP
If you specify both the 
\-ax and 
\-m options (Linux and OS X) or the 
/Qax and 
/arch options (Windows), the baseline code will execute on
non\-Intel processors compatible with the setting specified for the 
\-m or 
/arch option. 
.NL
.PP
If you specify both the 
\-ax and 
\-march options (Linux and OS X), or the 
/Qax and 
/arch options (Windows), the compiler will not generate
Intel\-specific instructions. 
.NL
.PP
The 
[Q]ax option tells the compiler to find opportunities to
generate separate versions of functions that take advantage of features of the 
specified instruction features. 
.NL
.PP
If the compiler finds such an opportunity, it first
checks whether generating a feature\-specific version of a function is likely to
result in a performance gain. If this is the case, the compiler generates both
a feature\-specific version of a function and a baseline version of the
function. At run time, one of the versions is chosen to execute, depending on
the Intel(R) processor in use. In this way, the program can benefit from
performance gains on more advanced Intel processors, while still working
properly on older processors and non\-Intel processors. A non\-Intel processor
always executes the baseline code path. 
.NL
.PP
You can use more than one of the feature values by
combining them. For example, you can specify 
\-axSSE4.1,SSSE3 (Linux
and OS X) or 
/QaxSSE4.1,SSSE3
(Windows). You cannot combine the old style, deprecated options and the new
options. For example, you cannot specify 
\-axSSE4.1,T (Linux and OS
X) or 
/QaxSSE4.1,T (Windows). 
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-Bdir
.RS
.TP
Specifies a directory that can be used to find include files, libraries, and executables.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the directory to be used. If necessary, the compiler adds a directory separator character at the end of \fIdir\fR.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler looks for files in the directories specified in your PATH environment variable.
.TP
\fBDescription:\fR 
.PP
This option specifies a directory that can be used to find include files, libraries, and executables.
.NL
.PP
The compiler uses \fIdir\fR as a prefix.
.NL
.PP
For include files, the \fIdir\fR is converted to \-I/\fIdir\fR/include. This command is added to the front of the includes passed to the preprocessor.
.NL
.PP
For libraries, the \fIdir\fR is converted to \-L/\fIdir\fR. This command is added to the front of the standard \-L inclusions before system libraries are added.
.NL
.PP
For executables, if \fIdir\fR contains the name of a tool, such as ld or as, the compiler will use it instead of those found in the default directories.
.NL
.PP
The compiler looks for include files in \fIdir\fR /include while library files are looked for in \fIdir\fR.
.NL
.PP
On Linux* systems, another way to get the behavior of this option is to use the environment variable GCC_EXEC_PREFIX.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bdynamic (L*X only)
.RS
.TP
Enables dynamic linking of libraries at run time.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Limited dynamic linking occurs.
.TP
\fBDescription:\fR 
.PP
This option enables dynamic linking of libraries at run time. Smaller executables are created than with static linking.
.NL
.PP
This option is placed in the linker command line corresponding to its location on the user command line. It controls the linking behavior of any library that is passed using the command line.
.NL
.PP
All libraries on the command line following option \-Bdynamic are linked dynamically until the end of the command line or until a \-Bstatic option is encountered. The \-Bstatic option enables static linking of libraries. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bstatic (L*X only)
.RS
.TP
Enables static linking of a user\[aq]s library.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Default static linking occurs.
.TP
\fBDescription:\fR 
.PP
This option enables static linking of a user\[aq]s library.
.NL
.PP
This option is placed in the linker command line corresponding to its location on the user command line. It controls the linking behavior of any library that is passed using the command line.
.NL
.PP
All libraries on the command line following option \-Bstatic are linked statically until the end of the command line or until a \-Bdynamic option is encountered. The \-Bdynamic option enables dynamic linking of libraries.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bsymbolic (L*X only)
.RS
.TP
Binds references to all global symbols in a program to the definitions within a user\[aq]s shared library.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
When a program is linked to a shared library, it can override the definition within the shared library.
.TP
\fBDescription:\fR 
.PP
This option binds references to all global symbols in a program to the definitions within a user\[aq]s shared library.
.NL
.PP
This option is only meaningful on Executable Linkage Format (ELF) platforms that support shared libraries.
.NL
.PP
.B CAUTION:
This option can have unintended side\-effects of disabling symbol preemption in the shared library.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bsymbolic\-functions (L*X only)
.RS
.TP
Binds references to all global function symbols in a program to the definitions within a user\[aq]s shared library.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
When a program is linked to a shared library, it can override the definition within the shared library.
.TP
\fBDescription:\fR 
.PP
This option binds references to all global function symbols in a program to the definitions within a user\[aq]s shared library.
.NL
.PP
This option is only meaningful on Executable Linkage Format (ELF) platforms that support shared libraries.
.NL
.PP
.B CAUTION:
This option can have unintended side\-effects of disabling symbol preemption in the shared library.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-c
.RS
.TP
Prevents linking.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Linking is performed.
.TP
\fBDescription:\fR 
.PP
This option prevents linking. Compilation stops after the object file is generated.
.NL
.PP
The compiler generates an object file for each C or C++ source file or preprocessed source file. It also takes an assembler file and invokes the assembler to generate an object file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-C
.RS
.TP
Places comments in preprocessed source
output. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No comments are placed in preprocessed source
output.
.TP
\fBDescription:\fR 
.PP
This option places (or preserves) comments in
preprocessed source output.
.NL
.PP
Comments following preprocessing directives, however, are
not preserved.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-check=keyword[, 
keyword...]
.TP
.B
/check:keyword[, 
keyword...]
.RS
.TP
Checks for certain conditions at run
time.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies the conditions to check. Possible values
are:
.RS
.TP 15
[no]conversions
Determines whether checking occurs for
converting to smaller types. Keyword 
conversions enables this checking.
.TP 15
[no]stack
Determines whether checking occurs on the
stack frame. Keyword 
stack enables this checking. If 
stack is specified, the stack is checked for
buffer overruns and buffer underruns. This option also enforces local variables
initialization and stack pointer verification.
.TP 15
[no]uninit
Determines whether checking occurs for
uninitialized variables. Keyword 
uninit enables this checking. If a variable is
read before it is written, a run\-time error routine will be called.
.IP
Run\-time checking of undefined variables is
only implemented on local, scalar variables. It is not implemented on
dynamically allocated variables, extern variables or static variables. It is
not implemented on structs, classes, unions or arrays. 
.RE
.TP
\fBDefault:\fR 
.TP 18
noconversions nostack nouninit
.NL
No checking is performed for the above run\-time
conditions.
.TP
\fBDescription:\fR 
.PP
This option checks for certain conditions at run time.
.NL
.PP
On Windows* systems, this option disables any default or specified
optimizations and applies the 
/Od level of optimization. If you specified optimizations, the
compiler emits warning diagnostics for the disabled optimizations.
.NL
.PP
On Linux* and OS X* systems, this option may disable some optimizations.
.NL
.PP
.B NOTE:
This option requires library support. Depending on the
platform, the required library is either in your operating system run\-time
environment or in your compiler package.
.TP
\fBAlternate Options:\fR 
.TP 18
check conversions
.NL
Linux and OS X: None
.TP 18
check
stack
.NL
Linux and OS X: None
.TP 18
check
uninit
.NL
Linux and OS X: None
.RE
.TP
.B
\-check\-pointers=keyword (L*X only)
.RS
.TP
Determines whether the compiler checks
bounds for memory access through pointers.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies what type of bounds checking occurs.
Possible values are:
.RS
.TP 15
none
Disables bounds checking. This is the
default.
.TP 15
rw
Checks bounds for reads and writes through
pointers.
.TP 15
write
Checks bounds for only writes through
pointers.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-check\-pointers=none or 
/Qcheck\-pointers:none
.NL
No bounds checking occurs for memory access through
pointers.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler checks bounds for memory access
through pointers. It enables checking of all indirect accesses through
pointers, and all array accesses.
.NL
.PP
The compiler may optimize these checks away when it can determine that an
access is safe.
.NL
.PP
When 
rw or 
write is specified, the 
[Q]check\-pointers\-undimensioned option is set and dimensioned
and undimensioned arrays are checked. 
.NL
.PP
If you do not want undimensioned arrays checked, you must specify option the
negative form of the option (see Syntax above).
.NL
.PP
This pointer checker feature requires installation of
another product. For more information, see 
Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-check\-pointers\-dangling=keyword (L*X only)
.RS
.TP
Determines whether the compiler checks
for dangling pointer references.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies what type of dangling pointer checking
occurs. Possible values are:
.RS
.TP 15
none
Disables checking for dangling pointer
references. This is the default.
.TP 15
heap
Checks for dangling pointer references on
the heap.
.TP 15
stack
Checks for dangling pointer references on
the stack.
.TP 15
all
Checks for dangling pointer references on
the heap and the stack.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-check\-pointers\-dangling=none or 
/Qcheck\-pointers\-dangling:none
.NL
No checking occurs for dangling pointer
references.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler checks for dangling pointer
references.
.NL
.PP
To use this option, you must also specify the 
[Q]check\-pointers option. 
.NL
.PP
This pointer checker feature requires installation of
another product. For more information, see 
Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-check\-pointers\-mpx=keyword (L*X only)
.RS
.TP
Determines whether the compiler checks
bounds for memory access through pointers on processors that support Intel(R)
Memory Protection Extensions (Intel(R) MPX). 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology 
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies what type of bounds checking occurs.
Possible values are: 
.RS
.TP 15
none
Disables bounds checking. This is the
default. 
.TP 15
rw
Checks bounds for reads and writes through
pointers. 
.TP 15
write
Checks bounds for only writes through
pointers. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-check\-pointers\-mpx=none or 
/Qcheck\-pointers\-mpx:none
.NL
No bounds checking occurs for memory access through
pointers on processors that support Intel(R) MPX. 
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler checks bounds
for memory access through pointers on processors that support Intel(R) MPX. It
enables checking of all indirect accesses through pointers, and all array
accesses. 
.NL
.PP
The compiler may optimize these checks away when it can
determine that an access is safe. 
.NL
.PP
If you specify option 
[Q]check\-pointers along with option 
[Q]check\-pointers\-mpx, option 
[Q]check\-pointers\-mpx takes precedence. 
.NL
.PP
If you specify 
[Q]check\-pointers\-mpx, you cannot specify option 
[Q]check\-pointers\-dangling. 
.NL
.PP
.B NOTE:
This feature requires supporting hardware, OS, and
library support. Intel(R) MPX bounds exceptions are hardware exceptions that are
handled by the OS and run\-time library, similar to the way that a null pointer
exception is handled. Pointer Checker detailed reports and report control
functions are not enabled with Intel(R) MPX, because these require overriding the
OS exception handling. 
.PP
For more details, see the document titled: Intel(R)
Memory Protection Extensions Enabling Guide, which is located at
http://intel.ly/1QlUdjN 
.PP
This pointer checker feature requires installation of
another product. For more information, see 
Feature Requirements. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-check\-pointers\-narrowing (L*X only)
.TP
.B
\-no\-check\-pointers\-narrowing (L*X only)
.RS
.TP
Determines whether the compiler enables
or disables the narrowing of pointers to structure fields.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-check\-pointers\-narrowing or 
/Qcheck\-pointers\-narrowing
.NL
The compiler enables the narrowing of pointers to
structure fields.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler enables or disables the
narrowing of pointers to structure fields. Narrowing restricts a field pointer
so that it can only legally point to that field.
.NL
.PP
To use this option, you must also specify the 
[Q]check\-pointers option. 
.NL
.PP
Disabling this feature can improve Pointer Checker compatibility with
non\-ANSI compliant code.
.NL
.PP
To disable the narrowing of pointers to structure fields, specify the
negative form of the option (see Syntax above).
.NL
.PP
This pointer checker feature requires installation of another product. For
more information, see Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-check\-pointers\-undimensioned (L*X only)
.TP
.B
\-no\-check\-pointers\-undimensioned (L*X only)
.RS
.TP
Determines whether the compiler checks
bounds for memory access through arrays that are declared without dimensions. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology 
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-check\-pointers\-undimensioned or 
/Qcheck\-pointers\-undimensioned
.NL
Bounds checking occurs for memory access through
arrays that are declared without dimensions. This checking occurs for both
dimensioned and undimensioned arrays. 
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler checks bounds for memory access
through arrays that are declared without dimensions. 
.NL
.PP
To use this option, you must also specify the 
[Q]check\-pointers option. 
.NL
.PP
This pointer checker feature requires installation of
another product. For more information, see 
Feature Requirements. 
.NL
.PP
The default setting, 
[Q]check\-pointers\-undimensioned, can cause link time errors
for multiple definitions for non\-standard code and it can cause linker warnings
for undefined symbols when linking library code that has not been compiled with
pointer checking enabled. In both of these cases, the symbols will contain the
string cp_array_end. 
.NL
.PP
To prevent these issues, disable the checking of undimensioned arrays, by
specifying the negative form of the option (see Syntax above). 
.NL
.PP
Note that even if you specify the negative form of the option, dimensioned
arrays are always checked. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-check\-uninit
.TP
.B
\-no\-check\-uninit
.RS
.TP
Determines whether checking occurs for uninitialized variables. This is a deprecated option. The replacement option is \-check=uninit.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-check\-uninit
.NL
No checking occurs for uninitialized variables.
.TP
\fBDescription:\fR 
.PP
This option determines whether checking occurs for uninitialized variables. Option \-check\-uninit enables this checking.
.NL
.PP
If a variable is read before it is written, a run\-time error routine will be called. 
.NL
.PP
Run\-time checking of undefined variables is only implemented on local, scalar variables. It is not implemented on dynamically allocated variables, extern variables or static variables. It is not implemented on structs, classes, unions or arrays.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-check=uninit
.NL
.PP
Windows: /check:uninit
.NL
.RE
.TP
.B
\-cilk\-serialize
.RS
.TP
Causes serialization of Intel(R) Cilk(TM) Plus
code.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The Intel(R) Cilk(TM) Plus language extensions are
recognized.
.TP
\fBDescription:\fR 
.PP
This option causes serialization of code that contains Intel(R) Cilk(TM) Plus
language extensions. This means that the compiler will run the program as if it
were a C/C++ serialized program.
.NL
.PP
This option forces inclusion of a special header file (cilk_stub.h) that
includes preprocessor macros that make certain specific keywords that are
related to those language extensions invisible to the compiler.
.NL
.PP
The serialization of a program containing these special language extensions
is described in Using Intel(R) Cilk(TM) Plus.
.NL
.PP
.B NOTE:
Vector parallelism, which is generated by the array notations within
Intel(R) Cilk(TM) Plus, is not affected by this compiler option.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-clang\-name=name (M*X only)
.RS
.TP
Specifies the name of the Clang compiler
that should be used to set up the environment for C compilations. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the Clang compiler to use. It can
include the path where the Clang compiler is located. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses the PATH setting to find the
Clang compiler and resolve environment settings. 
.TP
\fBDescription:\fR 
.PP
This option specifies the name of the Clang compiler that
should be used to set up the environment for C compilations. If you do not
specify a path, the compiler will search the PATH settings for the compiler
name you provide. 
.NL
.PP
This option is helpful when you are referencing a
non\-standard Clang installation. 
.NL
.PP
The C++ equivalent to option 
\-clang\-name is 
\-clangxx\-name. 
.NL
.PP
.B NOTE:
This option applies to the Intel compiler running in a
CLANG environment. It does not apply to the Intel CLANG\-based compiler. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-clangxx\-name=name (M*X only)
.RS
.TP
Specifies the name of the Clang++
compiler that should be used to set up the environment for C++ compilations. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the Clang++ compiler to use. It can
include the path where the Clang++ compiler is located. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses the PATH setting to find the
Clang++ compiler and resolve environment settings. 
.TP
\fBDescription:\fR 
.PP
This option specifies the name of the Clang++ compiler
that should be used to set up the environment for C++ compilations. If you do
not specify a path, the compiler will search the PATH settings for the compiler
name you provide. 
.NL
.PP
The C equivalent to option 
\-clangxx\-name is 
\-clang\-name. 
.NL
.PP
.B NOTE:
This option applies to the Intel compiler running in a
CLANG environment. It does not apply to the Intel CLANG\-based compiler. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-complex\-limited\-range
.TP
.B
\-no\-complex\-limited\-range
.RS
.TP
Determines whether the use of basic
algebraic expansions of some arithmetic operations involving data of type
COMPLEX is enabled.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-complex\-limited\-range 
.NL
Basic algebraic expansions of some arithmetic
operations involving data of type COMPLEX are disabled.
.TP
\fBDescription:\fR 
.PP
This option determines whether the use of basic algebraic
expansions of some arithmetic operations involving data of type COMPLEX is
enabled. 
.NL
.PP
When the option is enabled, this can cause performance
improvements in programs that use a lot of COMPLEX arithmetic. However, values
at the extremes of the exponent range may not compute correctly. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-cxxlib[=dir] (L*X only)
.TP
.B
\-cxxlib\-nostd (L*X only)
.TP
.B
\-no\-cxxlib (L*X only)
.RS
.TP
Determines whether the compiler links using the C++ run\-time libraries and header files provided by gcc.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is an optional top\-level location for the gcc binaries and libraries.
.TP
\fBDefault:\fR 
.TP 18
C++: \-cxxlib C: \-no\-cxxlib
.NL
For C++, the compiler uses the run\-time libraries and headers provided by gcc. For C, the compiler uses the default run\-time libraries and headers and does not link to any additional C++ run\-time libraries and headers. However, if you specify compiler option \-std=gnu++98, the default is \-cxxlib.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler links using the C++ run\-time libraries and header files provided by gcc. 
.NL
.PP
If you specify \fIdir\fR for cxxlib, the compiler uses \fIdir\fR/bin/gcc to setup the environment.
.NL
.PP
Option \-cxxlib=\fIdir\fR can be used with option \-gcc\-name=\fIname\fR to specify the location \fIdir\fR/bin/\fIname\fR.
.NL
.PP
Option \-cxxlib\-nostd prevents the compiler from linking with the standard C++ library. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Dname[=value]
.RS
.TP
Defines a 
macro name that can be
associated with an optional value. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the 
macro. 
.TP 18
\fIvalue\fR
.NL
Is an optional integer or an optional character
string delimited by double quotes; for example, 
D\fIname=string\fR. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Only default symbols or macros are defined. 
.TP
\fBDescription:\fR 
.PP
Defines a 
macro name that can be
associated with an optional value. 
This option is
equivalent to a #define preprocessor directive.
.NL
.PP
If a 
\fIvalue\fR is not
specified, 
\fIname\fR  is defined as "1". 
.NL
.PP
.B CAUTION:
On Linux* and OS X* systems, if you are not specifying
a 
\fIvalue\fR, do not use 
D for 
\fIname\fR, because it
will conflict with the 
\-DD option. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-daal[=lib]
.RS
.TP
Tells the compiler to link to certain
libraries in the Intel(R) Data Analytics Acceleration Library (Intel(R) DAAL). 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor (code name
Knights Landing),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology 
.TP
\fBArguments:\fR 
.TP 18
\fIlib\fR
.NL
Indicates which Intel(R) DAAL library files should be
linked. Possible values are: 
.RS
.TP 15
parallel
Tells the compiler to link using the threaded
Intel(R) DAAL libraries. This is the default if the option is specified with no 
\fIlib\fR. 
.TP 15
sequential
Tells the compiler to link using the
non\-threaded Intel(R) DAAL libraries. 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not link to the Intel(R) DAAL. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to link to certain libraries in the Intel(R)
Data Analytics Acceleration Library (Intel(R) DAAL). 
.NL
.PP
On Linux* and OS X* systems, the associated Intel(R) DAAL headers are included
when you specify this option. 
.NL
.PP
.B NOTE:
On Windows* systems, this option is processed by the
compiler, which adds directives to the compiled object file that are processed
by the linker. On Linux* and OS X* systems, this option is processed by the 
icc/icpc command that initiates linking, adding library
names explicitly to the link command. 
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-dD
.RS
.TP
Same as  option \-dM, but outputs #define directives in preprocessed source.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not output #define directives.
.TP
\fBDescription:\fR 
.PP
Same as \-dM, but outputs #define directives in preprocessed source. To use this option, you must also specify the E option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-debug [keyword]
.RS
.TP
Enables or disables generation of
debugging information. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is the type of debugging information to be
generated. Possible values are: 
.RS
.TP 15
none
Disables generation of debugging information.
.TP 15
full or
all
Generates complete debugging information. 
.TP 15
minimal
Generates line number information for
debugging. 
.TP 15
[no]emit_column
Determines whether the compiler generates column
number information for debugging.
.TP 15
[no]expr\-source\-pos
Determines whether the compiler generates
source position information at the expression level of granularity. 
.TP 15
[no]inline\-debug\-info
Determines whether the compiler generates
enhanced debug information for inlined code. 
.TP 15
[no]macros
Determines whether the compiler emits
debugging information for C/C++ macros. 
.TP 15
[no]pubnames
Determines whether the compiler generates a
DWARF debug_pubnames section. 
.TP 15
[no]semantic\-stepping
Determines whether the compiler generates
enhanced debug information useful for breakpoints and stepping. 
.TP 15
[no]variable\-locations
Determines whether the compiler generates
enhanced debug information useful in finding scalar local variables. 
.TP 15
extended
Sets keyword values 
semantic\-stepping and
variable\-locations. 
.TP 15
[no]parallel (Linux only)
Determines whether the compiler generates
parallel debug code instrumentations useful for thread data sharing and
reentrant call detection. 
.RE
.PP
For information on the non\-default settings for these
keywords, see the Description section. 
.NL
.TP
\fBDefault:\fR 
.TP 18
varies
.NL
Normally, the default is 
\-debug none and no debugging information is generated.
However, on Linux*, the 
\-debug inline\-debug\-info option will be enabled by
default if you compile with optimizations (option 
\-O2 or higher) and debugging is enabled (option 
\-g). 
.TP
\fBDescription:\fR 
.PP
This option enables or disables generation of debugging
information. 
.NL
.PP
By default, enabling debugging, will disable
optimization. To enable both debugging and optimization use the 
\-debug option together
with one of the optimization level options (\-O3, 
\-O2 or 
\-O3). 
.NL
.PP
Keywords 
semantic\-stepping, 
inline\-debug\-info, 
variable\-locations, and 
extended can be used in
combination with each other. If conflicting keywords are used in combination,
the last one specified on the command line has precedence. 
.NL
.TP 18
\fBOption 
\fR
.NL
.NL
\fBDescription 
\fR
.NL
.NL
.TP 18
\-debug none
.NL
Disables generation of debugging information. 
.NL
.TP 18
\-debug full or 
\-debug all
.NL
Generates complete debugging information. It is
the same as specifying 
\-debug with no
keyword. 
.NL
.TP 18
\-debug minimal
.NL
Generates line number information for
debugging. 
.NL
.TP 18
\-debug emit_column
.NL
Generates column number information for
debugging. 
.NL
.TP 18
\-debug expr\-source\-pos
.NL
Generates source position information at the
statement level of granularity. 
.NL
.TP 18
\-debug inline\-debug\-info
.NL
Generates enhanced debug information for
inlined code. 
.TP 18
On inlined functions, symbols are (by default) associated with the
caller. This option causes symbols for inlined functions to be associated with
the source of the called function. 
.NL
.TP 18
\-debug macros
.NL
The compiler emits debugging information for
C/C++ macros. This provides a means to describe the macros for a given
compilation unit. 
.NL
.TP 18
\-debug pubnames
.NL
The compiler generates a DWARF debug_pubnames
section. This provides a means to list the names of global objects and
functions in a compilation unit. 
.NL
.TP 18
\-debug semantic\-stepping
.NL
Generates enhanced debug information useful for
breakpoints and stepping. It tells the debugger to stop only at machine
instructions that achieve the final effect of a source statement. 
.TP 18
For example, in the case of an assignment
statement, this might be a store instruction that assigns a value to a program
variable; for a function call, it might be the machine instruction that
executes the call. Other instructions generated for those source statements are
not displayed during stepping. 
.TP 18
This option has no impact unless optimizations
have also been enabled. 
.NL
.TP 18
\-debug variable\-locations
.NL
Generates enhanced debug information useful in
finding scalar local variables. It uses a feature of the Dwarf object module
known as "location lists". 
.TP 18
This feature allows the run\-time locations of
local scalar variables to be specified more accurately; that is, whether, at a
given position in the code, a variable value is found in memory or a machine
register. 
.NL
.TP 18
\-debug extended
.NL
Sets keyword values 
semantic\-stepping and 
variable\-locations. It
also tells the compiler to include column numbers in the line information. 
.NL
.TP 18
\-debug parallel
.NL
Generates parallel debug code instrumentations
needed for the thread data sharing and reentrant call detection. 
For shared
data and reentrancy detection, option 
\-qopenmp must be set.
.NL
.PP
On Linux* systems, debuggers read debug information from
executable images. As a result, information is written to object files and then
added to the executable by the linker. 
.NL
.PP
On OS X* systems, debuggers read debug information from
object files. As a result, the executables don\[aq]t contain any debug information.
Therefore, if you want to be able to debug on these systems, you must retain
the object files. 
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
For 
\-debug full, 
\-debug all, or 
\-debug
.NL
Linux and OS X: 
\-g
.TP 18
For 
\-debug
variable\-locations
.NL
Linux and OS X: 
\-fvar\-tracking
.TP 18
For 
\-debug
semantic\-stepping
.NL
Linux and OS X: 
\-fvar\-tracking\-assignments
.RE
.TP
.B
\-diag\-type=diag\-list
.RS
.TP
Controls the display of diagnostic
information during compilation. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fItype\fR
.NL
Is an action to perform on diagnostics. Possible
values are: 
.RS
.TP 15
enable
Enables a diagnostic message or a group of
messages. If you specify 
\-diag\-enable=all (Linux* and OS X*) or 
/Qdiag\-enable:all (Windows*), all diagnostic
messages shown in 
\fIdiag\-list\fR are enabled. 
.TP 15
disable
Disables a diagnostic message or a group of
messages. If you specify 
\-diag\-disable=all (Linux* and OS X*) or 
/Qdiag\-disable:all (Windows*), all diagnostic
messages shown in 
\fIdiag\-list\fR are disabled. 
.TP 15
error
Tells the compiler to change diagnostics to
errors. 
.TP 15
warning
Tells the compiler to change diagnostics to
warnings. 
.TP 15
remark
Tells the compiler to change diagnostics to
remarks (comments). 
.RE
.TP 18
\fIdiag\-list\fR
.NL
Is a diagnostic group or ID value. Possible values
are: 
.RS
.TP 15
driver
Specifies diagnostic messages issued by the
compiler driver. 
.TP 15
port\-linux
Specifies diagnostic messages for language
features that may cause errors when porting to Linux* systems. This diagnostic
group is only available on Windows* systems. 
.TP 15
port\-win
Specifies diagnostic messages for GNU
extensions that may cause errors when porting to Windows. This diagnostic group
is only available on Linux and OS X* systems. 
.TP 15
thread
Specifies diagnostic messages that help in
thread\-enabling a program. 
.TP 15
vec
Specifies diagnostic messages issued by the
vectorizer. 
.TP 15
par
Specifies diagnostic messages issued by the
auto\-parallelizer (parallel optimizer). 
.TP 15
openmp
Specifies diagnostic messages issued by the
OpenMP* parallelizer. 
.TP 15
warn
Specifies diagnostic messages that have a
"warning" severity level. 
.TP 15
error
Specifies diagnostic messages that have an
"error" severity level. 
.TP 15
remark
Specifies diagnostic messages that are
remarks or comments. 
.TP 15
cpu\-dispatch
Specifies the CPU dispatch remarks for
diagnostic messages. These remarks are enabled by default. 
.TP 15
id[,id,...]
Specifies the ID number of one or more
messages. If you specify more than one message number, they must be separated
by commas. There can be no intervening white space between each 
id. 
.TP 15
tag[,tag,...]
Specifies the mnemonic name of one or more
messages. If you specify more than one mnemonic name, they must be separated by
commas. There can be no intervening white space between each 
tag. 
.RE
.IP
The diagnostic messages generated can be affected
by certain options, such as 
[Q]x, 
/arch (Windows) or 
\-m (Linux and OS X). 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler issues certain diagnostic messages by
default. 
.TP
\fBDescription:\fR 
.PP
This option controls the display of diagnostic
information during compilation. Diagnostic messages are output to stderr unless
the 
[Q]diag\-file option is
specified. 
.NL
.PP
To control the diagnostic information reported by the
vectorizer, use options 
[q or Q]opt\-report and 
[q or Q]opt\-report\-phase, phase 
vec. 
.NL
.PP
To control the diagnostic information reported by the
auto\-parallelizer, use options 
[q or Q]opt\-report and 
[q or Q]opt\-report\-phase, phase 
par. 
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
enable vec
.NL
Linux and OS X: 
\-qopt\-report; 
\-qopt\-report \-qopt\-report\-phase=vec
.TP 18
disable vec
.NL
Linux and OS X: 
\-qopt\-report=0 \-qopt\-report\-phase=vec
.TP 18
enable par
.NL
Linux and OS X: 
\-qopt\-report; 
\-qopt\-report \-qopt\-report\-phase=par
.TP 18
disable par
.NL
Linux and OS X: 
\-qopt\-report=0 \-qopt\-report\-phase=par
.RE
.TP
.B
\-diag\-dump
.RS
.TP
Tells the compiler to print all enabled diagnostic messages and stop compilation.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler issues certain diagnostic messages by default.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to print all enabled diagnostic messages and stop compilation. The diagnostic messages are output to stdout.
.NL
.PP
This option prints the enabled diagnostics from all possible diagnostics that the compiler can issue, including any default diagnostics.
.NL
.PP
If \fIdiag\-list\fR is specified for the [Q]diag\-enable option, the print out will include the \fIdiag\-list\fR diagnostics.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-enable=power
.TP
.B
\-diag\-disable=power
.RS
.TP
Controls whether diagnostics are enabled for possibly inefficient code that may affect power consumption on IA\-32 and Intel(R) 64 architectures.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-diag\-disable=power or
/Qdiag\-disable:power
.NL
Power consumption diagnostics are disabled.
.TP
\fBDescription:\fR 
.PP
This option controls whether diagnostics are
enabled for possibly inefficient code that may affect power
consumption on IA\-32 and Intel(R) 64 architectures.
.NL
.PP
If you specify option \-diag\-enable=power
(Linux* and OS X*) or /Qdiag\-enable:power (Windows*), the compiler will detect
various API calls with argument values in ranges known to be
inefficient for power consumption. The diagnostic issued will point
out the problem argument; for example, "power inefficient use of
\[aq]Sleep\[aq] with argument in range [0;10]".
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-enable=sc[n] (L*X only)
.TP
.B
\-diag\-enable=sc\-mode (L*X only)
.TP
.B
\-diag\-disable=sc (L*X only)
.RS
.TP
Enables static analysis diagnostics. You can determine which diagnostics to emit based on severity or you can specify an analysis mode for diagnostic messages. This is a deprecated option. There is no replacement option.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Specifies the level of severity to report. Possible values are:  
.RS
.TP 15
1
Reports only diagnostics with a severity level of "critical". Diagnostics with a severity level of "error" or "warning" are not displayed.
.TP 15
2
Reports all diagnostics with a severity level of "critical" and "error". Diagnostics with a severity level of "warning" are not reported. This is the default.
.TP 15
3
Reports all diagnostics regardless of the severity level.
.RE
.TP 18
\fImode\fR
.NL
Specifies the analysis mode. Possible values are:
.RS
.TP 15
full
This mode attempts to find all program weaknesses, even at the expense of more false positives. This mode is recommended when using the tool for security assurance. 
.IP
This is the default if \-diag\-enable=sc{[1|2|3]} (Linux* OS and OS X*) or
/Qdiag\-enable:sc{[1|2|3]} (Windows* OS) is present. Otherwise, the default is
None (static analysis diagnostics are
disabled).
.TP 15
concise
This mode attempts to reduce false positives
somewhat more than reducing false negatives. This mode is recommended when using the tool for general error
detection.
.TP 15
precise
This mode attempts to avoid all false positives, even at the expense of substantially reduced error checking. This mode is recommended when using the tool for acceptance screening.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-diag\-disable=sc and /Qdiag\-disable:sc
.NL
Static analysis diagnostics are disabled.
.TP
\fBDescription:\fR 
.PP
This option enables static analysis diagnostics. 
.NL
.PP
If you specify \fIn\fR for the option, you can determine which diagnostics to emit based on severity.  If you specify \fImode\fR, you can also specify an analysis mode for diagnostic messages. 
.NL
.PP
To disable static analysis, specify /Qdiag\-disable:sc (Windows* OS) or option \-diag\-disable=sc (Linux* OS). 
.NL
.PP
You can also specify the following options that affect the diagnostics:
.NL
.IP \(bu 2
Option [Q]diag\-error setting sc
This changes all Static Analysis diagnostics to errors.
.IP \(bu 2
Option [Q]diag\-warning setting sc
This changes all Static Analysis diagnostics to warnings.
.IP \(bu 2
Option [Q]diag\-remark setting sc
This changes all Static Analysis diagnostics to remarks (comments).
.PP
This static analysis feature requires installation of another product. For more information, see Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-enable=sc\-enums (L*X only)
.RS
.TP
Tells static analysis to treat enumeration variables as known values equal to any one of the associated enumeration literals. This is a deprecated option. There is no replacement option.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
If static analysis is enabled, it treats unknown enumeration variables as unknown integer values.
.TP
\fBDescription:\fR 
.PP
This option tells static analysis to treat enumeration variables as known values equal to any one of the associated enumeration literals.  By default, static analysis treats unknown enumeration variables as unknown integer values.  Setting this option may find additional errors but tends to create more false positives.
.NL
.PP
This option is ignored unless you enable static analysis diagnostics by specifying option [Q]diag\-enable setting sc[n] or setting sc\-mode.
.NL
.PP
This static analysis feature requires installation of another product. For more information, see Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-enable=sc\-include (L*X only)
.RS
.TP
Tells a source code analyzer to process include files and source files when issuing diagnostic messages.  This is a deprecated option. There is no replacement option.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler issues certain diagnostic messages by default. If static analysis is enabled, include files are not analyzed by default.
.TP
\fBDescription:\fR 
.PP
This option tells the static security analyzer to process include files and source files when issuing diagnostic messages. Normally, when static analysis diagnostics are enabled, only source files are analyzed. 
.NL
.PP
This option is ignored unless you enable static analysis diagnostics by specifying option [Q]diag\-enable setting sc[n] or setting sc\-mode.
.NL
.PP
This static analysis feature requires installation of another product. For more information, see Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-enable=sc\-single\-file (L*X only)
.RS
.TP
Tells static analysis to process each file individually. This is a deprecated option. There is no replacement option.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
If static analysis is
enabled, it analyzes the whole program.
.TP
\fBDescription:\fR 
.PP
This option tells static analysis to process each file individually.  Skipping the usual whole\-program analysis reduces memory requirements and analysis time on large programs but often finds fewer real errors. 
.NL
.PP
This option is ignored unless you enable static analysis diagnostics by specifying option [Q]diag\-enable setting sc[n] or setting sc\-mode.
.NL
.PP
This static analysis feature requires installation of another product. For more information, see Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-error\-limit=n
.TP
.B
\-no\-diag\-error\-limit
.RS
.TP
Specifies the maximum number of errors allowed before compilation stops.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the maximum number of error\-level or fatal\-level compiler errors allowed.
.TP
\fBDefault:\fR 
.TP 18
30
.NL
A maximum of 30 error\-level and fatal\-level messages are allowed.
.TP
\fBDescription:\fR 
.PP
This option specifies the maximum number of errors allowed before compilation stops. It indicates the maximum number of error\-level or fatal\-level compiler errors allowed for a file specified on the command line. 
.NL
.PP
If you specify the negative form of the [Q]diag\-error\-limit option on the command line, there is no limit on the number of errors that are allowed.
.NL
.PP
If the maximum number of errors is reached, a warning message is issued and the next file (if any) on the command line is compiled.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-wn (this is a deprecated option)
.NL
.RE
.TP
.B
\-diag\-file[=filename] (L*X only)
.RS
.TP
Causes the results of diagnostic analysis
to be output to a file. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file for output. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Diagnostic messages are output to stderr. 
.TP
\fBDescription:\fR 
.PP
This option causes the results of diagnostic analysis to
be output to a file. The file is placed in the current working directory. 
.NL
.PP
You can include a file extension in 
\fIfilename\fR. For
example, if 
\fIfile.txt\fR is specified, the name of the output file is 
\fIfile.txt\fR. If you do not provide a file extension, the name
of the file is 
\fIfilename.diag\fR. 
.NL
.PP
If 
\fIfilename\fR is not
specified, the name of the file is 
\fIname\-of\-the\-first\-source\-file.diag\fR.
This is also the name of the file if the name specified for file conflicts with
a source file name provided in the command line. 
.NL
.PP
.B NOTE:
If you specify the 
[Q]diag\-file option and
you also specify the 
[Q]diag\-file\-append
option, the last option specified on the command line takes precedence. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-diag\-file\-append[=filename] (L*X only)
.RS
.TP
Causes the results of diagnostic analysis to be appended to a file.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file to be appended to. It can include a path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Diagnostic messages are output to stderr.
.TP
\fBDescription:\fR 
.PP
This option causes the results of diagnostic analysis to be appended to a file. If you do not specify a path, the driver will look for \fIfilename\fR in the current working directory. 
.NL
.PP
If \fIfilename\fR is not found, then a new file with that name is created in the current working directory. If the name specified for file conflicts with a source file name provided in the command line, the name of the file is \fIname\-of\-the\-first\-source\-file.diag\fR.
.NL
.PP
.B NOTE:
If you specify the [Q]diag\-file\-append option and you also specify the [Q]diag\-file option, the last option specified on the command line takes precedence.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-id\-numbers
.TP
.B
\-no\-diag\-id\-numbers
.RS
.TP
Determines whether the compiler displays diagnostic messages by using their ID number values.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-diag\-id\-numbers 
.NL
The compiler displays diagnostic messages by using their ID number values.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler displays diagnostic messages by using their ID number values. If you specify the negative form of the [Q]diag\-id\-numbers option, mnemonic names are output for driver diagnostics only.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-onceid[,id,...]
.RS
.TP
Tells the compiler to issue one or more diagnostic messages only once.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIid\fR
.NL
Is the ID number of the diagnostic message. If you specify more than one message number, they must be separated by commas. There can be no intervening white space between each \fIid\fR. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler issues certain diagnostic messages by default.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to issue one or more diagnostic messages only once.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux: \-wo (this is a deprecated option)
.NL
.PP
Windows: /Qwo (this is a deprecated option)
.NL
.RE
.TP
.B
\-diag\-sc\-dir[=dir] (L*X only)
.RS
.TP
Specifies a directory for static analysis results. This is a deprecated option. There is no replacement option.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory where the results should be placed.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
If static analysis is enabled, analysis results are placed in the current working directory. For more details, see below.
.TP
\fBDescription:\fR 
.PP
This option specifies a directory for static analysis results. 
.NL
.PP
If you do not specify \fIdir\fR, the results are placed in the current working directory.  Results are placed in a subdirectory with the name r\fInnn\fRsc, where \fInnn\fR is replaced by the next available sequence number (001, 002, etc.).
.NL
.PP
This option is ignored unless you enable static analysis diagnostics by specifying option [Q]diag\-enable setting sc[n] or setting sc\-mode.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dM
.RS
.TP
Tells the compiler to output macro definitions in effect after preprocessing.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not output macro definitions after preprocessing.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to output macro definitions in effect after preprocessing. To use this option, you must also specify option E.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dN
.RS
.TP
Same as option \-dD, but output #define directives contain only macro names.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not output #define directives.
.TP
\fBDescription:\fR 
.PP
Same as \-dD, but output #define directives contain only macro names. To use this option, you must also specify option E.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dryrun
.RS
.TP
Specifies that driver tool commands should be shown but not executed.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No tool commands are shown, but they are executed.
.TP
\fBDescription:\fR 
.PP
This option specifies that driver tool commands should be shown but not executed. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dumpmachine
.RS
.TP
Displays the target machine and operating system configuration.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not display target machine or operating system information.
.TP
\fBDescription:\fR 
.PP
This option displays the target machine and operating system configuration. No compilation is performed.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dumpversion
.RS
.TP
Displays the version number of the compiler.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not display the compiler version number.
.TP
\fBDescription:\fR 
.PP
This option displays the version number of the compiler. It does not compile your source files.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dynamic\-linker file (L*X only)
.RS
.TP
Specifies a dynamic linker other than the default. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfile\fR
.NL
Is the name of the dynamic linker to be used.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default dynamic linker is used.
.TP
\fBDescription:\fR 
.PP
This option lets you specify a dynamic linker other than the default.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dynamiclib (M*X only)
.RS
.TP
Invokes the libtool command to generate dynamic libraries.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler produces an executable.
.TP
\fBDescription:\fR 
.PP
This option invokes the libtool command to generate dynamic libraries. 
.NL
.PP
When passed this option, the compiler uses the libtool command to produce a dynamic library instead of an executable when linking. 
.NL
.PP
To build static libraries, you should specify option \-staticlib or libtool \-static <objects>.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-E
.RS
.TP
Causes the preprocessor to send output to stdout.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Preprocessed source files are output to the compiler.
.TP
\fBDescription:\fR 
.PP
This option causes the preprocessor to send output to stdout. Compilation stops when the files have been preprocessed.
.NL
.PP
When you specify this option, the compiler\[aq]s preprocessor expands your source module and writes the result to stdout. The preprocessed source contains #line directives, which the compiler uses to determine the source file and line number.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-early\-template\-check
.TP
.B
\-no\-early\-template\-check
.RS
.TP
Lets you semantically check template
function template prototypes before instantiation.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-early\-template\-check
.NL
The prototype instantiation of function templates
and function members of class templates is deferred.
.TP
\fBDescription:\fR 
.PP
Lets you semantically check template function template
prototypes before instantiation. On Linux* platforms, gcc 3.4 (or newer)
compatibilty modes must be in effect. For all OS X* platforms, gcc 4.0 (or
newer) is required. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-EP
.RS
.TP
Causes the preprocessor to send output to
stdout, omitting #line directives. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Preprocessed source files are output to the
compiler. 
.TP
\fBDescription:\fR 
.PP
This option causes the preprocessor to send output to 
stdout, omitting #line
directives. 
.NL
.PP
If you also specify 
option 
P or 
Linux* 
option 
F, the preprocessor will
write the results (without #line directives) to a file instead of 
stdout. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-Fdir (M*X only)
.RS
.TP
Adds a framework directory to the head of an include file search path.
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name for the framework directory.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not add a framework directory to the head of an include file search path.
.TP
\fBDescription:\fR 
.PP
This option adds a framework directory to the head of an include file search path.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Fa[filename|dir]
.RS
.TP
Specifies that an assembly listing file
should be generated. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the assembly listing file.
.TP 18
\fIdir\fR
.NL
Is the directory where the file should be placed.
It can include 
\fIfilename\fR.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No assembly listing file is produced.
.TP
\fBDescription:\fR 
.PP
This option specifies that an assembly listing file
should be generated (optionally named 
\fIfilename\fR).
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: 
\-S
.NL
.PP
Windows: 
/S
.NL
.RE
.TP
.B
\-fabi\-version=n
.RS
.TP
Instructs the compiler to select a specific ABI implementation. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the ABI implementation. Possible values are:
.RS
.TP 15
0
Requests the latest ABI implementation.
.TP 15
1
Requests the ABI implementation used in gcc 3.2 and gcc 3.3.
.TP 15
2
Requests the ABI implementation used in gcc 3.4 and higher.
.RE
.TP
\fBDefault:\fR 
.TP 18
Varies
.NL
The compiler uses the ABI implementation that corresponds to the installed version of gcc.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to select a specific ABI implementation. This option is compatible with gcc option \-fabi\-version. If you have multiple versions of gcc installed, the compiler may change the value of \fIn\fR depending on which gcc is detected in your path.
.NL
.PP
.B NOTE:
gcc 3.2 and 3.3 are not fully ABI\-compliant, but gcc 3.4 is highly ABI\-compliant.
.PP
.B CAUTION:
Do not mix different values for \-fabi\-version in one link.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-falias
.TP
.B
\-fno\-alias
.RS
.TP
Determines whether aliasing is assumed in a
program. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-falias 
.NL
On Linux* and OS* X, aliasing is assumed in the
program. On Windows*, aliasing is not assumed in a program. 
.TP
\fBDescription:\fR 
.PP
This option determines
whether aliasing is assumed in a program. 
.NL
.PP
If you specify 
\-fno\-alias, aliasing is
not assumed in a program. 
.NL
.PP
If you specify 
\-falias, aliasing is
assumed in a program. However, this may affect performance. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-falign\-functions[=n]
.TP
.B
\-fno\-align\-functions
.RS
.TP
Tells the compiler to align 
functions on an
optimal byte boundary. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional positive integer initialization expression
indicating the number of bytes for the minimum alignment boundary. It tells the
compiler to align 
functions on a power\-of\-2 byte boundary.
If you do not specify 
\fIn\fR, the compiler aligns the start of 
functions on 16\-byte boundaries.
.IP
The 
\fIn\fR must be a positive integer less than or equal to
4096. If you specify a value that is not a power of 2, 
\fIn\fR will be rounded up to the nearest power of 2. For
example, if 23 is specified for 
\fIn\fR, 
functions will be aligned on 32 byte
boundaries.
.TP
\fBDefault:\fR 
.TP 18
\-fno\-align\-functions
.NL
The compiler aligns 
functions on 2\-byte boundaries. This is
the same as specifying 
\-falign\-functions=2
(Linux* and OS X*). 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to align 
functions on an
optimal byte boundary. If you do not specify 
\fIn\fR, the compiler
aligns the start of 
functions on 16\-byte
boundaries. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-falign\-loops[=n]
.TP
.B
\-fno\-align\-loops
.RS
.TP
Aligns loops to a power\-of\-two byte
boundary. 
.NL
.TP
\fBArguments:\fR 
.TP 18
n
.NL
Is the optional number of bytes for the minimum alignment boundary. It
must be a power of 2 between 1 and 4096, such as 1, 2, 4, 8, 16, 32, 64, 128,
and so on. 
.IP
If you specify 1 for 
n, no
alignment is performed; this is the same as specifying the negative form of the
option. 
.IP
If you do not specify 
n, the
default alignment is 16 bytes. 
.TP
\fBDefault:\fR 
.TP 18
\-fno\-align\-loops
or 
/Qalign\-loops\-
.NL
No special loop alignment is performed. 
.TP
\fBDescription:\fR 
.PP
This option aligns loops to a power\-of\-two boundary. This alignment may
improve performance. 
.NL
.PP
It can be affected by the 
pragma code_align and attribute
code_align. 
.NL
.PP
If code is compiled with the 
\-falign\-loop=m (Linux* and OS X*) or 
/Qalign\-loop:m (Windows*) option and a code_align:n pragma
precedes a loop, the loop is aligned on a max (m, n) byte boundary. If a
function is modified by a code_align:k pragma and a code_align:n pragma
precedes a loop, then both the function and the loop are aligned on a max (k,
n) byte boundary. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-falign\-stack=mode (L*X only)
.RS
.TP
Tells the compiler the stack alignment to use on entry to routines. 
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on IA\-32 architecture
.TP
\fBArguments:\fR 
.TP 18
\fImode\fR
.NL
Is the method to use for stack alignment.  Possible values are:
.RS
.TP 15
assume\-4\-byte
Tells the compiler to assume the stack is aligned on 4\-byte boundaries. The compiler can dynamically adjust the stack to 16\-byte alignment if needed. 
.TP 15
maintain\-16\-byte
Tells the compiler to not assume any specific stack alignment, but attempt to maintain alignment in case the stack is already aligned. The compiler can dynamically align the stack if needed. This setting is compatible with gcc. 
.TP 15
assume\-16\-byte
Tells the compiler to assume the stack is aligned on 16\-byte boundaries and to continue to maintain 16\-byte alignment. This setting is compatible with gcc. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-falign\-stack=assume\-16\-byte
.NL
The compiler assumes the stack is aligned on 16\-byte boundaries and continues to maintain 16\-byte alignment.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler the stack alignment to use on entry to routines.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fargument\-alias
.TP
.B
\-fargument\-noalias
.RS
.TP
Determines whether function arguments can alias each other. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fargument\-alias
.NL
Function arguments can alias each other and can alias global storage.
.TP
\fBDescription:\fR 
.PP
This option determines whether function arguments can alias each other. If you specify \-fargument\-noalias or /Qalias\-args\-, function arguments cannot alias each other, but they can alias global storage.
.NL
.PP
On Linux and OS X systems, you can also disable aliasing for global storage, by specifying option \-fargument\-noalias\-global.
.NL
.RE
.TP
.B
\-fargument\-noalias\-global
.RS
.TP
Tells the compiler that function arguments cannot alias each other and cannot alias global storage.  
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Function arguments can alias each other and can alias global storage.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler that function arguments cannot alias each other and they cannot alias global storage.
.NL
.PP
If you only want to prevent function arguments from being able to alias each other, specify option \-fargument\-noalias.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fasm\-blocks
.RS
.TP
Enables the use of blocks and entire functions of assembly code within a C or C++ file.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler allows a GNU*\-style inline assembly format.
.TP
\fBDescription:\fR 
.PP
This option enables the use of blocks and entire functions of assembly code within a C or C++ file.
.NL
.PP
It allows a Microsoft* MASM\-style inline assembly block not a GNU*\-style inline assembly block.
.NL
.PP
On OS X* systems, this option is provided for compatibility with the Apple* GNU compiler.
.NL
.TP
\fBAlternate Options:\fR 
.PP
\-use\-msasm
.NL
.RE
.TP
.B
\-fast
.RS
.TP
Maximizes speed across the entire
program. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The optimizations that maximize speed are not
enabled. 
.TP
\fBDescription:\fR 
.PP
This option maximizes speed across the entire program. 
.NL
.PP
It sets the following options: 
.NL
.PP
On OS X* systems: 
\-ipo, 
\-mdynamic\-no\-pic, 
\-O3, 
\-no\-prec\-div, 
\-fp\-model fast=2, and 
\-xHost On Windows* systems: 
/O3, 
/Qipo, 
/Qprec\-div\-, 
/fp:fast=2, and 
/QxHost On Linux* systems: 
\-ipo, 
\-O3, 
\-no\-prec\-div, 
\-static, 
\-fp\-model fast=2, and 
\-xHost On Intel(R) 64 architecture\-based
systems targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner):
[Q]ipo, 
O3, 
\-no\-prec\-div (Linux*) or 
/Qprec\-div\- (Windows*), 
\-fp\-model fast=2 (Linux*) or 
/fp:fast=2 (Windows*) 
.NL
.PP
When option 
fast is specified, you
can override the 
[Q]xHost option setting
by specifying a different processor\-specific 
[Q]x option on the
command line. However, the last option specified on the command line takes
precedence. 
.NL
.PP
For example: 
.NL
.IP \(bu 2
On Linux* systems, if you specify option 
\-fast \-xSSE3, option 
\-xSSE3 takes effect.
However, if you specify 
\-xSSE3 \-fast, option 
\-xHost takes effect. 
.IP \(bu 2
On Windows* systems, if you specify option 
/fast /QxSSE3,
option/QxSSE3 takes
effect. However, if you specify 
/QxSSE3 /fast, option 
/QxHost takes effect. 
.PP
For implications on non\-Intel processors, refer to the 
[Q]xHost documentation. 
.NL
.PP
.B NOTE:
Option 
fast sets some
aggressive optimizations that may not be appropriate for all applications. The
resulting executable may not run on processor types different from the one on
which you compile. You should make sure that you understand the individual
optimization options that are enabled by option 
fast. 
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-fast\-transcendentals
.TP
.B
\-no\-fast\-transcendentals
.RS
.TP
Enables the compiler to replace calls to
transcendental functions with faster but less precise implementations.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
depends on the setting
of \-fp\-model (Linux* and OS X*)
.NL
If you do not specify option 
\-[no\-]fast\-transcendentals:
.RS
.IP \(bu 2
The default is ON if option 
\-fp\-model fast is specified or is in effect. 
.IP \(bu 2
The default is OFF if a value\-safe setting is
specified for 
\-fp\-model (such as "precise", "source", etc.). 
.RE
.TP
\fBDescription:\fR 
.PP
This option enables the compiler to replace calls to
transcendental functions with implementations that may be faster but less
precise. 
.NL
.PP
It allows the compiler to perform certain optimizations
on transcendental functions, such as replacing individual calls to sine in a
loop with a single call to a less precise vectorized sine library routine. 
.NL
.PP
This option does not affect explicit Short Vector Math
Library (SVML) intrinsics. It only affects scalar calls to the standard math
library routines.
.NL
.PP
You cannot use option 
–fast\-transcendentals with option 
–fp\-model strict. 
.NL
.PP
This option determines the setting for the maximum allowable relative error
for math library function results (max\-error) if none of the following options
are specified:
.NL
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux* and OS X*) or 
/Qimf\-accuracy\-bits (Windows*)
.IP \(bu 2
\-fimf\-max\-error (Linux and OS X) or 
/Qimf\-max\-error (Windows)
.IP \(bu 2
\-fimf\-precision (Linux and OS X) or 
/Qimf\-precision (Windows)
.PP
This option enables extra optimization that only applies
to Intel(R) processors.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fasynchronous\-unwind\-tables
.TP
.B
\-fno\-asynchronous\-unwind\-tables
.RS
.TP
Determines whether unwind information is precise at an instruction boundary or at a call boundary. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
Intel(R) 64 architecture: \-fasynchronous\-unwind\-tables
.NL
The unwind table generated is precise at  an instruction boundary, enabling accurate unwinding at any instruction.
.TP 18
IA\-32 architecture: \-fno\-asynchronous\-unwind\-tables
.NL
The unwind table generated is precise at call boundaries only.
.TP
\fBDescription:\fR 
.PP
This option determines whether unwind information is precise at an instruction boundary or at a call boundary. The compiler generates an unwind table in DWARF2 or DWARF3 format, depending on which format is supported on your system.
.NL
.PP
If \-fno\-asynchronous\-unwind\-tables is specified, the unwind table is precise at call boundaries only. In this case, the compiler will avoid creating unwind tables for routines such as the following:
.NL
.IP \(bu 2
A C++ routine that does not declare objects with destructors and does not contain calls to routines that might throw an exception.
.IP \(bu 2
A C/C++ or Fortran routine compiled without \-fexceptions, and on Intel(R) 64 architecture, without \-traceback.
.IP \(bu 2
A C/C++ or Fortran routine compiled with \-fexceptions that does not contain calls to routines that might throw an exception.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fblocks (M*X only)
.TP
.B
\-fno\-blocks (M*X only)
.RS
.TP
Determines whether Apple* blocks are enabled or disabled. 
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fblocks
.NL
Apple* blocks are enabled.
.TP
\fBDescription:\fR 
.PP
This option determines whether Apple* blocks
(block variable declarations) are enabled or disabled.
.NL
.PP
If you want to disable Apple* blocks, specify
\-fno\-blocks.
.NL
.PP
To use this feature, OS X* 10.6 or greater is
required.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fbuiltin[\-name]
.TP
.B
\-fno\-builtin[\-name]
.RS
.TP
Enables or disables inline expansion of intrinsic functions.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is a list of one or more intrinsic functions.  If there is more than one intrinsic function, they must be separated by commas. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Inline expansion of intrinsic functions is disabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables inline expansion of one or more intrinsic functions.  
.NL
.PP
If \-fno\-builtin\fI\-name\fR  or /Qno\-builtin\fI\-name\fR is specified, inline expansion is disabled for the named functions. If \fIname\fR is not specified, \-fno\-builtin or /Oi\- disables inline expansion for all intrinsic functions.
.NL
.PP
For a list of built\-in functions affected by \-fbuiltin, search for "built\-in functions" in the appropriate gcc* documentation.
.NL
.PP
For a list of built\-in functions affected by /Oi, search for "/Oi" in the appropriate Microsoft* Visual C/C++* documentation.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fcode\-asm
.RS
.TP
Produces an assembly listing with machine code annotations.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No machine code annotations appear in the assembly listing file, if one is produced.
.TP
\fBDescription:\fR 
.PP
This option produces an assembly listing file with machine code annotations.
.NL
.PP
The assembly listing file shows the hex machine instructions at the beginning of each line of assembly code. The file cannot be assembled; the file name is the name of the source file with an extension of .cod.
.NL
.PP
To use this option, you must also specify option \-S, which causes an assembly listing to be generated.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-fcommon
.TP
.B
\-fno\-common
.RS
.TP
Determines whether the compiler treats
common symbols as global definitions. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fcommon
.NL
The compiler does not treat common symbols as
global definitions. 
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler treats common
symbols as global definitions and to allocate memory for each symbol at compile
time. 
.NL
.PP
Option 
\-fno\-common tells the
compiler to treat common symbols as global definitions. When using this option,
you can only have a common variable declared in one module; otherwise, a link
time error will occur for multiple defined symbols. 
.NL
.PP
Normally, a file\-scope
declaration with no initializer and without the 
extern or 
static keyword "int i;" is
represented as a common symbol. Such a symbol is treated as an external
reference. However, if no other compilation unit has a global definition for
the name, the linker allocates memory for it. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-fdefer\-pop
.TP
.B
\-fno\-defer\-pop
.RS
.TP
Determines whether the compiler always pops the arguments to each function call as soon as that function returns.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fdefer\-pop
.NL
The compiler uses default optimizations that may result in deferred clearance of the stack arguments.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler
always pops the arguments to each function call as soon as that
function returns.
.NL
.PP
If you want the
compiler to always pop the arguments to each function call as soon
as that function returns, specify \-fno\-defer\-pop.
.NL
.PP
For processors that must pop arguments after a
function call, the compiler normally lets arguments accumulate on
the stack for several function calls and pops them all at
once.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-feliminate\-unused\-debug\-types
.TP
.B
\-fno\-eliminate\-unused\-debug\-types
.RS
.TP
Controls the debug information emitted for types declared in a compilation unit.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-feliminate\-unused\-debug\-types 
.NL
The compiler emits debug information only for types that are actually used by a variable/parameter/etc..
.TP
\fBDescription:\fR 
.PP
This option controls the debug information emitted for types declared in a compilation unit.
.NL
.PP
If you specify \-fno\-eliminate\-unused\-debug\-types (Linux and OS X) or /Qeliminate\-unused\-debug\-types\-, it will cause the compiler to emit debug information for all types present in the sources. This option may cause a large increase in the size of the debug information.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-femit\-class\-debug\-always (L*X only)
.TP
.B
\-fno\-emit\-class\-debug\-always (L*X only)
.RS
.TP
Controls the format and size of debug information generated by the compiler for C++ classes.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-emit\-class\-debug\-always
.NL
Causes the compiler to reduce the amount of debug information generated for C++ classes.
.TP
\fBDescription:\fR 
.PP
When emission of debug information is enabled, this option will control the format and size of debug information generated by the compiler for C++ classes. It tells the compiler to generate full debug information, or it tells the compiler to reduce the amount of debug information it generates.
.NL
.PP
When you specify the \-femit\-class\-debug\-always option, the compiler emits debug information for a C++ class into each object file where the class is used.  This option is useful for tools that are not able to resolve incomplete type descriptions.  Note that this option may cause a large increase in the size of the debug information generated.
.NL
.PP
When you specify the \-fno\-emit\-class\-debug\-always option, the compiler does not emit full debug information for every instance of C++ class use. In general, this reduces the size of the debugging information generated for C++ applications without impacting debugging ability when used with debuggers that have corresponding support, such as gdb.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fexceptions
.TP
.B
\-fno\-exceptions
.RS
.TP
Enables exception handling table generation. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fexceptions
.NL
Exception handling table generation is enabled. Default for C++.
.TP 18
\-fno\-exceptions
.NL
Exception handling table generation is disabled. Default for C.
.TP
\fBDescription:\fR 
.PP
This option enables exception handling table generation. The \-fno\-exceptions option disables exception handling table generation, resulting in smaller code. When this option is used, any use of exception handling constructs (such as try blocks and throw statements) will produce an error. Exception specifications are parsed but ignored. It also undefines the preprocessor symbol __EXCEPTIONS.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fextend\-arguments=n
.RS
.TP
Controls how scalar integer arguments are extended in calls to unprototyped and varargs functions.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Specifies the extension for the integer parameters. Possible values are:
.RS
.TP 15
32
Causes unprototyped integer parameters to be extended to 32 bits.
.TP 15
64
Causes unprototyped integer parameters to be extended to 64 bits. This value is only available on Intel(R) 64 architecture.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fextend\-arguments=32 or /Qextend\-arguments:32
.NL
Unprototyped integer parameters are extended to 32 bits.
.TP
\fBDescription:\fR 
.PP
This option controls how scalar integer arguments are extended in calls to unprototyped and varargs functions.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ffat\-lto\-objects (L*X only)
.TP
.B
\-fno\-fat\-lto\-objects (L*X only)
.RS
.TP
Determines whether a fat link\-time optimization (LTO) object, containing both intermediate language and object code, is generated during an interprocedural optimization compilation (\-c –ipo).
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-ffat\-lto\-objects
.NL
When –c –ipo is specified, the compiler generates a fat link\-time optimization (LTO) object that has both a true object and a discardable intermediate language section.
.TP
\fBDescription:\fR 
.PP
This option determines whether a fat link time optimization (LTO) object, containing both intermediate language and object code, is generated during an interprocedural optimization compilation (\-c –ipo).
.NL
.PP
During an interprocedural optimization compilation (\-c –ipo), the following occurs:
.NL
.IP \(bu 2
If you specify \-ffat\-lto\-objects, the compiler generates a fat link\-time optimization (LTO) object that has both a true object and a discardable intermediate language section.  This enables both link\-time optimization (LTO) linking and normal linking.
.IP \(bu 2
If you specify \-fno\-fat\-lto\-objects, the compiler generates a fat link\-time optimization (LTO) object that only has a discardable intermediate language section; no true object is generated. This option may improve compilation time.
.PP
Note that these files will be inserted into archives in the form in which they were created.
.NL
.PP
This option is provided for compatibility with gcc. For more information about this option, see the gcc documentation.
.NL
.PP
.B NOTE:
Intel\[aq]s intermediate language representation is not compatible with gcc’s intermediate language representation.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ffnalias
.TP
.B
\-fno\-fnalias
.RS
.TP
Determines whether aliasing is assumed
within functions.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-ffnalias 
.NL
Aliasing is assumed within functions.
.TP
\fBDescription:\fR 
.PP
This option determines whether aliasing is assumed within
functions. 
.NL
.PP
If you specify 
\-fno\-fnalias, aliasing is
not assumed within functions, but it is assumed across calls. 
.NL
.PP
If you specify 
\-ffnalias, aliasing is
assumed within functions. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ffreestanding
.RS
.TP
Ensures that compilation takes place in a freestanding environment.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Standard libraries are used during compilation.
.TP
\fBDescription:\fR 
.PP
This option ensures that compilation takes place in a freestanding environment. The compiler assumes that the standard library may not exist and program startup may not necessarily be at main. This environment meets the definition of a freestanding environment as described in the C and C++ standard.
.NL
.PP
An example of an application requiring such an environment is an OS kernel.
.NL
.PP
.B NOTE:
When you specify this option, the compiler will not assume the presence of compiler\-specific libraries. It will only generate calls that appear in the source code.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ffriend\-injection
.TP
.B
\-fno\-friend\-injection
.RS
.TP
Causes the compiler to inject friend functions into the enclosing namespace.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-friend\-injection
.NL
The compiler does not inject friend functions
into the enclosing namespace. A friend function that is not declared in an
enclosing scope can only be found using argument\-dependent
lookup.
.TP
\fBDescription:\fR 
.PP
This option causes the compiler to inject
friend functions into the enclosing namespace, so they are visible
outside the scope of the class in which they are
declared.
.NL
.PP
On Linux systems,  in gcc versions 4.1 or later, this is not the
default behavior. This option allows compatibility with gcc 4.0 or
earlier.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ffunction\-sections
.RS
.TP
Places each function in its own COMDAT section.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Places each function in its own COMDAT section.
.NL
.TP
\fBAlternate Options:\fR 
.PP
\-fdata\-sections
.NL
.RE
.TP
.B
\-fgnu89\-inline
.RS
.TP
Tells the compiler to use C89 semantics for inline functions when in C99 mode.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use C89 semantics for inline functions when in C99 mode.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-absolute\-error=value[:funclist]
.RS
.TP
Defines the maximum allowable absolute error for math library function results.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIvalue\fR
.NL
Is a positive, floating\-point number. Errors in math library function results may exceed the maximum relative error (max\-error) setting if the absolute\-error is less than or equal to \fIvalue\fR.
.IP
The format for the number is [digits] [.digits] [ { e | E
}[sign]digits]
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-absolute\-error=0.00001:sin,sinf (or /Qimf\-absolute\-error:0.00001:sin,sinf) to specify the maximum allowable absolute error for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example you can specify  \-fimf\-absolute\-error=0.00001:/ or /Qimf\-absolute\-error: 0.00001:/.
.TP
\fBDefault:\fR 
.TP 18
Zero ("0")
.NL
An absolute\-error setting of 0 means that the function is bound by the relative error setting. This is the default behavior.
.TP
\fBDescription:\fR 
.PP
This option defines the maximum allowable absolute error for math library function results.
.NL
.PP
This option can improve run\-time performance, but it may decrease the accuracy of results.
.NL
.PP
This option only affects functions that have
zero as a possible return value, such as log, sin, asin,
etc.
.NL
.PP
The relative error requirements for a
particular function are determined by options that set the maximum relative error (max\-error)
and precision. The return value from a function must have a
relative error less than the max\-error value, or an absolute error
less than the absolute\-error value.
.NL
.PP
If you need to define the accuracy for a math function of a certain
precision, specify the function name of the precision that you
need. For example, if you want double precision, you can specify
:sin; if you want single precision, you can specify :sinf, as
in \-fimf\-absolute\-error=0.00001:sin or
/Qimf\-absolute\-error:0.00001:sin, or \-fimf\-absolute\-error=0.00001:sqrtf or
/Qimf\-absolute\-error:0.00001:sqrtf.
.NL
.PP
If you do not specify any function names, then
the setting applies to all functions (and to all precisions).
However, as soon as you specify an individual function name, the
setting applies only to the function of corresponding
precision. So, for example, sinf applies only to the single\-precision sine
function, sin applies only to the
double\-precision sine
function, sinl applies only to the
extended\-precision sine
function, etc.
.NL
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-accuracy\-bits=bits[:funclist]
.RS
.TP
Defines the relative error for math
library function results, including division and square root.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIbits\fR
.NL
Is a positive, floating\-point number indicating the
number of correct bits the compiler should use.
.IP
The format for the number is [digits] [.digits] [
{ e | E }[sign]digits].
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the
attribute should be applied. If you specify more than one function, they must
be separated with commas. Precision\-specific variants like sin and sinf are
considered different functions, so you would need to use 
\-fimf\-accuracy\-bits=23:sin,sinf (or 
/Qimf\-accuracy\-bits:23:sin,sinf) to specify the relative
error for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides,
symbol / to denote double\-precision divides, symbol /l to denote
extended\-precision divides, and symbol /q to denote quad\-precision divides. For
example you can specify 
\-fimf\-accuracy\-bits=10.0:/f or 
/Qimf\-accuracy\-bits:10.0:/f.
.TP
\fBDefault:\fR 
.TP 18
\-fimf\-precision=medium or
/Qimf\-precision:medium
.NL
The compiler uses medium precision when calling
math library functions. Note that other options can affect precision; see below
for details.
.TP
\fBDescription:\fR 
.PP
This option defines the relative error, measured by the number of correct
bits, for math library function results.
.NL
.PP
The following formula is used to convert
bits into ulps: ulps = 2p\-1\-bits, where p is the number of the
target format mantissa bits (24, 53, and 64 for single, double, and long
double, respectively).
.NL
.PP
This option can affect run\-time performance and the accuracy of results.
.NL
.PP
If you need to define the accuracy for a math function of a certain
precision, specify the function name of the precision that you need. For
example, if you want double precision, you can specify :sin; if you want single
precision, you can specify :sinf, as in the following: 
.NL
.IP \(bu 2
\-fimf\-accuracy\-bits=23:sinf,cosf,logf or 
/Qimf\-accuracy\-bits:23:sinf,cosf,logf
.IP \(bu 2
\-fimf\-accuracy\-bits=52:sqrt,/,trunc or 
/Qimf\-accuracy\-bits:52:sqrt,/,trunc
.IP \(bu 2
\-fimf\-accuracy\-bits=10:powf or 
/Qimf\-accuracy\-bits:10:powf
.PP
If you do not specify any function names, then the setting applies to all
functions (and to all precisions). However, as soon as you specify an
individual function name, the setting applies only to the function of
corresponding precision. So, for example, sinf applies only to the
single\-precision sine function, sin applies only to the double\-precision sine
function, sinl applies only to the extended\-precision sine function, etc. 
.NL
.PP
There are three options you can use to express the maximum relative error.
They are as follows:
.NL
.IP \(bu 2
\-fimf\-precision (Linux* and OS X*)
or 
/Qimf\-precision (Windows*)
.IP \(bu 2
\-fimf\-max\-error (Linux* and OS X*) or 
/Qimf\-max\-error (Windows*)
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux and OS X*)
or 
/Qimf\-accuracy\-bits (Windows)
.PP
If more than one of these options are specified, the default value for the
maximum relative error is determined by the last one specified on the command
line.
.NL
.PP
If none of the above options are specified, the default values for the
maximum relative error are determined by the setting of the following options:
.NL
.IP \(bu 2
[Q]fast\-transcendentals
.IP \(bu 2
[Q]prec\-div
.IP \(bu 2
[Q]prec\-sqrt 
.IP \(bu 2
\-fp\-model (Linux and OS X) or 
/fp (Windows)
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math
Library) are more highly optimized for Intel(R) microprocessors than for
non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-arch\-consistency=value[:funclist]
.RS
.TP
Ensures that the math library functions
produce consistent results across different microarchitectural implementations
of the same architecture.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIvalue\fR
.NL
Is one of the logical values "true" or "false".
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library
functions to which the attribute should be applied. If you specify more than
one function, they must be separated with commas. Precision\-specific variants
like sin and sinf are considered different functions, so you would need to use 
\-fimf\-arch\-consistency=true:sin,sinf (or 
/Qimf\-arch\-consistency:true:sin,sinf) to specify
consistent results for both the single\-precision and double\-precision sine
functions. 
.IP
You also can specify the symbol /f to denote
single\-precision divides, symbol / to denote double\-precision divides, symbol
/l to denote extended\-precision divides, and symbol /q to denote quad\-precision
divides. For example you can specify 
\-fimf\-arch\-consistency=true:/ or 
/Qimf\-arch\-consistency:true:/.
.TP
\fBDefault:\fR 
.TP 18
false
.NL
Implementations of some math library functions may
produce slightly different results on implementations of the same architecture.
.TP
\fBDescription:\fR 
.PP
This option ensures that the math library functions produce consistent
results across different microarchitectural implementations of the same
architecture (for example, across different microarchitectural implementations
of IA\-32 architecture). Consistency is only guaranteed for a single binary.
Consistency is not guaranteed across different architectures. For example,
consistency is not guaranteed across IA\-32 architecture and Intel(R) 64
architecture.
.NL
.PP
If you need to define the accuracy for a math function of a certain
precision, specify the function name of the precision that you need. For
example, if you want double precision, you can specify :sin; if you want single
precision, you can specify :sinf, as in 
\-fimf\-arch\-consistency=true:sin or
/Qimf\-arch\-consistency:true:sin, or 
\-fimf\-arch\-consistency=false:sqrtf or 
/Qimf\-arch\-consistency:false:sqrtf.
.NL
.PP
If you do not specify any function names, then the setting applies to all
functions (and to all precisions). However, as soon as you specify an
individual function name, the setting applies only to the function of
corresponding precision. So, for example, sinf applies only to the
single\-precision sine function, sin applies only to the double\-precision sine
function, sinl applies only to the extended\-precision sine function, etc. 
.NL
.PP
The 
\-fimf\-arch\-consistency (Linux* and OS X*) and 
/Qimf\-arch\-consistency (Windows*) option may decrease run\-time
performance, but the option will provide bit\-wise consistent results on all
Intel(R) processors and compatible, non\-Intel processors, regardless of
micro\-architecture. This option may not provide bit\-wise consistent results
between different architectures, for example, between IA\-32 and Intel(R) 64
architectures, or between Intel(R)
64 architecture and Intel(R) MIC Architecture.
.NL
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math
Library) are more highly optimized for Intel(R) microprocessors than for
non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-domain\-exclusion=classlist[:funclist]
.RS
.TP
Indicates the input arguments domain on which math functions must provide correct results. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIclasslist\fR
.NL
Is one of the following: 
.RS
.IP \(bu 2
One or more of the following floating\-point value classes you can exclude from the function domain without affecting the correctness of your program. The supported class names are:
.RS
extremes
This class is for values which do not lie within the usual domain of arguments for a given function.
nans
This means "x=Nan".
infinities
This means "x=infinities".
denormals
This means "x=denormal".
zeros
This means "x=0".
.RE
Each \fIclasslist\fR element corresponds to a power of two. The exclusion attribute is the logical or of the associated powers of two (that is, a bitmask). 
The following shows the current mapping from \fIclasslist\fR mnemonics to numerical values:
.TP 18
extremes
.NL
1
.NL
.TP 18
nans
.NL
2
.NL
.TP 18
infinities
.NL
4
.NL
.TP 18
denormals
.NL
8
.NL
.TP 18
zeros
.NL
16
.NL
.TP 18
none
.NL
0
.NL
.TP 18
all
.NL
31
.NL
.TP 18
common
.NL
15
.NL
.TP 18
other combinations
.NL
bitwise OR of the used values
.NL
You must specify the integer value that corresponds to the class that you want to exclude. 
Note that on excluded values, unexpected results may occur.
.IP \(bu 2
One of the following short\-hand tokens:
.RS
none
This means that none of the supported classes are excluded from the domain. To indicate this token, specify 0, as in \-fimf\-domain\-exclusion=0 (or /Qimf\-domain\-exclusion:0).
all
This means that all of the supported classes are excluded from the domain. To indicate this token, specify 31, as in \-fimf\-domain\-exclusion=31 (or /Qimf\-domain\-exclusion:31).
common
This is the same as specifying extremes,nans,infinities,denormals. To indicate this token, specify 15 (1 + 2+ 4 + 8), as in \-fimf\-domain\-exclusion=15 (or /Qimf\-domain\-exclusion:15)
.RE
.RE
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-domain\-exclusion=4:sin,sinf (or /Qimf\-domain\-exclusion:4:sin,sinf) to specify infinities for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example, you can specify:
.IP
\-fimf\-domain\-exclusion=4 or /Qimf\-domain\-exclusion:4
.IP
\-fimf\-domain\-exclusion=5:/,powf or /Qimf\-domain\-exclusion:5:/,powf
.IP
\-fimf\-domain\-exclusion=23:log,logf,/,sin,cosf or /Qimf\-domain\-exclusion:23:log,logf,/,sin,cosf
.IP
If you don’t specify argument \fIfunclist\fR, the domain restrictions apply to all math library functions.
.TP
\fBDefault:\fR 
.TP 18
Zero ("0")
.NL
The compiler uses default heuristics when calling math library functions.
.TP
\fBDescription:\fR 
.PP
This option indicates the input arguments domain on which math functions must provide correct results. It specifies that your program will function correctly if the functions specified in \fIfunclist\fR do not produce standard conforming results on the number classes.
.NL
.PP
This option can affect run\-time performance and the accuracy of results.  As more classes are excluded, faster code sequences can be used.
.NL
.PP
If you need to define the accuracy for a math function of a certain precision, specify the function name of the precision that you need. For example, if you want double precision, you can specify :sin; if you want single precision, you can specify :sinf, as in \-fimf\-domain\-exclusion=denormals:sin  or /Qimf\-domain\-exclusion:denormals:sin, or \-fimf\-domain\-exclusion=extremes:sqrtf or /Qimf domain\-exclusion:extremes:sqrtf.
.NL
.PP
If you do not specify any function names, then the setting applies to all functions (and to all precisions). However, as soon as you specify an individual function name, the setting applies only to the function of corresponding precision. So, for example, sinf applies only to the single\-precision sine function, sin applies only to the double\-precision sine function, sinl applies only to the extended\-precision sine function, etc.  
.NL
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-max\-error=ulps[:funclist]
.RS
.TP
Defines the maximum allowable relative
error for math library function results, including division and square root.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIulps\fR
.NL
Is a positive, floating\-point number indicating the
maximum allowable relative error the compiler should use. 
.IP
The format for the number is [digits] [.digits] [ {
e | E }[sign]digits].
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the
attribute should be applied. If you specify more than one function, they must
be separated with commas. Precision\-specific variants like sin and sinf are
considered different functions, so you would need to use 
\-fimf\-max\-error=4.0:sin,sinf (or 
/Qimf\-max\-error=4.0:sin,sinf) to specify the maximum
allowable relative error for both the single\-precision and double\-precision
sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides,
symbol / to denote double\-precision divides, symbol /l to denote
extended\-precision divides, and symbol /q to denote quad\-precision divides. For
example you can specify 
\-fimf\-max\-error=4.0:/ or 
/Qimf\-max\-error:4.0:/.
.TP
\fBDefault:\fR 
.TP 18
\-fimf\-precision=medium or
/Qimf\-precision:medium
.NL
The compiler uses medium precision when calling
math library functions. Note that other options can affect precision; see below
for details.
.TP
\fBDescription:\fR 
.PP
This option defines the maximum allowable relative error, measured in ulps,
for math library function results. 
.NL
.PP
This option can affect run\-time performance and the accuracy of results.
.NL
.PP
If you need to define the accuracy for a math function of a certain
precision, specify the function name of the precision that you need. For
example, if you want double precision, you can specify :sin; if you want single
precision, you can specify :sinf, as in 
\-fimf\-max\-error=4.0:sin or 
/Qimf\-max\-error:4.0:sin, or 
\-fimf\-max\-error=4.0:sqrtf or 
/Qimf\-max\-error:4.0:sqrtf.
.NL
.PP
If you do not specify any function names, then the setting applies to all
functions (and to all precisions). However, as soon as you specify an
individual function name, the setting applies only to the function of
corresponding precision. So, for example, sinf applies only to the
single\-precision sine function, sin applies only to the double\-precision sine
function, sinl applies only to the extended\-precision sine function, etc. 
.NL
.PP
There are three options you can use to express the maximum relative error.
They are as follows:
.NL
.IP \(bu 2
\-fimf\-precision (Linux* and OS X*)
or 
/Qimf\-precision (Windows*)
.IP \(bu 2
\-fimf\-max\-error (Linux* and OS X*) or 
/Qimf\-max\-error (Windows*)
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux and OS X*)
or 
/Qimf\-accuracy\-bits (Windows)
.PP
If more than one of these options are specified, the default value for the
maximum relative error is determined by the last one specified on the command
line.
.NL
.PP
If none of the above options are specified, the default values for the
maximum relative error are determined by the setting of the following options:
.NL
.IP \(bu 2
[Q]fast\-transcendentals
.IP \(bu 2
[Q]prec\-div
.IP \(bu 2
[Q]prec\-sqrt 
.IP \(bu 2
\-fp\-model (Linux and OS X) or 
/fp (Windows)
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math
Library) are more highly optimized for Intel(R) microprocessors than for
non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-precision[=value[:funclist]]
.RS
.TP
Lets you specify a level of accuracy
(precision) that the compiler should use when determining which math library
functions to use. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIvalue\fR
.NL
Is one of the following values denoting the desired
accuracy: 
.RS
.TP 15
high
This is equivalent to
max\-error = 1.0. 
.TP 15
medium
This is equivalent to max\-error = 4; this is
the default setting if the option is specified and 
\fIvalue\fR is omitted. 
.TP 15
low
This is equivalent to accuracy\-bits = 11 for
single\-precision functions; accuracy\-bits = 26 for double\-precision functions. 
.RE
.IP
In the above explanations, max\-error means option 
\-fimf\-max\-error (Linux* and OS X*) or 
/Qimf\-max\-error (Windows*); accuracy\-bits means option 
\-fimf\-accuracy\-bits (Linux* and OS X*) or 
/Qimf\-accuracy\-bits (Windows*). 
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the
attribute should be applied. If you specify more than one function, they must
be separated with commas. Precision\-specific variants like sin and sinf are
considered different functions, so you would need to use 
\-fimf\-precision=high:sin,sinf (or 
/Qimf\-precision:high:sin,sinf) to specify high precision
for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides,
symbol / to denote double\-precision divides, symbol /l to denote
extended\-precision divides, and symbol /q to denote quad\-precision divides. For
example you can specify 
\-fimf\-precision=low:/ or 
/Qimf\-precision:low:/ and 
\-fimf\-precision=low:/f or 
/Qimf\-precision:low:/f. 
.TP
\fBDefault:\fR 
.TP 18
medium
.NL
The compiler uses medium precision when calling
math library functions. Note that other options can affect precision; see below
for details. 
.TP
\fBDescription:\fR 
.PP
This option lets you specify a level of accuracy (precision) that the
compiler should use when determining which math library functions to use. 
.NL
.PP
This option can be used to improve run\-time performance if reduced accuracy
is sufficient for the application, or it can be used to increase the accuracy
of math library functions selected by the compiler. 
.NL
.PP
In general, using a lower precision can improve run\-time performance and
using a higher precision may reduce run\-time performance. 
.NL
.PP
If you need to define the accuracy for a math function of a certain
precision, specify the function name of the precision that you need. For
example, if you want double precision, you can specify :sin; if you want single
precision, you can specify :sinf, as in 
\-fimf\-precision=low:sin or
/Qimf\-precision:low:sin, or 
\-fimf\-precision=high:sqrtf or 
/Qimf\-precision:high:sqrtf. 
.NL
.PP
If you do not specify any function names, then the setting applies to all
functions (and to all precisions). However, as soon as you specify an
individual function name, the setting applies only to the function of
corresponding precision. So, for example, sinf applies only to the
single\-precision sine function, sin applies only to the double\-precision sine
function, sinl applies only to the extended\-precision sine function, etc. 
.NL
.PP
There are three options you can use to express the maximum relative error.
They are as follows: 
.NL
.IP \(bu 2
\-fimf\-precision (Linux* and OS X*)
or 
/Qimf\-precision (Windows*) 
.IP \(bu 2
\-fimf\-max\-error (Linux* and OS X*) or 
/Qimf\-max\-error (Windows*) 
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux and OS X*)
or 
/Qimf\-accuracy\-bits (Windows) 
.PP
If more than one of these options are specified, the default value for the
maximum relative error is determined by the last one specified on the command
line. 
.NL
.PP
If none of the above options are specified, the default values for the
maximum relative error are determined by the setting of the following options: 
.NL
.IP \(bu 2
[Q]fast\-transcendentals
.IP \(bu 2
[Q]prec\-div
.IP \(bu 2
[Q]prec\-sqrt 
.IP \(bu 2
\-fp\-model (Linux and OS X) or 
/fp (Windows) 
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML
(Short Vector Math Library) are more highly optimized for Intel(R)
microprocessors than for non\-Intel microprocessors. 
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-finline
.TP
.B
\-fno\-inline
.RS
.TP
Tells the compiler to inline functions declared with __inline and perform C++ inlining.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-inline
.NL
The compiler does not inline functions declared with __inline.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to inline functions declared with __inline and perform C++ inlining.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-inline\-level
.NL
.RE
.TP
.B
\-finline\-functions
.TP
.B
\-fno\-inline\-functions
.RS
.TP
Enables function inlining for single file compilation.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-finline\-functions
.NL
Interprocedural optimizations occur. However, if you specify \-O0, the default is OFF.
.TP
\fBDescription:\fR 
.PP
This option enables function inlining for single file compilation. 
.NL
.PP
It enables the compiler to perform inline function expansion for calls to functions defined within the current source file.
.NL
.PP
The compiler applies a heuristic to perform the function expansion. To specify the size of the function to be expanded, use the \-finline\-limit option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-inline\-level=2
.NL
.RE
.TP
.B
\-finline\-limit=n
.RS
.TP
Lets you specify the maximum size of a function to be inlined.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Must be an integer greater than or equal to zero. It is the maximum number of lines the function can have to be considered for inlining.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics when inlining functions.
.TP
\fBDescription:\fR 
.PP
This option lets you specify the maximum size of a function to be inlined. The compiler inlines smaller functions, but this option lets you inline large functions. For example, to indicate a large function, you could specify 100 or 1000 for \fIn\fR.
.NL
.PP
Note that parts of functions cannot be inlined, only whole functions.
.NL
.PP
This option is a modification of the \-finline\-functions option, whose behavior occurs by default.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-finstrument\-functions
.TP
.B
\-fno\-instrument\-functions
.RS
.TP
Determines whether 
function entry and exit
points are instrumented.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-instrument\-functions 
.NL
Function entry and exit points are not
instrumented.
.TP
\fBDescription:\fR 
.PP
This option determines whether 
function entry and exit
points are instrumented. It may increase execution time.
.NL
.PP
The following profiling functions are called with the
address of the current 
function and the address
of where the 
function was called (its
"call site"):
.NL
.IP \(bu 2
This function is called upon 
function entry:
.RS
.IP \(bu 2
.IP
void __cyg_profile_func_enter (void *this_fn,
.IP
void *call_site);
.RE
.IP \(bu 2
This function is called upon 
function exit:
.RS
.IP \(bu 2
.IP
void __cyg_profile_func_exit (void *this_fn,
.IP
void *call_site);
.RE
.PP
These functions can be used to gather more information,
such as profiling information or timing information. Note that it is the user\[aq]s
responsibility to provide these profiling functions.
.NL
.PP
If you specify 
\-finstrument\-functions
(Linux* and OS X*) or 
/Qinstrument\-functions
(Windows*), 
function inlining is
disabled. If you specify 
\-fno\-instrument\-functions
or 
/Qinstrument\-functions\-,
inlining is not disabled.
.NL
.PP
On Linux and OS X
systems, you can use the following attribute to stop an individual function
from being instrumented:
.NL
.PP
__attribute__((__no_instrument_function__))
.PP
.PP
It also stops inlining
from being disabled for that individual function.
.NL
.PP
This option is provided for compatibility with gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fjump\-tables
.TP
.B
\-fno\-jump\-tables
.RS
.TP
Determines whether jump tables are generated for switch statements. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fjump\-tables
.NL
The compiler may use jump tables for switch statements.
.TP
\fBDescription:\fR 
.PP
This option determines whether jump tables are generated for switch statements.
.NL
.PP
Option \-fno\-jump\-tables prevents the compiler from generating jump tables for switch statements. This action is performed unconditionally and independent of any generated code performance consideration.
.NL
.PP
Option \-fno\-jump\-tables also prevents the compiler from creating switch statements internally as a result of optimizations.
.NL
.PP
Use \-fno\-jump\-tables with \-fpic when compiling objects that will be loaded in a way where the jump table relocation cannot be resolved.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fkeep\-static\-consts
.TP
.B
\-fno\-keep\-static\-consts
.RS
.TP
Tells the compiler to preserve allocation
of variables that are not referenced in the source.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-keep\-static\-consts
.NL
If a variable is never referenced in a routine, the
variable is discarded unless optimizations are disabled by option 
\-O0 (Linux* and OS
X*).
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to preserve allocation of
variables that are not referenced in the source.
.NL
.PP
The negated form can be useful when optimizations are
enabled to reduce the memory usage of static data.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fma
.TP
.B
\-no\-fma
.RS
.TP
Determines whether the compiler
generates fused multiply\-add (FMA) instructions if such instructions exist on
the target processor. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fma 
.NL
If the instructions exist on the target processor,
the compiler generates fused multiply\-add (FMA) instructions. 
.IP
However, if you specify 
\-fp\-model strict
(Linux* and OS X*), but do not explicitly specify 
\-fma, the
default is 
\-no\-fma. 
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler generates fused multiply\-add
(FMA) instructions if such instructions exist on the target processor. When the
[Q]fma option is specified, the compiler may generate FMA
instructions for combining multiply and add operations. When the negative form
of the 
[Q]fma option is specified, the compiler must generate
separate multiply and add instructions with intermediate rounding. 
.NL
.PP
This option has no effect unless setting CORE\-AVX2 or higher is specified
for option 
[Q]x, 
\-march (Linux and OS X), or 
/arch (Windows). 
.NL
.RE
.TP
.B
\-fmath\-errno
.TP
.B
\-fno\-math\-errno
.RS
.TP
Tells the compiler that errno can be reliably tested after calls to standard math library functions.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-math\-errno
.NL
The compiler assumes that the program does not test errno after calls to standard math library functions.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to assume that the program tests errno after calls to math library functions. This restricts optimization because it causes the compiler to treat most math functions as having side effects.
.NL
.PP
Option \-fno\-math\-errno tells the compiler to assume that the program does not test errno after calls to math library functions. This frequently allows the compiler to generate faster code. Floating\-point code that relies on IEEE exceptions instead of errno to detect errors can safely use this option to improve performance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fmerge\-constants (L*X only)
.TP
.B
\-fno\-merge\-constants (L*X only)
.RS
.TP
Determines whether the compiler and linker attempt to merge identical constants (string constants and floating\-point constants) across compilation units.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fmerge\-constants
.NL
The compiler and linker attempt to merge identical constants across compilation units if the compiler and linker supports it.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler and linker
attempt to merge identical constants (string constants and
floating\-point constants) across compilation units.
.NL
.PP
If you do not want the compiler and linker to
attempt to merge identical constants across compilation units.
specify \-fno\-merge\-constants.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fmerge\-debug\-strings (L*X only)
.TP
.B
\-fno\-merge\-debug\-strings (L*X only)
.RS
.TP
Causes the compiler to pool strings used in debugging information.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fmerge\-debug\-strings
.NL
The compiler will pool strings used in debugging information.
.TP
\fBDescription:\fR 
.PP
This option causes the compiler to pool strings
used in debugging information. The linker will automatically retain
this pooling.
.NL
.PP
This option can reduce the size of debug
information, but it may produce slightly slower compile and link
times.
.NL
.PP
This option is only turned on by default if you
are using gcc 4.3 or later, where this setting is also the default,
since the generated debug tables require binutils version 2.17 or
later to work reliably.
.NL
.PP
If you do not want the compiler to pool strings
used in debugging information, specify option
\-fno\-merge\-debug\-strings.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fminshared
.RS
.TP
Specifies that a compilation unit is a
component of a main program and should not be linked as part of a shareable
object.
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Source files are compiled together to form a single
object file.
.TP
\fBDescription:\fR 
.PP
This option specifies that a compilation unit is a
component of a main program and should not be linked as part of a shareable
object.
.NL
.PP
This option allows the compiler to optimize references to
defined symbols without special visibility settings. To ensure that external
and common symbol references are optimized, you need to specify visibility
hidden or protected by using the 
\-fvisibility, 
\-fvisibility\-hidden, or 
\-fvisibility\-protected
option.
.NL
.PP
Also, the compiler does not need to generate
position\-independent code for the main program. It can use absolute addressing,
which may reduce the size of the global offset table (GOT) and may reduce
memory traffic.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fmpc\-privatize (L*X only)
.TP
.B
\-fno\-mpc\-privatize (L*X only)
.RS
.TP
Enables or disables privatization of all
static data for the MultiProcessor Computing environment (MPC) unified parallel
runtime.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-mpc\-privatize
.NL
The privatization of all static data for the MPC
unified parallel runtime is disabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables privatization of all static data for the
MultiProcessor Computing environment (MPC) unified parallel runtime. 
.NL
.PP
Option 
\-fmpc\-privatize causes calls to extended thread\-local\-storage
(TLS) resolution, run\-time routines that are not supported on standard Linux*
distributions. 
.NL
.PP
This option requires installation of another product.
For more information, see 
Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fms\-dialect[=ver] (L*X only)
.RS
.TP
Enables support for a language dialect
that is compatible with Microsoft* Windows, while maintaining link
compatibility with gcc. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIver\fR
.NL
Indicates that the language dialect should be
compatible with a certain version of Microsoft* Visual Studio. Possible values
are: 
.RS
.TP 15
14
Specifies the dialect should be compatible
with Microsoft* Visual Studio 2015. 
.TP 15
12
Specifies the dialect should be compatible
with Microsoft* Visual Studio 2013. 
.TP 15
11
Specifies the dialect should be compatible
with Microsoft* Visual Studio 2012. This is the default if you do not specify 
\fIver\fR. 
.TP 15
10
Specifies the dialect should
be compatible with Microsoft* Visual Studio 2010. This is a deprecated option. 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not support a language dialect
that is compatible with Microsoft* Windows. 
.TP
\fBDescription:\fR 
.PP
This option enables support for a language dialect that
is compatible with Microsoft* Windows, while maintaining link compatibility
with gcc. It allows portability of code written on Windows* that uses Microsoft
extensions or language features. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None 
.NL
.RE
.TP
.B
\-fmudflap (L*X only)
.RS
.TP
The compiler instruments risky pointer
operations to prevent buffer overflows and invalid heap use. This is a
deprecated option. There is no replacement option. You can consider using the
Pointer Checker options (such as option \-check\-pointers).
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not instrument risky pointer
operations.
.TP
\fBDescription:\fR 
.PP
The compiler instruments risky pointer operations to
prevent buffer overflows and invalid heap use. It requires gcc 4.0 or newer.
.NL
.PP
When using this compiler option, you must specify linker
option 
\-lmudflap in the link
command line to resolve references to the 
libmudflap library.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fno\-gnu\-keywords
.RS
.TP
Tells the compiler to not recognize typeof as a keyword.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Keyword typeof
is recognized.
.TP
\fBDescription:\fR 
.PP
Tells the compiler to not recognize typeof as a  keyword.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fno\-implicit\-inline\-templates
.RS
.TP
Tells the compiler to not emit code for implicit instantiations of inline templates.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler handles inlines so that compilations, with and without optimization, will need the same set of explicit instantiations.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to not emit code for implicit instantiations of inline templates.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fno\-implicit\-templates
.RS
.TP
Tells the compiler to not emit code for non\-inline templates that are instantiated implicitly. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler handles inlines so that compilations, with and without optimization, will need the same set of explicit instantiations.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to not emit code for non\-inline templates that are instantiated implicitly, but to only emit code for explicit instantiations.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fnon\-call\-exceptions
.TP
.B
\-fno\-non\-call\-exceptions
.RS
.TP
Allows trapping instructions to throw C++ exceptions.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-non\-call\-exceptions
.NL
C++ exceptions are not thrown from trapping instructions.
.TP
\fBDescription:\fR 
.PP
This option allows trapping instructions to throw C++ exceptions. It allows hardware signals generated by trapping instructions to be converted into C++ exceptions and caught using the standard C++ exception handling mechanism. Examples of such signals are SIGFPE (floating\-point exception) and SIGSEGV (segmentation violation). 
.NL
.PP
You must write a signal handler that catches the signal and throws a C++ exception. After that, any occurrence of that signal within a C++ try block can be caught by a C++ catch handler of the same type as the C++ exception thrown within the signal handler.
.NL
.PP
Only signals generated by trapping instructions (that is, memory access instructions and floating\-point instructions) can be caught. Signals that can occur at any time, such as SIGALRM, cannot be caught in this manner.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fnon\-lvalue\-assign
.TP
.B
\-fno\-non\-lvalue\-assign
.RS
.TP
Determines whether casts and conditional expressions can be used as lvalues.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fnon\-lvalue\-assign
.NL
The compiler allows casts and conditional expressions to be used as lvalues.
.TP
\fBDescription:\fR 
.PP
This option determines whether casts and conditional expressions can be used as lvalues.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fno\-operator\-names
.RS
.TP
Disables support for the operator names specified in the standard.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Disables support for the operator names specified in the standard.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fno\-rtti
.RS
.TP
Disables support for run\-time type
information (RTTI). 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Support for run\-time type information (RTTI) is
enabled.
.TP
\fBDescription:\fR 
.PP
This option disables support for run\-time type
information (RTTI).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fomit\-frame\-pointer
.TP
.B
\-fno\-omit\-frame\-pointer
.RS
.TP
Determines whether EBP is used as a
general\-purpose register in optimizations. 
.NL
.TP
\fBArchitecture Restrictions:\fR Option 
/Oy[\-] is only available
on IA\-32 architecture 
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fomit\-frame\-pointer 
.NL
EBP is used as a general\-purpose register in
optimizations. However, on Linux* and OS X* systems, the default is 
\-fno\-omit\-frame\-pointer if option
\-O0 or 
\-g is specified. 
.TP
\fBDescription:\fR 
.PP
These options determine whether EBP is used as a
general\-purpose register in optimizations. Options 
\-fomit\-frame\-pointer and 
/Oy allow this use.
Options 
\-fno\-omit\-frame\-pointer
and 
/Oy\- disallow it. 
.NL
.PP
Some debuggers expect EBP to be used as a stack frame
pointer, and cannot produce a stack backtrace unless this is so. The 
\-fno\-omit\-frame\-pointer
and 
/Oy\- options direct the
compiler to generate code that maintains and uses EBP as a stack frame pointer
for all functions so that a debugger can still produce a stack backtrace
without doing the following: 
.NL
.IP \(bu 2
For 
\-fno\-omit\-frame\-pointer:
turning off optimizations with 
\-O0
.IP \(bu 2
For 
/Oy\-: turning off 
/O1, 
/O2, or 
/O3 optimizations 
.PP
The 
\-fno\-omit\-frame\-pointer
option is set when you specify option 
\-O0 or the 
\-g option. The 
\-fomit\-frame\-pointer
option is set when you specify option 
\-O1, 
\-O2, or 
\-O3. 
.NL
.PP
The 
/Oy option is set when
you specify the 
/O1, 
/O2, or 
/O3 option. Option 
/Oy\- is set when you
specify the 
/Od option. 
.NL
.PP
Using the 
\-fno\-omit\-frame\-pointer
or 
/Oy\- option reduces the
number of available general\-purpose registers by 1, and can result in slightly
less efficient code. 
.NL
.PP
.B NOTE:
For Linux* systems: 
.PP
There is currently an issue with GCC 3.2 exception
handling. Therefore, the Intel compiler ignores this option when GCC 3.2 is
installed for C++ and exception handling is turned on (the default). 
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: 
\-fp (this is a deprecated
option) 
.NL
.RE
.TP
.B
\-foptimize\-sibling\-calls
.TP
.B
\-fno\-optimize\-sibling\-calls
.RS
.TP
Determines whether the compiler optimizes tail recursive calls.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-foptimize\-sibling\-calls
.NL
The compiler optimizes tail recursive calls.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler
optimizes tail recursive calls. It enables conversion of tail recursion into
loops.
.NL
.PP
If you do not want to optimize tail recursive
calls, specify \-fno\-optimize\-sibling\-calls.
.NL
.PP
Tail recursion is a special form of recursion
that doesn\[aq]t use stack space. In tail recursion, a recursive call
is converted to a GOTO statement that returns to the beginning of
the function. In this case, the return value of the recursive call
is only used to be returned. It is not used in another expression.
The recursive function is converted into a loop, which prevents
modification of the stack space used.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fp\-model keyword
.RS
.TP
Controls the semantics of floating\-point
calculations. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies the semantics to be used. Possible values
are: 
.RS
.TP 15
precise
Disables optimizations that are not value\-safe
on floating\-point data.
.TP 15
fast[=1|2]
Enables more aggressive optimizations on
floating\-point data. 
.TP 15
consistent
Enables consistent,
reproducible results for different optimization levels or between different
processors of the same architecture. 
.TP 15
strict
Enables precise and except, disables
contractions, and 
enables
pragma 
stdc
fenv_access.
.TP 15
source
Rounds intermediate results to source\-defined
precision. 
.TP 15
double
Rounds intermediate results to 53\-bit
(double) precision. 
.TP 15
extended
Rounds intermediate results to 64\-bit
(extended) precision. 
.TP 15
[no\-]except
(Linux* and OS X*) or except[\-] (Windows* )
Determines whether strict floating\-point
exception semantics are honored. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fp\-model fast=1 
.NL
The compiler uses more aggressive optimizations on
floating\-point calculations. 
.TP
\fBDescription:\fR 
.PP
This option controls the semantics of floating\-point
calculations. 
.NL
.PP
The 
\fIkeywords\fR can be
considered in groups: 
.NL
.IP \(bu 2
Group A: 
precise, 
fast, 
consistent, 
strict
.IP \(bu 2
Group B: 
source, 
double, 
extended
.IP \(bu 2
Group C: 
except (or the negative form)
.PP
You can use more than one 
\fIkeyword\fR. However,
the following rules apply: 
.NL
.IP \(bu 2
You cannot specify 
fast and 
except together in the same
compilation. You can specify any other combination of group A, group B, and
group C. Since 
fast is the default, you must
not specify 
except without a group A or
group B 
\fIkeyword\fR. 
.IP \(bu 2
You should specify only one 
\fIkeyword\fR from
group A and only one 
\fIkeyword\fR from group B. If you try to specify more than
one 
\fIkeyword\fR from
either group A or group B, the last (rightmost) one takes effect. 
.IP \(bu 2
If you specify 
except more than once, the
last (rightmost) one takes effect. 
.PP
The floating\-point (FP) environment is a collection of
registers that control the behavior of FP machine instructions and indicate the
current FP status. The floating\-point environment may include rounding\-mode
controls, exception masks, flush\-to\-zero controls, exception status flags, and
other floating\-point related features.
.NL
.TP 18
\fBOption 
\fR
.NL
.NL
\fBDescription 
\fR
.NL
.NL
.TP 18
\-fp\-model precise or 
/fp:precise
.NL
Tells the compiler to strictly adhere to
value\-safe optimizations when implementing floating\-point calculations. It
disables optimizations that can change the result of floating\-point
calculations, which is
required for strict ANSI conformance. 
.TP 18
These semantics ensure the reproducibility of
floating\-point computations for serial code, including code vectorized or
auto\-parallelized by the compiler, but they may slow performance. They do not
ensure value safety or run\-to\-run reproducibility of other parallel code.
Run\-to\-run reproducibility for floating\-point reductions in OpenMP* code may be
obtained for a fixed number of threads through the KMP_DETERMINISTIC_REDUCTION
environment variable. For more information about this environment variable, see
topic "Supported Environment Variables". 
.TP 18
The compiler assumes the default floating\-point
environment; you are not allowed to modify it. 
.TP 18
Intermediate
results are computed with the precision shown in the following table, unless it
is overridden by a keyword from Group B: 
.TP 18
IA\-32 architecture: Windows:
Double; Linux: Extended; OS X: Extended 
.TP 18
Intel(R) 64 architecture: All
operating systems: Source 
.TP 18
Floating\-point exception semantics are disabled
by default. To enable these semantics, you must also specify 
\-fp\-model
except or 
/fp:except. 
.NL
.TP 18
\-fp\-model fast[=1|2] or 
/fp:fast[=1|2]
.NL
Tells the compiler to use more aggressive
optimizations when implementing floating\-point calculations. These
optimizations increase speed, 
but may affect the accuracy or reproducibility of
floating\-point computations.
.TP 18
Specifying fast is the same as specifying 
fast=1. 
fast=2 may produce
faster and less accurate results. 
.TP 18
Floating\-point exception semantics are disabled
by default and they cannot be enabled because you cannot specify fast and
except together in the same compilation. To enable exception semantics, you
must explicitly specify another keyword (see other keyword descriptions for
details). 
.TP 18
To enable exception semantics,
you must explicitly specify another keyword (see other keyword descriptions for
details). 
.NL
.TP 18
\-fp\-model consistent or 
/fp:consistent
.NL
Tells the compiler to generate code that will give consistent,
reproducible floating\-point results for different optimization levels or
between different processors of the same architecture . 
.TP 18
For more information, see the article titled: Consistency
of Floating\-Point Results using the Intel(R) Compiler, which is located in
http://software.intel.com/en\-us/articles/consistency\-of\-floating\-point\-results\-using\-the\-intel\-compiler/
.NL
.TP 18
\-fp\-model strict or 
/fp:strict
.NL
Tells the compiler to strictly adhere to
value\-safe optimizations when implementing floating\-point calculations and
enables floating\-point exception semantics. This is the strictest
floating\-point model. 
.TP 18
The compiler does not assume the default
floating\-point environment; you are allowed to modify it. 
.TP 18
Floating\-point exception semantics can be
disabled by explicitly specifying 
\-fp\-model
no\-except or 
/fp:except\-. 
.NL
.TP 18
\-fp\-model source or 
/fp:source
.NL
This option causes intermediate results to be
rounded to the precision defined in the source code. It also implies keyword 
precise unless it is
overridden by a keyword from Group A. 
.TP 18
Intermediate
expressions use the precision of the operand with higher precision, if any. 
.TP 18
long double: 64\-bit
precision; 80\-bit data type; 15\-bit exponent 
.TP 18
double: 53\-bit
precision; 64\-bit data type; 11\-bit exponent; on Windows systems using IA\-32
architecture, the exponent may be 15\-bit if an x87 register is used to hold the
value. 
.TP 18
float: 24\-bit
precision; 32\-bit data type; 8\-bit exponent 
.TP 18
The compiler assumes the default floating\-point
environment; you are not allowed to modify it. 
.NL
.TP 18
\-fp\-model double or 
/fp:double
.NL
This option causes intermediate results to be
rounded as follows: 
.TP 18
53\-bit (double)
precision 
.TP 18
64\-bit data type 
.TP 18
11\-bit exponent; on
Windows systems using IA\-32 architecture, the exponent may be 15\-bit if an x87
register is used to hold the value. 
.TP 18
This option also implies keyword 
precise unless it is
overridden by a keyword from Group A. 
.TP 18
The compiler assumes the default floating\-point
environment; you are not allowed to modify it. 
.NL
.TP 18
\-fp\-model extended or 
/fp:extended
.NL
This option causes intermediate results to be
rounded as follows: 
.TP 18
64\-bit (extended)
precision 
.TP 18
80\-bit data type 
.TP 18
15\-bit exponent 
.TP 18
This option also implies keyword 
precise unless it is
overridden by a keyword from Group A. 
.TP 18
The compiler assumes the default floating\-point
environment; you are not allowed to modify it. 
.NL
.TP 18
\-fp\-model except or 
/fp:except
.NL
Tells the compiler to follow strict
floating\-point exception semantics. 
.NL
.PP
The 
\-fp\-model and 
/fp options determine the setting for the maximum allowable
relative error for math library function results (max\-error) if none of the
following options are specified: 
.NL
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux* and OS X*) or 
/Qimf\-accuracy\-bits (Windows*) 
.IP \(bu 2
\-fimf\-max\-error (Linux and OS X) or 
/Qimf\-max\-error (Windows) 
.IP \(bu 2
\-fimf\-precision (Linux and OS X) or 
/Qimf\-precision (Windows) 
.IP \(bu 2
[Q]fast\-transcendentals
.PP
Option 
\-fp\-model fast (and 
/fp:fast) sets option 
\-fimf\-precision=medium
(/Qimf\-precision:medium) and option 
\-fp\-model precise (and 
/fp:precise) implies 
\-fimf\-precision=high (and 
/Qimf\-precision:high). Option 
\-fp\-model fast=2 (and 
/fp:fast2) sets option 
\-fimf\-precision=medium (and 
/Qimf\-precision:medium) and option 
\-fimf\-domain\-exclusion=15 (and 
/Qimf\-domain\-exclusion=15). 
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-fp\-port
.TP
.B
\-no\-fp\-port
.RS
.TP
Rounds floating\-point results after
floating\-point operations. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-fp\-port 
.NL
The default rounding behavior depends on the
compiler\[aq]s code generation decisions and the precision parameters of the
operating system.
.TP
\fBDescription:\fR 
.PP
This option rounds floating\-point results after floating\-point operations.
.NL
.PP
This option is designed to be used with the 
\-mia32 (Linux* and OS X*) or 
/arch:IA32 (Windows*) option on a 32\-bit compiler. Under those
conditions, the compiler implements floating\-point calculations using the x87
instruction set, which uses an internal precision that may be higher than the
precision specified in the program.
.NL
.PP
By default, the compiler may keep results of
floating\-point operations in this higher internal precision. Rounding to
program precision occurs at unspecified points. This provides better
performance, but the floating\-point results are less deterministic. The 
[Q]fp\-port option rounds floating\-point results to
user\-specified precision at assignments and type conversions. This has some
impact on speed.
.NL
.PP
When compiling for newer architectures, the compiler
implements floating\-point calculations with different instructions, such as
Intel(R) SSE and SSE2. These Intel(R) Streaming SIMD Extensions round directly to
single precision or double precision at every instruction. In these cases,
option 
[Q]fp\-port has no effect.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fp\-speculation=mode
.RS
.TP
Tells the compiler the mode in which to
speculate on floating\-point operations. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fImode\fR
.NL
Is the mode for floating\-point operations. Possible
values are: 
.RS
.TP 15
fast
Tells the compiler to speculate on
floating\-point operations. 
.TP 15
safe
Tells the compiler to disable speculation if
there is a possibility that the speculation may cause a floating\-point
exception. 
.TP 15
strict
Tells the compiler to disable speculation on
floating\-point operations. 
.TP 15
off
This is the same as specifying strict. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fp\-speculation=fast 
.NL
The compiler speculates on floating\-point
operations. This is also the behavior when optimizations are enabled. However,
if you specify no optimizations (\-O0 on Linux*), the default is 
\-fp\-speculation=safe (Linux*). 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler the mode in which to
speculate on floating\-point operations. 
.NL
.PP
Disabling speculation may
prevent the vectorization of some loops containing conditionals. For an
example, see the article titled: 
Diagnostic 15326: loop was not vectorized: implied FP exception model
prevents vectorization, which is located in
https://software.intel.com/en\-us/articles/fdiag15326 . 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-fp\-stack\-check
.RS
.TP
Tells the compiler to generate extra code
after every function call to ensure that the floating\-point stack is in the
expected state.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
There is no checking to ensure that the
floating\-point (FP) stack is in the expected state.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate extra code
after every function call to ensure that the floating\-point (FP) stack is in
the expected state.
.NL
.PP
By default, there is no checking. So when the FP stack
overflows, a NaN value is put into FP calculations and the program\[aq]s results
differ. Unfortunately, the overflow point can be far away from the point of the
actual bug. This option places code that causes an access violation exception
immediately after an incorrect call occurs, thus making it easier to locate
these issues. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fp\-trap=mode[,mode,...]
.RS
.TP
Sets the floating\-point trapping mode for
the main routine.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.TP 18
\fImode\fR
.NL
Is the floating\-point trapping mode. If you specify
more than one mode value, the list is processed sequentially from left to
right. Possible values are:
.RS
.TP 15
[no]divzero
Enables or disables the IEEE trap for
division by zero.
.TP 15
[no]inexact 
Enables or disables the IEEE trap for inexact
result.
.TP 15
[no]invalid 
Enables or disables the IEEE trap for invalid
operation.
.TP 15
[no]overflow 
Enables or disables the IEEE trap for
overflow.
.TP 15
[no]underflow 
Enables or disables the IEEE trap for
underflow.
.TP 15
[no]denormal 
Enables or disables the trap for denormal.
.TP 15
all
Enables all of the above traps.
.TP 15
none
Disables all of the above traps.
.TP 15
common
Sets the most commonly used IEEE traps: division by zero,
invalid operation, and overflow. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fp\-trap=none 
.NL
No traps are enabled when a program starts.
.TP
\fBDescription:\fR 
.PP
This option sets the floating\-point trapping mode for the main routine. It
does not set a handler for floating\-point exceptions.
.NL
.PP
The 
[no] form of a 
mode value is only used to modify the meaning of 
mode values 
all and 
common, and can only be used with one of those values. The
[no] form of the option by itself does not explicitly
cause a particular trap to be disabled.
.NL
.PP
Use 
mode value 
inexact with caution. This results in the trap being
enabled whenever a floating\-point value cannot be represented exactly, which
can cause unexpected results.
.NL
.PP
If 
mode value 
underflow is specified, the compiler ignores the FTZ
(flush\-to\-zero) bit state of Intel(R) Streaming SIMD Extensions (Intel(R) SSE)
floating\-point units.
.NL
.PP
When a DAZ (denormals are zero) bit is set in an Intel(R) SSE floating\-point
unit control word, a denormal operand exception is never generated.
.NL
.PP
To set the floating\-point trapping mode for all routines, specify
the[Q]fp\-trap\-all option.
.NL
.PP
.B NOTE:
The negative form of the 
[Q]ftz option can be used to set or reset the FTZ and the
DAZ hardware flags. 
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fp\-trap\-all=mode[,mode,...]
.RS
.TP
Sets the floating\-point trapping mode for
all routines.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.TP 18
\fImode\fR
.NL
Is the floating\-point trapping mode. If you specify
more than one mode value, the list is processed sequentially from left to
right. Possible values are:
.RS
.TP 15
[no]divzero
Enables or disables the IEEE trap for
division by zero.
.TP 15
[no]inexact 
Enables or disables the IEEE trap for inexact
result.
.TP 15
[no]invalid 
Enables or disables the IEEE trap for invalid
operation.
.TP 15
[no]overflow 
Enables or disables the IEEE trap for
overflow.
.TP 15
[no]underflow 
Enables or disables the IEEE trap for
underflow.
.TP 15
[no]denormal 
Enables or disables the trap for denormal.
.TP 15
all
Enables all of the above traps.
.TP 15
none
Disables all of the above traps.
.TP 15
common
Sets the most commonly used IEEE traps: division by zero,
invalid operation, and overflow. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fp\-trap\-all=none 
.NL
No traps are enabled for all routines.
.TP
\fBDescription:\fR 
.PP
This option sets the floating\-point trapping mode for the main routine. It
does not set a handler for floating\-point exceptions.
.NL
.PP
The 
[no] form of a 
mode value is only used to modify the meaning of 
mode values 
all and 
common, and can only be used with one of those values. The
[no] form of the option by itself does not explicitly
cause a particular trap to be disabled.
.NL
.PP
Use 
mode value 
inexact with caution. This results in the trap being
enabled whenever a floating\-point value cannot be represented exactly, which
can cause unexpected results.
.NL
.PP
If 
mode value 
underflow is specified, the compiler ignores the FTZ
(flush\-to\-zero) bit state of Intel(R) Streaming SIMD Extensions (Intel(R) SSE)
floating\-point units.
.NL
.PP
When a DAZ (denormals are zero) bit is set in an Intel(R) SSE floating\-point
unit control word, a denormal operand exception is never generated.
.NL
.PP
To set the floating\-point trapping mode for the main routine only, specify
the 
[Q]fp\-trap option.
.NL
.PP
.B NOTE:
The negative form of the 
[Q]ftz option can be used to set or reset the FTZ and the
DAZ hardware flags. 
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fpack\-struct
.RS
.TP
Specifies that structure members should be packed together.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Specifies that structure members should be packed together. 
.NL
.PP
.B NOTE:
Using this option may result in code that is not usable with standard (system) c and C++ libraries.
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-Zp1
.NL
.RE
.TP
.B
\-fpermissive
.RS
.TP
Tells the compiler to allow for non\-conformant code.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Tells the compiler to allow for non\-conformant code.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fpic
.TP
.B
\-fno\-pic
.RS
.TP
Determines whether the compiler generates position\-independent code.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-pic
.NL
The compiler does not generate position\-independent code.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler generates position\-independent code.
.NL
.PP
Option \-fpic specifies full symbol preemption. Global symbol definitions as well as global symbol references get default (that is, preemptable) visibility unless explicitly specified otherwise.
.NL
.PP
Option \-fpic must be used when building shared objects.
.NL
.PP
This option can also be specified as \-fPIC.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fpie (L*X only)
.RS
.TP
Tells the compiler to generate position\-independent code. The generated code can only be linked into executables. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate position\-independent code for an executable\-only object.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate position\-independent code. It is similar to \-fpic, but code generated by \-fpie can only be linked into an executable. 
.NL
.PP
Because the object is linked into an executable, this option causes better optimization of some symbol references.
.NL
.PP
To ensure that run\-time libraries are set up properly for the executable, you should also specify option \-pie to the compiler driver on the link command line. 
.NL
.PP
Option \-fpie can also be specified as \-fPIE.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fprotect\-parens
.TP
.B
\-fno\-protect\-parens
.RS
.TP
Determines whether the optimizer honors
parentheses when expressions are evaluated. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-protect\-parens 
.NL
Parentheses are ignored when determining the order
of expression evaluation. 
.TP
\fBDescription:\fR 
.PP
This option determines whether the optimizer honors parentheses when
determining the order of expression evaluation. 
.NL
.PP
When option 
\-fprotect\-parens (Linux* and OS X*) or 
/Qprotect\-parens (Windows*) is specified, the optimizer will
maintain the order of evaluation imposed by parentheses in the code. 
.NL
.PP
When the option 
\-fno\-protect\-parens (Linux* and OS X*) or 
/Qprotect\-parens\- (Windows*) is specified, the optimizer may
reorder expressions without regard for parentheses if it produces faster
executing code. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-freg\-struct\-return
.RS
.TP
Tells the compiler to return struct and union values in registers when possible.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on IA\-32 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to return struct and union values in registers when possible.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fshort\-enums
.RS
.TP
Tells the compiler to allocate as many bytes as needed for enumerated types. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler allocates a default number of bytes for enumerated types.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to allocate as many bytes as needed for enumerated types.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fsource\-asm
.RS
.TP
Produces an assembly listing with source code annotations.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No source code annotations appear in the assembly listing file, if one is produced.
.TP
\fBDescription:\fR 
.PP
This option produces an assembly listing file with source code annotations. The assembly listing file shows the source code as interspersed comments.
.NL
.PP
To use this option, you must also specify option \-S, which causes an assembly listing to be generated.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fstack\-protector[\-keyword]
.TP
.B
\-fno\-stack\-protector[\-keyword]
.RS
.TP
Enables or disables stack overflow
security checks for certain (or all) routines. 
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Possible values are: 
.RS
.TP 15
strong
When option 
\-fstack\-protector\-strong is specified, it enables
stack overflow security checks for routines with any type of buffer. 
.TP 15
all
When option 
\-fstack\-protector\-all is specified, it enables
stack overflow security checks for every routine. 
.RE
.PP
If no 
\-keyword is specified, option 
\-fstack\-protector enables stack overflow security checks for
routines with a string buffer. 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-stack\-protector, 
\-fno\-stack\-protector\-strong
.NL
No stack overflow security checks are enabled for
the relevant routines. 
.TP 18
\-fno\-stack\-protector\-all
.NL
No stack overflow security checks are enabled for
any routines. 
.TP
\fBDescription:\fR 
.PP
This option enables or disables stack overflow security checks for certain
(or all) routines. A stack overflow occurs when a program stores more data in a
variable on the execution stack than is allocated to the variable. Writing past
the end of a string buffer or using an index for an array that is larger than
the array bound could cause a stack overflow and security violations. 
.NL
.PP
The 
\-fstack\-protector options are provided for compatibility with
gcc. They use the gcc/glibc implementation when possible. If the gcc/glibc
implementation is not available, they use the Intel implementation. 
.NL
.PP
For an Intel\-specific version of this feature, see option 
\-fstack\-security\-check. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-fstack\-security\-check
.TP
.B
\-fno\-stack\-security\-check
.RS
.TP
Determines whether the compiler generates
code that detects some buffer overruns. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-stack\-security\-check
.NL
The compiler does not detect buffer overruns. 
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler generates
code that detects some buffer overruns that overwrite the return address. This
is a common technique for exploiting code that does not enforce buffer size
restrictions. 
.NL
.PP
This option always uses an Intel implementation. 
.NL
.PP
For a gcc\-compliant version of this feature, see option 
fstack\-protector. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-fsyntax\-only
.RS
.TP
Tells the compiler to check only for correct syntax. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Normal compilation is performed.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to check only for correct syntax. No object file is produced.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-ftemplate\-depth=n
.RS
.TP
Control the depth in which recursive templates are expanded.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
The number of recursive templates that are expanded. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics for the depth of expansion.
.TP
\fBDescription:\fR 
.PP
Control the depth in which recursive templates are expanded. On Linux*, this option is supported only by invoking the compiler with icpc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ftls\-model=model
.RS
.TP
Changes the thread local storage (TLS) model.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fImodel\fR
.NL
Determines the TLS model used by the compiler. Possible values are:
.RS
.TP 15
global\-dynamic
Generates a generic TLS code. The code can be used everywhere and the code can access variables defined anywhere else. This setting causes the largest size code to be generated and uses the most run time to produce.
.TP 15
local\-dynamic
Generates an optimized TLS code. To use this setting, the thread\-local variables must be defined in the same object in which they are referenced.
.TP 15
initial\-exec
Generates a restrictive, optimized TLS code. To use this setting, the thread\-local variables accessed must be defined in one of the modules available to the program.
.TP 15
local\-exec
Generates the most restrictive TLS code. To use this setting, the thread\-local variables must be defined in the executable.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics when determining the thread\-local storage model.
.TP
\fBDescription:\fR 
.PP
This option changes the thread local storage (TLS) model.  Thread\-local storage is a mechanism by which
variables are allocated in a way that causes one instance of the
variable per extant thread.
.NL
.PP
For more information on the thread\-storage
localization models, see the appropriate gcc*
documentation.
.NL
.PP
For more information on the thread\-storage
localization models, see the appropriate clang*
documentation.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ftrapuv
.RS
.TP
Initializes stack local variables to an
unusual value to aid error detection. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not initialize local variables. 
.TP
\fBDescription:\fR 
.PP
This option initializes stack local variables to an
unusual value to aid error detection. Normally, these local variables should be
initialized in the application. It also unmasks the floating\-point invalid
exception. 
.NL
.PP
The option sets any uninitialized local variables that
are allocated on the stack to a value that is typically interpreted as a very
large integer or an invalid address. References to these variables are then
likely to cause run\-time errors that can help you detect coding errors. 
.NL
.PP
This option sets option 
\-g (Linux* and OS X*) and
/Zi or 
/Z7 (Windows*), which
changes the default optimization level from 
O2 to 
\-O0 (Linux and OS X) or 
/Od (Windows). You can override this effect by explicitly
specifying an 
O option setting. 
.NL
.PP
If option 
O2 and option 
\-ftrapuv (Linux and OS X) or 
/Qtrapuv (Windows) are used together, you should specify
option 
\-fp\-speculation safe (Linux and OS X) or 
/Qfp\-speculation:safe (Windows) to prevent exceptions
resulting from speculated floating\-point operations from being trapped. 
.NL
.PP
For more details on using options 
\-ftrapuv and 
/Qtrapuv with compiler option 
O, see the article in Intel(R) Developer Zone titled 
Don\[aq]t optimize when using \-ftrapuv for uninitialized variable
detection. 
.NL
.PP
Another way to detect uninitialized local scalar
variables is by specifying keyword 
uninit for option 
check. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-ftz
.TP
.B
\-no\-ftz
.RS
.TP
Flushes denormal results to zero.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-ftz
.NL
Denormal results are flushed to zero.
.IP
Every optimization option O level, except O0, sets [Q]ftz.
.TP
\fBDescription:\fR 
.PP
This option flushes denormal results to zero when the application is in the gradual underflow mode. It may improve performance if the denormal values are not critical to your application\[aq]s behavior.
.NL
.PP
The [Q]ftz option has no effect during compile\-time optimization.
.NL
.PP
The [Q]ftz option sets or resets the FTZ and the DAZ hardware flags. If FTZ is ON, denormal results from floating\-point calculations will be set to the value zero. If FTZ is OFF, denormal results remain as is. If DAZ is ON, denormal values used as input to floating\-point instructions will be treated as zero. If DAZ is OFF, denormal instruction inputs remain as is.  Systems using Intel(R) 64 architecture have both FTZ and DAZ. FTZ and DAZ are not supported on all IA\-32 architectures. 
.NL
.PP
When the [Q]ftz option is used in combination with an SSE\-enabling option on systems using IA\-32 architecture (for example, the [Q]xSSE2 option), the compiler will insert code in the main routine to set FTZ and DAZ. When [Q]ftz is used without such an option, the compiler will insert code to conditionally set FTZ/DAZ based on a run\-time processor check.  The negative form of  option [Q]ftz will prevent the compiler from inserting any code that might set FTZ or DAZ. 
.NL
.PP
Option [Q]ftz only has an effect when the main program is being compiled. It sets the FTZ/DAZ mode for the process. The initial thread and any threads subsequently created by that process will operate in FTZ/DAZ mode.
.NL
.PP
If this option produces undesirable results of the numerical behavior of your program, you can turn the FTZ/DAZ mode off by using \-no\-ftz or /Qftz\- in the command line while still benefiting from the O3 optimizations.
.NL
.PP
.B NOTE:
Option [Q]ftz is a performance option. Setting this option does not guarantee that all denormals in a program are flushed to zero. The option only causes denormals generated at run time to be flushed to zero.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-funroll\-all\-loops
.RS
.TP
Unroll all loops even if the number of iterations is uncertain when the loop is entered.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Do not unroll all loops.
.TP
\fBDescription:\fR 
.PP
Unroll all loops, even if the number of iterations is uncertain when the loop is entered. There may a performance impact with this option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-funsigned\-bitfields
.TP
.B
\-fno\-unsigned\-bitfields
.RS
.TP
Determines whether the default bitfield type is changed to unsigned.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-unsigned\-bitfields
.NL
The default bitfield type is signed.
.TP
\fBDescription:\fR 
.PP
This option determines whether the default bitfield type is changed to unsigned.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-funsigned\-char
.RS
.TP
Change default char type to unsigned.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Do not change default char type to unsigned.
.TP
\fBDescription:\fR 
.PP
Change default char type to unsigned. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fverbose\-asm
.TP
.B
\-fno\-verbose\-asm
.RS
.TP
Produces an assembly listing with compiler comments, including options and version information.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-verbose\-asm
.NL
No source code annotations appear in the assembly listing file, if one is produced.
.TP
\fBDescription:\fR 
.PP
This option produces an assembly listing file with compiler comments, including options and version information.
.NL
.PP
To use this option, you must also specify \-S, which sets \-fverbose\-asm.
.NL
.PP
If you do not want this default when you specify \-S, specify \-fno\-verbose\-asm.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fvisibility=keyword
.TP
.B
\-fvisibility\-keyword=filename
.RS
.TP
Specifies the default visibility for
global symbols or the visibility for symbols in a file. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies the visibility setting. Possible values
are:
.RS
.TP 15
default
Sets visibility to default.
.TP 15
extern
Sets visibility to extern.
.TP 15
hidden
Sets visibility to hidden.
.TP 15
internal
Sets visibility to internal.
.TP 15
protected
Sets visibility to protected. This value is
not available on OS X* systems.
.RE
.TP 18
\fIfilename\fR
.NL
Is the pathname of a file containing the list of
symbols whose visibility you want to set. The symbols must be separated by
whitespace (spaces, tabs, or newlines).
.TP
\fBDefault:\fR 
.TP 18
\-fvisibility=default
.NL
The compiler sets visibility of symbols to default.
.TP
\fBDescription:\fR 
.PP
This option specifies the default visibility for global
symbols (syntax 
\-fvisibility=\fIkeyword\fR) or the visibility for
symbols in a file (syntax 
\-fvisibility\-\fIkeyword=filename\fR). 
.NL
.PP
Visibility specified by 
\-fvisibility\-\fIkeyword=filename\fR overrides
visibility specified by 
\-fvisibility=\fIkeyword\fR for symbols specified
in a file.
.NL
.TP 18
\fBOption
\fR
.NL
.NL
\fBDescription
\fR
.NL
.NL
.TP 18
\-fvisibility=default \-fvisibility\-default\fI=filename\fR
.NL
Sets visibility of symbols to default. This
means other components can reference the symbol, and the symbol definition can
be overridden (preempted) by a definition of the same name in another
component.
.NL
.TP 18
\-fvisibility=extern \-fvisibility\-extern\fI=filename\fR
.NL
Sets visibility of symbols to extern. This
means the symbol is treated as though it is defined in another component. It
also means that the symbol can be overridden by a definition of the same name
in another component.
.NL
.TP 18
\-fvisibility=hidden \-fvisibility\-hidden\fI=filename\fR
.NL
Sets visibility of symbols to hidden. This
means that other components cannot directly reference the symbol. However, its
address may be passed to other components indirectly.
.NL
.TP 18
\-fvisibility=internal \-fvisibility\-internal\fI=filename\fR
.NL
Sets visibility of symbols to internal. This
means that the symbol cannot be referenced outside its defining component,
either directly or indirectly. The affected functions can never be called from
another module, including through function pointers.
.NL
.TP 18
\-fvisibility=protected \-fvisibility\-protected\fI=filename\fR
.NL
Sets visibility of symbols to protected. This
means other components can reference the symbol, but it cannot be overridden by
a definition of the same name in another component. This value is not available
on OS X* systems.
.NL
.PP
If an 
\-fvisibility option is
specified more than once on the command line, the last specification takes
precedence over any others.
.NL
.PP
If a symbol appears in more than one visibility 
\fIfilename\fR, the
setting with the least visibility takes precedence.
.NL
.PP
The following shows the precedence of the visibility
settings (from greatest to least visibility):
.NL
.IP \(bu 2
extern
.IP \(bu 2
default
.IP \(bu 2
protected
.IP \(bu 2
hidden
.IP \(bu 2
internal
.PP
Note that 
extern visibility only applies to
functions. If a variable symbol is specified as 
extern, it is assumed to be 
default.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fvisibility\-inlines\-hidden
.RS
.TP
Causes inline member functions (those defined in the class declaration) to be marked hidden.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on IA\-32 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not cause inline member functions to be marked hidden.
.TP
\fBDescription:\fR 
.PP
Causes inline member functions (those defined in the class declaration) to be marked hidden. This option is particularly useful for templates.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fzero\-initialized\-in\-bss
.TP
.B
\-fno\-zero\-initialized\-in\-bss
.RS
.TP
Determines whether the compiler places
in the DATA section any variables explicitly initialized with zeros.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-zero\-initialized\-in\-bss 
.NL
Variables explicitly initialized with zeros are
placed in the BSS section. This can save space in the resulting code.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler places in the DATA section any
variables explicitly initialized with zeros.
.NL
.PP
If option 
\-fno\-zero\-initialized\-in\-bss (Linux* and OS X*) or 
/Qzero\-initialized\-in\-bss\- (Windows*) is specified, the
compiler places in the DATA section any variables that are initialized to zero.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-g
.RS
.TP
Tells the compiler to generate full
debugging information in the object file. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No debugging information is produced. 
.TP
\fBDescription:\fR 
.PP
Option 
\-g tells the compiler to generate symbolic debugging
information in the object file, which increases the size of the object file. 
.NL
.PP
The compiler does not support the generation of debugging information in
assemblable files. If you specify this option, the resulting object file will
contain debugging information, but the assemblable file will not. 
.NL
.PP
This option turns off option 
\-O2 and makes option 
\-O0 the default unless option 
\-O2 (or higher) is explicitly specified in the same command
line. 
.NL
.PP
Specifying the 
\-g or 
\-O0 option sets the 
\-fno\-omit\-frame\-pointer option. On Linux*, the \-debug
inline\-debug\-info option will be enabled by default if you compile with
optimizations (option 
\-O2 or higher) and debugging is enabled (option 
\-g). 
.NL
.PP
.B NOTE:
When option 
\-g is specified, debugging information is generated in the
DWARF Version 3 format. Older versions of some analysis tools may require
applications to be built with the 
\-gdwarf\-2 option to ensure correct operation. 
.TP
\fBAlternate Options:\fR 
.PP
Linux: None 
.NL
.PP
Windows: /Zi, /Z7,
/ZI
.NL
.RE
.TP
.B
\-g0
.RS
.TP
Disables generation of symbolic debug information. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler generates symbolic debug information.
.TP
\fBDescription:\fR 
.PP
This option disables generation of symbolic debug information. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gcc
.TP
.B
\-no\-gcc
.TP
.B
\-gcc\-sys
.RS
.TP
Determines whether certain GNU macros are defined or undefined. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-gcc
.NL
The compiler defines the GNU macros __GNUC__, __GNUC_MINOR__, and __GNUC_PATCHLEVEL__
.TP
\fBDescription:\fR 
.PP
This option determines whether the GNU macros __GNUC__, __GNUC_MINOR__, and __GNUC_PATCHLEVEL__ are defined or undefined.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
\-gcc
.NL
Defines GNU macros.
.NL
.TP 18
\-no\-gcc
.NL
Undefines GNU macros.
.NL
.TP 18
\-gcc\-sys
.NL
Defines GNU macros only during compilation of system headers.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gcc\-include\-dir (L*X only)
.TP
.B
\-no\-gcc\-include\-dir (L*X only)
.RS
.TP
Controls whether the gcc\-specific include directory is put into the system include path.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-gcc\-include\-dir
.NL
The gcc\-specific include directory is put into the system include path.
.TP
\fBDescription:\fR 
.PP
This option controls whether the gcc\-specific include directory is put into the system include path.
.NL
.PP
If you specify \-no\-gcc\-include\-dir, the gcc\-specific include directory will not be put into the system include path.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gcc\-name=name (L*X only)
.RS
.TP
Lets you specify the name of the gcc compiler that should be used to set up the environment for C compilations.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the gcc compiler to use.  It can include the path where the gcc compiler is located.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses the PATH setting to find the gcc compiler and resolve environment settings.
.TP
\fBDescription:\fR 
.PP
This option lets you specify the name of the gcc compiler that should be used to set up the environment for C compilations. If you do not specify a path, the compiler will search the PATH settings for the compiler name you provide.
.NL
.PP
This option is helpful when you are referencing a non\-standard gcc installation, or you have multiple gcc installations on your system. The compiler will match gcc version values to the gcc compiler you specify.
.NL
.PP
The C++ equivalent to option \-gcc\-name is \-gxx\-name.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gdwarf\-n
.RS
.TP
Lets you specify a DWARF Version format
when generating debug information.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a value denoting the DWARF Version format to
use. Possible values are:
.RS
.TP 15
2
Generates debug information using the DWARF
Version 2 format.
.TP 15
3
Generates debug information using the DWARF
Version 3 format.
.TP 15
4
Generates debug information using the DWARF
Version 4 format. This setting is only available on Linux*.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No debug information is generated. However, if
compiler option 
\-g is specified,
debugging information is generated in the DWARF Version 3 format.
.TP
\fBDescription:\fR 
.PP
This option lets you specify a DWARF Version format when
generating debug information. 
.NL
.PP
Note that older versions of some analysis tools may
require applications to be built with the \-gdwarf\-2 option to ensure correct
operation.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-global\-hoist
.TP
.B
\-no\-global\-hoist
.RS
.TP
Enables certain optimizations that can move memory loads to a point earlier in the program execution than where they appear in the source.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-global\-hoist 
.NL
Certain optimizations are enabled that can move memory loads.
.TP
\fBDescription:\fR 
.PP
This option enables certain optimizations that can move memory loads to a point earlier in the program execution than where they appear in the source. In most cases, these optimizations are safe and can improve performance. 
.NL
.PP
The negative form of the option is useful for some applications, such as those that use shared or dynamically mapped memory, which can fail if a load is moved too early in the execution stream (for example, before the memory is mapped).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gnu\-prefix=prefix (L*X only)
.RS
.TP
Lets you specify a prefix that will be
added to the names of gnu utilities called from the compiler. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIprefix\fR
.NL
Is a string that prepends the name of gnu tools called from the
compiler. The value depends on the gnu toolchain used for a particular
operating system. For example, for Wind River* Linux 6.x, the 
\fIprefix\fR value will be 
x86_64\-wrs\-linux\-. You must append a hyphen to 
\fIprefix\fR only if the toolchain prefix ends with a
hyphen. 
.IP
You can specify a short name or a pathname: 
.RS
.IP \(bu 2
short name: 
\-gnu\-prefix=\fIprefix\fR
In this case, the compiler calls 
\fIprefix<gnu_utility>\fR instead of 
\fI<gnu_utility>\fR. The utility with this name
should be in the PATH environment variable. 
.IP \(bu 2
pathname: 
\-gnu\-prefix=/directory_name/\fIprefix\fR
In this case, the compiler calls 
/directory_name/\fIprefix<gnu_utility>\fR.
The utility with this name will be invoked by its full pathname. 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler calls gnu utilities by their short
names, and looks for them in the path specified by the PATH environment
variable. 
.TP
\fBDescription:\fR 
.PP
This option lets you specify a prefix that will be added to the names of
gnu utilities called from the compiler. This option is available for
Linux*\-targeted compilers but the host may be either Windows* or Linux*. 
.NL
.PP
If you specify option 
\-gnu\-prefix with option 
\-gcc\-name (or 
\-gxx\-name), the following occurs: 
.NL
.IP \(bu 2
If a name specified in 
\-gcc\-name (or 
\-gxx\-name) contains a full path to a binary then option 
\-gnu\-prefix has no effect on the specified name; other
binutils will have the prefix. 
.IP \(bu 2
Otherwise, option 
\-gnu\-prefix is applied to the name specified in 
\-gcc\-name (or 
\-gxx\-name). 
.PP
The above approach provides flexibility to specify an
alternative gcc name outside of the default toolchain. At the same time, if a
short name is provided in option 
\-gcc\-name, it is assumed to be a part of the default toolchain
and a prefix will be added. 
.NL
.PP
Instead of using option 
\-gnu\-prefix, you can create symlinks for the short names of
gnu utilities in the toolchain and add them to the PATH. For example, 
ld\-\-> i686\-wrs\-linux\-gnu\-ld. 
.NL
.PP
.B NOTE:
Even though this option is not supported for a
Windows\-to\-Windows native compiler, it is supported for a Windows\-host to
Linux\-target compiler. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-grecord\-gcc\-switches (L*X only)
.RS
.TP
Causes the command line options that were used to invoke the compiler to be appended to the DW_AT_producer attribute in DWARF debugging information.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The command line options that were used to
invoke the compiler are not appended to the DW_AT_producer
attribute in DWARF debugging information.
.TP
\fBDescription:\fR 
.PP
This option causes the command line options
that were used to invoke the compiler to be appended to the DW_AT_producer attribute in DWARF
debugging information.
.NL
.PP
The options
are concatenated with whitespace separating them from each other and
from the compiler version.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gsplit\-dwarf (L*X only)
.RS
.TP
Creates a separate object file containing
DWARF debug information. 
.NL
.TP
\fBArchitectures:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No separate object file containing DWARF debug
information is created. 
.TP
\fBDescription:\fR 
.PP
This option creates a separate object file containing DWARF debug
information. It causes debug information to be split between the generated
object (.o) file and the new DWARF object (.dwo) file. 
.NL
.PP
The DWARF object file is not used by the linker, so this reduces the amount
of debug information the linker must process and it results in a smaller
executable file. 
.NL
.PP
For this option to perform correctly, you must use binutils\-2.24 or later.
To debug the resulting executable, you must use gdb\-7.6.1 or later. 
.NL
.PP
.B NOTE:
If you use the split executable with a tool that does
not support the split DWARF format, it will behave as though the DWARF debug
information is absent. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-guide[=n]
.RS
.TP
Lets you set a level of guidance for
auto\-vectorization, auto parallelism, and data transformation. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional value specifying the level of guidance to be provided.
.IP
The values available are 1 through 4. Value 1 indicates a standard
level of guidance. Value 4 indicates the most advanced level of guidance. If 
\fIn\fR is omitted, the default is 4.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance about how to improve
optimizations for parallelism, vectorization, and data transformation.
.TP
\fBDescription:\fR 
.PP
This option lets you set a level of guidance (advice) for
auto\-vectorization, auto parallelism, and data transformation. It causes the
compiler to generate messages suggesting ways to improve these optimizations. 
.NL
.PP
When this option is specified, the compiler does not
produce any objects or executables. 
.NL
.PP
You must also specify the 
[Q]parallel option to receive auto parallelism guidance.
.NL
.PP
You can set levels of guidance for the individual guide
optimizations by specifying one of the following options:
.NL
.TP 18
[Q]guide\-data\-trans
.NL
Provides guidance for data transformation. 
.TP 18
[Q]guide\-par
.NL
Provides guidance for auto
parallelism.
.TP 18
[Q]guide\-vec
.NL
Provides guidance for auto\-vectorization. 
.PP
If you specify the 
[Q]guide option and also specify one of the options setting a
level of guidance for an individual guide optimization, the value set for the
individual guide optimization will override the setting specified in 
[Q]guide.
.NL
.PP
If you do not specify 
[Q]guide, but specify one of the options setting a level of
guidance for an individual guide optimization, option 
[Q]guide is enabled with the greatest value passed among any
of the three individual guide optimizations specified.
.NL
.PP
In debug mode, this option has no effect unless option 
O2 (or higher) is explicitly specified in the same command
line.
.NL
.PP
.B NOTE:
The compiler speculatively performs optimizations as
part of guide analysis. As a result, when you use guided auto\-parallelism
options with options that produce vectorization or auto\-parallelizer reports
(such as option 
[q or Q]opt\-report), the compiler generates "LOOP WAS
VECTORIZED" or similar messages as if the compilation was performed with the
recommended changes. 
.PP
When compilation is performed with the 
[Q]guide option, you should use extra caution when
interpreting vectorizer diagnostics and auto\-parallelizer diagnostics.
.PP
.B NOTE:
You can specify 
[Q]diag\-disable to prevent the compiler from issuing one or
more diagnostic messages. 
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-data\-trans[=n]
.RS
.TP
Lets you set a level of guidance for data transformation.  
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional value specifying the level of guidance to be provided.
.IP
The values available are 1 through 4. Value 1 indicates a standard level of guidance. Value 4 indicates the most advanced level of guidance. If \fIn\fR is omitted, the default is 4.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance about how to improve optimizations for data transformation.
.TP
\fBDescription:\fR 
.PP
This option lets you set a level of guidance for data transformation. It causes the compiler to generate messages suggesting ways to improve that optimization.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-file[=filename]
.RS
.TP
Causes the results of guided auto
parallelism to be output to a file.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file for output. It can include
a path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Messages that are generated by guided auto
parallelism are output to stderr.
.TP
\fBDescription:\fR 
.PP
This option causes the results of guided auto parallelism to be output to a
file.
.NL
.PP
This option is ignored unless you also specify one or more of the following
options: 
.NL
.IP \(bu 2
[Q]guide
.IP \(bu 2
[Q]guide\-vec
.IP \(bu 2
[Q]guide\-data\-trans
.IP \(bu 2
[Q]guide\-par
.PP
If you do not specify a path, the file is placed in the current working
directory.
.NL
.PP
If there is already a file named 
\fIfilename\fR, it will be
overwritten.
.NL
.PP
You can include a file extension in 
\fIfilename\fR. For
example, if 
\fIfile.txt\fR is specified, the name of the output file is 
\fIfile.txt\fR. If you do not provide a file extension, the name
of the file is 
\fIfilename.guide\fR.
.NL
.PP
If you do not specify 
\fIfilename\fR, the name
of the file is 
\fIname\-of\-the\-first\-source\-file.guide\fR. This is also the name
of the file if the name specified for 
\fIfilename\fR conflicts with a source file name provided in the
command line.
.NL
.PP
.B NOTE:
If you specify the 
[Q]guide\-file option and you also specify option 
[Q]guide\-file\-append, the last option specified on the
command line takes precedence.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-file\-append[=filename]
.RS
.TP
Causes the results of guided auto parallelism to be appended to a file.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file to be appended to. It can include a path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Messages that are generated by guided auto parallelism are
output to stderr.
.TP
\fBDescription:\fR 
.PP
This option causes the results of guided auto parallelism to be appended to a file.
.NL
.PP
This option is ignored unless you also specify
one or more of the following options: 
.NL
.IP \(bu 2
[Q]guide
.IP \(bu 2
[Q]guide\-vec
.IP \(bu 2
[Q]guide\-data\-trans
.IP \(bu 2
[Q]guide\-par
.PP
If you do not specify a path, the compiler
looks for \fIfilename\fR in the current working directory.
.NL
.PP
If \fIfilename\fR is not found, then a new file with
that name is created in the current working directory.
.NL
.PP
If you do not specify a file extension, the
name of the file is \fIfilename.guide\fR.
.NL
.PP
If the name specified for \fIfilename\fR conflicts
with a source file name provided in the command line, the name of
the file is \fIname\-of\-the\-first\-source\-file.guide\fR.
.NL
.PP
.B NOTE:
If you specify the [Q]guide\-file\-append
option
and you also specify option  [Q]guide\-file, the last option specified on the command line takes precedence.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-opts=string
.RS
.TP
Tells the compiler to analyze certain
code and generate recommendations that may improve optimizations. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Is the text denoting the code to analyze. The
string must appear within quotes. It can take one or more of the following
forms: 
\fIfilename\fR\fIfilename\fR, 
\fIroutine\fR\fIfilename\fR, 
\fIrange\fR [, 
\fIrange\fR]... 
\fIfilename\fR, 
\fIroutine\fR, 
\fIrange\fR [, 
\fIrange\fR]... 
.IP
If you specify more than one of the above forms in
a string, a semicolon must appear between each form. If you specify more than
one 
\fIrange\fR in a string, a comma must appear between each 
\fIrange\fR. Optional blanks can follow each parameter in
the forms above and they can also follow each form in a string. 
.RS
.TP 15
\fIfilename\fR
Specifies the name of a file to be analyzed. It can include a
path. 
.IP
If you do not specify a path, the compiler looks for filename
in the current working directory. 
.TP 15
\fIroutine\fR
Specifies the name of a routine to be analyzed. You can include
an identifying parameter. 
.IP
The name, including any
parameter, must be
enclosed in single quotes. 
.IP
The compiler tries to uniquely identify the routine that
corresponds to the specified routine name. It may select multiple routines to
analyze, especially if the following is true: 
.RS
.IP \(bu 2
More than one routine has the specified
routine name, so the routine cannot be uniquely identified. 
.IP \(bu 2
No
parameter information has
been specified to narrow the number of routines selected as matches. 
.RE
.TP 15
\fIrange\fR
Specifies a range of line numbers to analyze in the file or
routine specified. The 
\fIrange\fR must be specified in integers in the
form: 
.IP
\fIfirst_line_number\-last_line_number\fR
.IP
The hyphen between the line numbers is required. 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance on how to improve
optimizations. However, if you specify the 
[Q]guide option, the compiler analyzes and generates
recommendations for all the code in an application 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to analyze certain code and generate
recommendations that may improve optimizations. 
.NL
.PP
This option is ignored unless you also specify one or more of the following
options: 
.NL
.IP \(bu 2
[Q]guide
.IP \(bu 2
[Q]guide\-vec
.IP \(bu 2
[Q]guide\-data\-trans
.IP \(bu 2
[Q]guide\-par
.PP
When the 
[Q]guide\-opts option is specified, a message is output that
includes which parts of the input files are being analyzed. If a routine is
selected to be analyzed, the complete routine name will appear in the generated
message. 
.NL
.PP
When inlining is involved, you should specify callee line numbers.
Generated messages also use callee line numbers. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-guide\-par[=n]
.RS
.TP
Lets you set a level of guidance for auto parallelism.  
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional value specifying the level of guidance to be provided.
.IP
The values available are 1 through 4. Value 1 indicates a standard level of guidance. Value 4 indicates the most advanced level of guidance. If \fIn\fR is omitted, the default is 4.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance about how to improve optimizations for parallelism.
.TP
\fBDescription:\fR 
.PP
This option lets you set a level of guidance
for auto parallelism. It causes the compiler to generate
messages suggesting ways to improve that optimization.
.NL
.PP
You must also specify the [Q]parallel option to receive auto parallelism
guidance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-profile=filename|dir [, [filename|dir]...]
.RS
.TP
Specifies a loop profiler data file (or a set of files) when used with option \-guide or /Qguide.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is an .xml file created from a loop profiler run.
.TP 18
\fIdir\fR
.NL
Is a directory that contains one or more .xml files from a loop profiler run.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
When the [Q]guide option is specified, the guide region is the whole file or the region specified by option [Q]guide\-opts.
.TP
\fBDescription:\fR 
.PP
This option specifies a loop profiler data file
(or a set of files) when used with the [Q]guide option.
.NL
.PP
This option has no effect unless the [Q]guide option has been specified. Option [Q]guide\-profile
helps you take advantage of the [Q]guide option to more efficiently optimize
your applications for
auto parallelism and/or vectorization.
.NL
.PP
The loop profile data file can be collected by
using one of the following options:
.NL
.IP \(bu 2
[Q]profile\-loops
.IP \(bu 2
[Q]profile\-functions
.PP
When the data is from [Q]profile\-loops, the setting of the guide regions will be based
upon the hottest loops.
.NL
.PP
When the data is from [Q]profile\-functions, the guide region will be the entire function
containing the hottest functions.
.NL
.PP
If you specify options [Q]guide\-opts and
[Q]guide\-profile, the compiler issues an error
message.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-vec[=n]
.RS
.TP
Lets you set a level of guidance for auto\-vectorization.  
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional value specifying the level of guidance to be provided.
.IP
The values available are 1 through 4. Value 1 indicates a standard level of guidance. Value 4 indicates the most advanced level of guidance. If \fIn\fR is omitted, the default is 4.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance about how to improve optimizations for vectorization.
.TP
\fBDescription:\fR 
.PP
This option lets you set a level of guidance
for auto\-vectorization. It causes the compiler to generate
messages suggesting ways to improve that optimization.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gxx\-name=name (L*X only)
.RS
.TP
Lets you specify the name of the g++ compiler that should be used to set up the environment for C++ compilations.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the g++ compiler to use.  It can include the path where the g++ compiler is located.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses the PATH setting to find the g++ compiler and resolve environment settings.
.TP
\fBDescription:\fR 
.PP
This option lets you specify the name of the g++ compiler that should be used to set up the environment for C++ compilations.  If you do not specify a path, the compiler will search the PATH settings for the compiler name you provide.
.NL
.PP
This option is helpful if you have multiple gcc++ installations on your system. The compiler will match gcc++ version values to the gcc++ compiler you specify.
.NL
.PP
The C equivalent to option \-gxx\-name is \-gcc\-name.
.NL
.PP
.B NOTE:
When compiling a C++ file with icc, g++ is used to get the environment.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-H
.RS
.TP
Tells the compiler to display the include file order and continue compilation. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Compilation occurs as usual.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to display the include file order and continue compilation. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-help[category]
.RS
.TP
Displays all available compiler options or a category of compiler options.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIcategory\fR
.NL
Is a category or class of options to display. Possible values are:
.RS
.TP 15
advanced
Displays advanced optimization options that allow fine tuning of compilation or allow control over advanced features of the compiler.
.TP 15
codegen
Displays Code Generation options.
.TP 15
compatibility
Displays options affecting language compatibility.
.TP 15
component
Displays options for component control.
.TP 15
data
Displays options related to interpretation of data in programs or the storage of data.
.TP 15
deprecated
Displays options that have been deprecated.
.TP 15
diagnostics
Displays options that affect diagnostic messages displayed by the compiler.
.TP 15
float
Displays options that affect floating\-point operations.
.TP 15
help
Displays all the available help categories.
.TP 15
inline
Displays options that affect inlining.
.TP 15
ipo
Displays Interprocedural Optimization (IPO) options
.TP 15
language
Displays options affecting the behavior of the compiler language features.
.TP 15
link
Displays linking or linker options.
.TP 15
misc
Displays miscellaneous options that do not fit within other categories.
.TP 15
openmp
Displays OpenMP and parallel processing options.
.TP 15
opt
Displays options that help you optimize code.
.TP 15
output
Displays options that provide control over compiler output.
.TP 15
pgo
Displays Profile Guided Optimization (PGO) options.
.TP 15
preproc
Displays options that affect preprocessing operations.
.TP 15
reports
Displays options for optimization reports.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No list is displayed unless this compiler option is specified.
.TP
\fBDescription:\fR 
.PP
This option displays all available compiler options or a category of compiler options. If category is not specified, all available compiler options are displayed. On Linux* systems, this option can also be specified as \-\-help.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-help\-pragma
.RS
.TP
Displays all supported pragmas.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No list is displayed unless this compiler option is specified.
.TP
\fBDescription:\fR 
.PP
This option displays all supported pragmas and shows their syntaxes.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Idir
.RS
.TP
Specifies an additional directory to search for include files. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the additional directory for the search.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default directory is searched for include files.
.TP
\fBDescription:\fR 
.PP
This option specifies an additional directory to search for include files. To specify multiple directories on the command line, repeat the include option for each directory. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-I\-
.RS
.TP
Splits the include path.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF 
.NL
The default directory is searched for include files.
.TP
\fBDescription:\fR 
.PP
This option splits the include path. It prevents the use of the current directory as the first search directory for \[aq]#include "file"\[aq].
.NL
.PP
If you specify directories using the I option \fIbefore\fR you specify option I\-, the directories are searched only for the case of  \[aq]#include "file"\[aq]; they are not searched for \[aq]#include <file>\[aq].
.NL
.PP
If you specify directories using the I option \fIafter\fR you specify option I\-, these directories are searched for all \[aq]#include\[aq] directives.
.NL
.PP
This option has no effect on option nostdinc++, which searches the standard system directories for header files.
.NL
.PP
This option is provided for compatibility with gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-icc
.TP
.B
\-no\-icc
.RS
.TP
Determines whether certain Intel compiler macros are defined or undefined.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-icc or /Qicl
.NL
The __INTEL_COMPILER macros are set to represent the current version of the compiler.
.TP
\fBDescription:\fR 
.PP
This option determines whether certain Intel compiler macros are defined or undefined.
.NL
.PP
If you specify option \-no\-icc or /Qicl\- , the compiler undefines the __INTEL_COMPILER macros. These macros are defined by default or by specifying \-icc or /Qicl.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-idirafterdir
.RS
.TP
Adds a directory to the second include file search path.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory to add.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Include file search paths include certain default directories.
.TP
\fBDescription:\fR 
.PP
This option adds a directory to the second include file search path (after \-I).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-imacros filename
.RS
.TP
Allows a header to be specified that is included in front of the other headers in the translation unit.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Name of header file.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Allows a header to be specified that is included in front of the other headers in the translation unit.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-calloc
.TP
.B
\-no\-inline\-calloc
.RS
.TP
Tells the compiler to inline calls to calloc() as calls to malloc() and memset().
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-calloc 
.NL
The compiler inlines calls to calloc() as calls to calloc().
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to inline calls to calloc() as calls to malloc() and memset(). This enables additional memset() optimizations. For example, it can enable inlining as a sequence of store operations when the size is a compile time constant.
.NL
.PP
.B NOTE:
Many routines in the supplied libraries are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-factor=n
.TP
.B
\-no\-inline\-factor
.RS
.TP
Specifies the percentage multiplier that
should be applied to all inlining options that define upper limits.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer specifying the percentage
value. The default value is 100 (a factor of 1).
.TP
\fBDefault:\fR 
.TP 18
\-inline\-factor=100 
.NL
The compiler uses a percentage multiplier of 100.
.TP
\fBDescription:\fR 
.PP
This option specifies the percentage multiplier that
should be applied to all inlining options that define upper limits:
.NL
.IP \(bu 2
[Q]inline\-max\-size
.IP \(bu 2
[Q]inline\-max\-total\-size
.IP \(bu 2
[Q]inline\-max\-per\-routine
.IP \(bu 2
[Q]inline\-max\-per\-compile
.PP
The 
[Q]inline\-factor option
takes the default value for each of the above options and multiplies it by 
\fIn\fR divided by 100. For
example, if 200 is specified, all inlining options that define upper limits are
multiplied by a factor of 2. This option is useful if you do not want to
individually increase each option limit.
.NL
.PP
If you specify 
\-no\-inline\-factor (Linux*
and OS X*) or 
/Qinline\-factor\-
(Windows*), the following occurs:
.NL
.IP \(bu 2
Every function is considered to be a small or medium
function; there are no large functions.
.IP \(bu 2
There is no limit to the size a routine may grow when
inline expansion is performed.
.IP \(bu 2
There is no limit to the number of times some routine
may be inlined into a particular routine.
.IP \(bu 2
There is no limit to the number of times inlining can
be applied to a compilation unit.
.PP
To see compiler values for important inlining limits,
specify option 
[q or Q]opt\-report.
.NL
.PP
.B CAUTION:
When you use this option to increase default limits,
the compiler may do so much additional inlining that it runs out of memory and
terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-forceinline
.RS
.TP
Instructs the compiler to force inlining of functions suggested for inlining whenever the compiler is capable doing so.
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics for inline routine expansion.
.TP
\fBDescription:\fR 
.PP
This option instructs the compiler to force inlining of functions suggested for inlining whenever the compiler is capable doing so. 
.NL
.PP
Without this option, the compiler treats functions declared with the inline keyword as merely being recommended for inlining. When this option is used, it is as if they were declared with the keyword __forceinline keyword.
.NL
.PP
.B NOTE:
Because C++ member functions whose definitions are included in the class declaration are considered inline functions by default, using this option will also make these member functions "forceinline" functions.
.PP
To see compiler values for important inlining limits, specify option [q or Q]opt\-report.
.NL
.PP
.B CAUTION:
When you use this option to change the meaning of inline to "forceinline", the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-level=n
.RS
.TP
Specifies the level of inline function
expansion.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the inline function expansion level. Possible
values are 0, 1, and 2.
.TP
\fBDefault:\fR 
.TP 18
\-inline\-level=2
.NL
This is the default if option 
O2 is specified or
is in effect by default. On Windows* systems, this is also the default if
option 
O3 is specified.
.TP 18
\-inline\-level=0
.NL
This is the default if option 
\-O0 (Linux* and OS
X*) is specified.
.TP
\fBDescription:\fR 
.PP
This option specifies the level of inline function
expansion. Inlining procedures can greatly improve the run\-time performance of
certain programs.
.NL
.TP 18
\fBOption
\fR
.NL
.NL
\fBDescription
\fR
.NL
.NL
.TP 18
\-inline\-level=0 or 
/Ob0
.NL
Disables inlining of user\-defined functions.
Note that statement functions are always inlined.
.NL
.TP 18
\-inline\-level=1 
or 
/Ob1
.NL
Enables inlining when an inline keyword or an
inline 
attribute is specified. Also enables inlining
according to the C++ language.
.NL
.TP 18
\-inline\-level=2 
or 
/Ob2
.NL
Enables inlining of any function at the
compiler\[aq]s discretion.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-max\-per\-compile=n
.TP
.B
\-no\-inline\-max\-per\-compile
.RS
.TP
Specifies the maximum number of times
inlining may be applied to an entire compilation unit.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the number of
times inlining may be applied.
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-max\-per\-compile 
.NL
The compiler uses default heuristics for inline
routine expansion.
.TP
\fBDescription:\fR 
.PP
This option the maximum number of times inlining may be
applied to an entire compilation unit. It limits the number of times that
inlining can be applied.
.NL
.PP
For compilations using Interprocedural Optimizations
(IPO), the entire compilation is a compilation unit. For other compilations, a
compilation unit is a file.
.NL
.PP
If you specify 
\-no\-inline\-max\-per\-compile
(Linux* and OS X*) or 
/Qinline\-max\-per\-compile\-
(Windows*), there is no limit to the number of times inlining may be applied to
a compilation unit.
.NL
.PP
To see compiler values for important inlining limits,
specify option 
[q or Q]opt\-report.
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit,
the compiler may do so much additional inlining that it runs out of memory and
terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-max\-per\-routine=n
.TP
.B
\-no\-inline\-max\-per\-routine
.RS
.TP
Specifies the maximum number of times the
inliner may inline into a particular routine.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the maximum
number of times the inliner may inline into a particular routine.
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-max\-per\-routine 
.NL
The compiler uses default heuristics for inline
routine expansion.
.TP
\fBDescription:\fR 
.PP
This option specifies the maximum number of times the
inliner may inline into a particular routine. It limits the number of times
that inlining can be applied to any routine.
.NL
.PP
If you specify 
\-no\-inline\-max\-per\-routine
(Linux* and OS X*) or 
/Qinline\-max\-per\-routine\-
(Windows*), there is no limit to the number of times some routine may be
inlined into a particular routine.
.NL
.PP
To see compiler values for important inlining limits,
specify option 
[q or Q]opt\-report.
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit,
the compiler may do so much additional inlining that it runs out of memory and
terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-max\-size=n
.TP
.B
\-no\-inline\-max\-size
.RS
.TP
Specifies the lower limit for the size of
what the inliner considers to be a large routine.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the minimum
size of what the inliner considers to be a large routine.
.TP
\fBDefault:\fR 
.TP 18
\-inline\-max\-size 
.NL
The compiler sets the maximum size
(\fIn\fR) dynamically, based on the platform.
.TP
\fBDescription:\fR 
.PP
This option specifies the lower limit for the size of
what the inliner considers to be a large routine (a function). The inliner
classifies routines as small, medium, or large. This option specifies the
boundary between what the inliner considers to be medium and large\-size
routines.
.NL
.PP
The inliner prefers to inline small routines. It has a
preference against inlining large routines. So, any large routine is highly
unlikely to be inlined.
.NL
.PP
If you specify 
\-no\-inline\-max\-size
(Linux* and OS X*) or 
/Qinline\-max\-size\-
(Windows*), there are no large routines. Every routine is either a small or
medium routine.
.NL
.PP
To see compiler values for important inlining limits,
specify option 
[q or Q]opt\-report.
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit,
the compiler may do so much additional inlining that it runs out of memory and
terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-max\-total\-size=n
.TP
.B
\-no\-inline\-max\-total\-size
.RS
.TP
Specifies how much larger a routine can
normally grow when inline expansion is performed.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the permitted
increase in the routine\[aq]s size when inline expansion is performed.
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-max\-total\-size 
.NL
The compiler uses default heuristics for inline
routine expansion.
.TP
\fBDescription:\fR 
.PP
This option specifies how much larger a routine can
normally grow when inline expansion is performed. It limits the potential size
of the routine. For example, if 2000 is specified for 
\fIn\fR, the size of any
routine will normally not increase by more than 2000.
.NL
.PP
If you specify 
\-no\-inline\-max\-total\-size
(Linux* and OS X*) or 
/Qinline\-max\-total\-size\-
(Windows*), there is no limit to the size a routine may grow when inline
expansion is performed.
.NL
.PP
To see compiler values for important inlining limits,
specify option 
[q or Q]opt\-report.
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit,
the compiler may do so much additional inlining that it runs out of memory and
terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-min\-size=n
.TP
.B
\-no\-inline\-min\-size
.RS
.TP
Specifies the upper limit for the size of
what the inliner considers to be a small routine.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the maximum
size of what the inliner considers to be a small routine.
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-min\-size 
.NL
The compiler uses default heuristics for inline
routine expansion.
.TP
\fBDescription:\fR 
.PP
This option specifies the upper limit for the size of
what the inliner considers to be a small routine (a function). The inliner
classifies routines as small, medium, or large. This option specifies the
boundary between what the inliner considers to be small and medium\-size
routines.
.NL
.PP
The inliner has a preference to inline small routines.
So, when a routine is smaller than or equal to the specified size, it is very
likely to be inlined.
.NL
.PP
If you specify 
\-no\-inline\-min\-size
(Linux* and OS X*) or 
/Qinline\-min\-size\-
(Windows*), there is no limit to the size of small routines. Every routine is a
small routine; there are no medium or large routines.
.NL
.PP
To see compiler values for important inlining limits,
specify option 
[q or Q]opt\-report.
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit,
the compiler may do so much additional inlining that it runs out of memory and
terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-intel\-extensions
.TP
.B
\-no\-intel\-extensions
.RS
.TP
Enables or disables all Intel(R) C and
Intel(R) C++ language extensions.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The Intel(R) C and Intel(R) C++ language extensions are
enabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables all Intel(R) C and Intel(R)
C++ language extensions. 
.NL
.PP
If you specify the negative form of the option (see
above), it disables all Intel(R) C and Intel(R) C++ language extensions. For
example, it disables the Intel(R) Cilk(TM) Plus language extensions, which include
array notation, and it disables support for the decimal floating\-point types.
.NL
.PP
Note that certain settings for the 
[Q]std compiler option can enable or disable decimal
floating\-point support:
.NL
.IP \(bu 2
The following 
[Q]std settings enable decimal floating\-point support: c89,
gnu89 (Linux* only), gnu99 (Linux* only)
.IP \(bu 2
The following 
[Q]std setting disables decimal floating\-point support: c99
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ip
.TP
.B
\-no\-ip
.RS
.TP
Determines whether additional
interprocedural optimizations for single\-file compilation are enabled.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Some limited interprocedural optimizations occur,
including inline function expansion for calls to functions defined within the
current source file. These optimizations are a subset of full intra\-file
interprocedural optimizations. Note that this setting is not the same as 
\-no\-ip (Linux* and
OS X*).
.TP
\fBDescription:\fR 
.PP
This option determines whether additional interprocedural
optimizations for single\-file compilation are enabled. 
.NL
.PP
The 
[Q]ip option enables
additional interprocedural optimizations for single\-file compilation. 
.NL
.PP
Options 
\-no\-ip (Linux and OS X)
and 
/Qip\- (Windows) may not
disable inlining. To ensure that inlining of user\-defined functions is
disabled, specify 
\-inline\-level=0or 
\-fno\-inline (Linux and OS
X), or specify 
/Ob0 (Windows). 
To ensure that
inliningof compiler intrinsic functions is disabled, specify 
\-fno\-builtin (Linux and
OS X) or 
/Oi\- (Windows). 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ip\-no\-inlining
.RS
.TP
Disables full and partial inlining enabled by interprocedural optimization options.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Inlining enabled by interprocedural optimization options is performed.
.TP
\fBDescription:\fR 
.PP
This option disables full and partial inlining enabled by the following interprocedural optimization options:
.NL
.IP \(bu 2
On Linux* and OS X* systems: \-ip or \-ipo
.IP \(bu 2
On Windows* systems: /Qip, /Qipo, or /Ob2
.PP
It has no effect on other interprocedural optimizations.
.NL
.PP
On Windows systems, this option also has no effect on user\-directed inlining specified by option /Ob1.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ip\-no\-pinlining
.RS
.TP
Disables partial inlining enabled by interprocedural optimization options.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Inlining enabled by interprocedural optimization options is performed.
.TP
\fBDescription:\fR 
.PP
This option disables partial inlining enabled by the following interprocedural optimization options:
.NL
.IP \(bu 2
On Linux* and OS X* systems: \-ip or \-ipo
.IP \(bu 2
On Windows* systems: /Qip or /Qipo
.PP
It has no effect on other interprocedural optimizations.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo[n]
.TP
.B
\-no\-ipo
.RS
.TP
Enables interprocedural optimization between files.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional integer that specifies the number of object files the compiler should create. The integer must be greater than or equal to 0.
.TP
\fBDefault:\fR 
.TP 18
\-no\-ipo or /Qipo\-
.NL
Multifile interprocedural optimization is not enabled.
.TP
\fBDescription:\fR 
.PP
This option enables interprocedural optimization between files. This is also called multifile interprocedural optimization (multifile IPO) or Whole Program Optimization (WPO).
.NL
.PP
When you specify this option, the compiler performs inline function expansion for calls to functions defined in separate files.
.NL
.PP
You cannot specify the names for the files that are created.
.NL
.PP
If \fIn\fR is 0, the compiler decides whether to create one or more object files based on an estimate of the size of the application. It generates one object file for small applications, and two or more object files for large applications.
.NL
.PP
If \fIn\fR is greater than 0, the compiler generates \fIn\fR object files, unless \fIn\fR exceeds the number of source files (\fIm\fR), in which case the compiler generates only \fIm\fR object files.
.NL
.PP
If you do not specify \fIn\fR, the default is 0.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo\-c
.RS
.TP
Tells the compiler to optimize across multiple files and generate a single object file.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate a multifile object file.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to optimize across multiple files and generate a single object file (named ipo_out.o
on Linux* and OS X* systems; ipo_out.obj
on Windows* systems).
.NL
.PP
It performs the same optimizations as the [Q]ipo option, but compilation stops before the final link stage, leaving an optimized object file that can be used in further link steps.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo\-jobsn
.RS
.TP
Specifies the number of commands (jobs) to be executed simultaneously during the link phase of Interprocedural Optimization (IPO).
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the number of commands (jobs) to run simultaneously. The number must be greater than or equal to 1.
.TP
\fBDefault:\fR 
.TP 18
\-ipo\-jobs1 
.NL
One command (job) is executed in an interprocedural optimization parallel build.
.TP
\fBDescription:\fR 
.PP
This option specifies the number of commands (jobs) to be executed simultaneously during the link phase of Interprocedural Optimization (IPO). It should only be used if the link\-time compilation is generating more than one object. In this case, each object is generated by a separate compilation, which can be done in parallel.
.NL
.PP
This option can be affected by the following compiler options:
.NL
.IP \(bu 2
[Q]ipo when applications are large enough that the compiler decides to generate multiple object files.
.IP \(bu 2
[Q]ipo\fIn\fR when \fIn\fR is greater than 1.
.IP \(bu 2
[Q]ipo\-separate
.PP
.B CAUTION:
Be careful when using this option. On a multi\-processor system with lots of memory, it can speed application build time. However, if \fIn\fR is greater than the number of processors, or if there is not enough memory to avoid thrashing, this option can increase application build time.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo\-S
.RS
.TP
Tells the compiler to optimize across multiple files and generate a single assembly file.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate a multifile assembly file.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to optimize across multiple files and generate a single assembly file (named ipo_out.s on Linux* and OS X* systems; ipo_out.asm
on Windows* systems). 
.NL
.PP
It performs the same optimizations as the [Q]ipo option, but compilation stops before the final link stage, leaving an optimized assembly file that can be used in further link steps.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo\-separate (L*X only)
.RS
.TP
Tells the compiler to generate one object file for every source file.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler decides whether to create one or more object files.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate one object file for every source file. It overrides any [Q]ipo option  specification.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipp[=lib]
.RS
.TP
Tells the compiler to link to the some or
all of the Intel(R) Integrated Performance Primitives (Intel(R) IPP) libraries. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology 
.TP
\fBArguments:\fR 
.TP 18
\fIlib\fR
.NL
Indicates the Intel(R) IPP libraries that the
compiler should link to. Possible values are: 
.RS
.TP 15
common
Tells the compiler to link using the main
libraries set. This is the default if the option is specified with no 
\fIlib\fR. 
.TP 15
crypto
Tells the compiler to link using the main
libraries set and the crypto library. 
.TP 15
nonpic
(Linux* only)
Tells the compiler to link using the version
of the libraries that do not have position\-independent code. 
.TP 15
nonpic_crypto (Linux only)
Tells the compiler to link using the crypto
library and the version of the libraries that do not have position\-independent
code. 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not link to the Intel(R) IPP
libraries. 
.TP
\fBDescription:\fR 
.PP
The option tells the compiler to link to the some or all
of the Intel(R) Integrated Performance Primitives (Intel(R) IPP) libraries and
include the Intel(R) IPP headers. 
.NL
.PP
The 
[Q]ipp\-link option controls whether the compiler links to
static, dynamic threaded, or static threaded Intel(R) IPP run\-time libraries. 
.NL
.PP
.B NOTE:
On Windows* systems, this option is processed by the
compiler, which adds directives to the compiled object file that are processed
by the linker. On Linux* and OS X* systems, this option is processed by the
icc/icpc command that initiates linking, adding library names explicitly to the
link command. 
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-ipp\-link[=lib]
.RS
.TP
Controls whether the compiler links to
static or dynamic threaded Intel(R) Integrated Performance Primitives (Intel(R)
IPP) run\-time libraries. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology 
.TP
\fBArguments:\fR 
.TP 18
\fIlib\fR
.NL
Specifies the Intel(R) IPP library to use. Possible
values are: 
.RS
.TP 15
static
Tells the compiler to link to the set of
static run\-time libraries. 
.TP 15
dynamic
Tells the compiler to link to the set of
dynamic threaded run\-time libraries. 
.RE
.TP
\fBDefault:\fR 
.TP 18
dynamic
.NL
The compiler links to the Intel(R) IPP set of dynamic
run\-time libraries. However, if Linux* option 
\-static is specified, the compiler links to the set of
static run\-time libraries. 
.TP
\fBDescription:\fR 
.PP
This option controls whether the compiler links to static
or dynamic threaded Intel(R) Integrated Performance Primitives (Intel(R) IPP)
run\-time libraries. 
.NL
.PP
To use this option, you must also specify the 
[Q]ipp option. 
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-iprefix prefix
.RS
.TP
Option for indicating the prefix for
referencing directories containing header files.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture, targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.TP 18
\fIprefix\fR
.NL
Is the prefix to use.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Options for indicating the prefix for referencing
directories containing header files. Use 
\fIprefix\fR with option 
\-iwithprefix as a prefix.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-iquote dir
.RS
.TP
Add directory to the front of the include file search path for files included with quotes but not brackets.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory to add.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not add a directory to the front of the include file search path.
.TP
\fBDescription:\fR 
.PP
Add directory to the front of the include file search path for files included with quotes but not brackets.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-isystemdir
.RS
.TP
Specifies a directory to add to the start
of the system include path.
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the directory to add to the system include path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default system include path is used.
.TP
\fBDescription:\fR 
.PP
This option specifies a directory to add to the system
include path. The compiler searches the specified directory for include files
after it searches all directories specified by the 
\-I compiler option but
before it searches the standard system directories. 
.NL
.PP
On Linux* systems, this option is provided for
compatibility with gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-iwithprefixdir
.RS
.TP
Appends a directory to the prefix passed
in by \-iprefix and puts it on the include search path at the end of the include
directories. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the include directory. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
This option appends a directory to the prefix passed in
by 
\-iprefix and puts it on
the include search path at the end of the include directories. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-iwithprefixbeforedir
.RS
.TP
Similar to \-iwithprefix except the
include directory is placed in the same place as \-I command line include
directories.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the include directory.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Similar to 
\-iwithprefix except the
include directory is placed in the same place as 
\-I command line include
directories.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-lstring
.RS
.TP
Tells the linker to search for a specified library when linking.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Specifies the library (lib\fIstring\fR) that the linker should search.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The linker searches for standard libraries in standard directories.
.TP
\fBDescription:\fR 
.PP
This option tells the linker to search for a specified library when linking.
.NL
.PP
When resolving references, the linker normally searches for libraries in several standard directories, in directories specified by the L option, then in the library specified by the l option.
.NL
.PP
The linker searches and processes libraries and object files in the order they are specified. So, you should specify this option following the last object file it applies to.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Ldir
.RS
.TP
Tells the linker to search for libraries in a specified directory before searching the standard directories.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory to search for libraries.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The linker searches the standard directories for libraries.
.TP
\fBDescription:\fR 
.PP
This option tells the linker to search for libraries in a specified directory before searching for them in the standard directories.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mcode
.RS
.TP
Tells the compiler which features it may
target, including which instruction sets it may generate. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.TP 18
\fIcode\fR
.NL
Indicates to the compiler a feature set that it may target, including
which instruction sets it may generate. Many of the following descriptions
refer to Intel(R) Streaming SIMD Extensions (Intel(R) SSE) and Supplemental
Streaming SIMD Extensions (SSSE). Possible values are: 
.RS
.TP 15
avx
May generate Intel(R) Advanced Vector
Extensions (Intel(R) AVX), SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3
instructions. 
.TP 15
sse4.2
May generate Intel(R) SSE4.2, SSE4.1, SSE3,
SSE2, SSE, and SSSE3 instructions. 
.TP 15
sse4.1
May generate Intel(R) SSE4.1, SSE3, SSE2, SSE,
and SSSE3 instructions. 
.TP 15
ssse3
May generate SSSE3 instructions and Intel(R)
SSE3, SSE2, and SSE instructions. 
.TP 15
sse3
May generate Intel(R) SSE3, SSE2, and SSE
instructions. 
.TP 15
sse2
May generate Intel(R) SSE2 and SSE
instructions. This value is only available on Linux systems. 
.TP 15
sse
This option has been deprecated; it is now
the same as specifying 
ia32. 
.TP 15
ia32
Generates x86/x87 generic code that is
compatible with IA\-32 architecture. Disables any default extended instruction
settings, and any previously set extended instruction settings. It also
disables all feature\-specific optimizations and instructions. This value is
only available on Linux* systems using IA\-32 architecture. 
.RE
.TP
\fBDefault:\fR 
.TP 18
Linux* systems: 
\-msse2 OS X* systems using IA\-32
architecture: 
\-msse3 OS X* systems using Intel(R) 64
architecture: 
\-mssse3
.NL
For more information on the default values, see
Arguments above. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler which features it may
target, including which instruction sets it may generate. 
.NL
.PP
Code generated with these options should execute on any
compatible, non\-Intel processor with support for the corresponding instruction
set. 
.NL
.PP
Options 
\-x and 
\-m are mutually exclusive. If both are specified, the compiler
uses the last one specified and generates a warning. 
.NL
.PP
Linux* systems: For compatibility with gcc, the compiler
allows the following options but they have no effect. You will get a warning
error, but the instructions associated with the name will not be generated. You
should use the suggested replacement options. 
.NL
.TP 18
gcc Compatibility Option (Linux*) 
.NL
Suggested Replacement Option 
.NL
.TP 18
\-mfma
.NL
\-march=core\-avx2
.NL
.TP 18
\-mbmi, 
\-mavx2, 
\-mlzcnt
.NL
\-march=core\-avx2
.NL
.TP 18
\-mmovbe
.NL
\-march=atom \-minstruction=movbe
.NL
.TP 18
\-mcrc32, 
\-maes, 
\-mpclmul, 
\-mpopcnt
.NL
\-march=corei7
.NL
.TP 18
\-mvzeroupper
.NL
\-march=corei7\-avx
.NL
.TP 18
\-mfsgsbase, 
\-mrdrnd, 
\-mf16c
.NL
\-march=core\-avx\-i
.NL
.PP
Many of the
above gcc options are not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner).
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None 
.NL
.RE
.TP
.B
\-M
.RS
.TP
Tells the compiler to generate makefile
dependency lines for each source file.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate makefile dependency
lines for each source file.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate makefile
dependency lines for each source file, based on the #include lines found in the
source file. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-m32
.TP
.B
\-m64
.RS
.TP
Tells the compiler to generate code for a
specific architecture.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler\[aq]s behavior depends on the host system.
.TP
\fBDescription:\fR 
.PP
These options tell the compiler to generate code for a
specific architecture.
.NL
.TP 18
\fBOption
\fR
.NL
.NL
\fBDescription
\fR
.NL
.NL
.TP 18
\-m32 or 
/Qm32
.NL
Tells the compiler to generate code for IA\-32
architecture.
.NL
.TP 18
\-m64 or 
/Qm64
.NL
Tells the compiler to generate code for Intel(R)
64 architecture.
.NL
.PP
The 
\-m32 and 
\-m64 options are the same
as OS X* options 
\-arch i386 and 
\-arch x86_64,
respectively. These options are not related to the Intel(R) 
C++ 
Compiler option 
arch.
.NL
.PP
On Linux* systems, these options are provided for
compatibility with gcc. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-m80387
.TP
.B
\-mno\-80387
.RS
.TP
Specifies whether the compiler can use
x87 instructions. 
.NL
.TP
\fBArchitectures:\fR  Not available on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology 
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-m80387
.NL
The compiler may use x87 instructions. 
.TP
\fBDescription:\fR 
.PP
This option specifies whether the compiler can use x87 instructions. 
.NL
.PP
If you specify option 
\-mno\-80387, it prevents the compiler from using x87
instructions. If the compiler is forced to generate x87 instructions, it issues
an error message. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
\-m[no\-]x87 
.NL
.RE
.TP
.B
\-malign\-double
.TP
.B
\-mno\-align\-double
.RS
.TP
Determines whether double, long double, and long long types are naturally aligned.  This option is equivalent to specifying option align.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on IA\-32 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-mno\-align\-double
.NL
Types are aligned according to the gcc model, which means they are aligned to 4\-byte boundaries.
.TP
\fBDescription:\fR 
.PP
For details, see the \fIalign\fR option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-map\-opts (L*X only)
.RS
.TP
Maps one or more compiler options to their equivalent on a different operating system.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No platform mappings are performed.
.TP
\fBDescription:\fR 
.PP
This option maps one or more compiler options to their equivalent on a different operating system. The result is output to stdout. 
.NL
.PP
On Windows systems, the options you provide are presumed to be Windows options, so the options that are output to stdout will be Linux equivalents.
.NL
.PP
On Linux systems, the options you provide are presumed to be Linux options, so the options that are output to stdout will be Windows equivalents.
.NL
.PP
The tool can be invoked from the compiler command line or it can be used directly. 
.NL
.PP
No compilation is performed when the option mapping tool is used.
.NL
.PP
This option is useful if you have both compilers and want to convert scripts or makefiles.
.NL
.PP
.B NOTE:
Compiler options are mapped to their equivalent on the architecture you are using. For example, if you are using a processor with IA\-32 architecture, you will only see equivalent options that are available on processors with IA\-32 architecture.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-march=processor
.RS
.TP
Tells the compiler to generate code for
processors that support certain features. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.TP 18
\fIprocessor\fR
.NL
Indicates to the compiler the code it may generate.
Possible values are: 
.RS
.TP 15
generic
Generates code for the compiler\[aq]s default
behavior. 
.TP 15
broadwell haswell 
ivybridge 
knl 
sandybridge silvermont skylake
Optimizes code for processors
that support the specified Intel(R) microarchitecture code name. 
.IP
Keywords 
knl and 
silvermont are only available on Linux*
systems. 
.TP 15
core\-avx2
Generates code for processors that support
Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2), Intel(R) AVX, SSE4.2, SSE4.1,
SSE3, SSE2, SSE, and SSSE3 instructions. 
.TP 15
core\-avx\-i
Generates code for processors that support 
Float\-16 conversion
instructions and 
the RDRND instruction, Intel(R) Advanced Vector Extensions
(Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions. 
.TP 15
corei7\-avx
Generates code for processors that support
Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3,
SSE2, SSE, and SSSE3 instructions. 
.TP 15
corei7
Generates code for processors that support
Intel(R) SSE4 Efficient Accelerated String and Text Processing instructions. May
also generate code for Intel(R) SSE4 Vectorizing Compiler and Media Accelerator,
Intel(R) SSE3, SSE2, SSE, and SSSE3 instructions. 
.TP 15
atom
Generates code for processors that support
MOVBE instructions, depending on the setting of option 
\-minstruction (Linux* and OS X*) or
/Qinstruction (Windows*). May also generate code for SSSE3
instructions and Intel(R) SSE3, SSE2, and SSE instructions. 
.TP 15
core2
Generates code for the Intel(R) Core(TM) 2
processor family. 
.TP 15
pentium\-mmx
Generates for Intel(R) Pentium(R) with MMX
technology. 
.TP 15
pentiumpro
Generates for Intel(R) Pentium(R) Pro, Intel
Pentium II, and Intel Pentium III processors. 
.TP 15
pentium4m
Generates for Intel(R) Pentium(R) 4 processors
with MMX technology. 
.TP 15
pentium\-m pentium4 pentium3 pentium
Generates code for Intel(R) Pentium(R)
processors. Value 
pentium3 is only
available on Linux* systems. 
.RE
.TP
\fBDefault:\fR 
.TP 18
pentium4
.NL
If no architecture option is specified, value 
pentium4 is used by the
compiler to generate code. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate code for
processors that support certain features. 
.NL
.PP
If you specify both the 
\-ax and 
\-march options, the compiler will not generate Intel\-specific
instructions. 
.NL
.PP
Specifying 
\-march=pentium4 sets 
\-mtune=pentium4. 
.NL
.PP
For compatibility, a number of historical 
\fIprocessor\fR values are
also supported, but the generated code will not differ from the default. 
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
\-march=pentium3
.NL
Linux: 
\-xSSE
.IP
OS X: None 
.TP 18
\-march=pentium4 \-march=pentium\-m
.NL
Linux: 
\-xSSE2
.IP
OS X: None 
.TP 18
\-march=core2
.NL
Linux: 
\-xSSSE3
.IP
OS X: None 
.RE
.TP
.B
\-masm=dialect (L*X only)
.RS
.TP
Tells the compiler to generate the assembler output file using a selected dialect. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdialect\fR
.NL
Is the dialect to use for the assembler output file.  Possible values are:
.RS
.TP 15
att
Tells the compiler to generate the assembler output file using AT&T* syntax.
.TP 15
intel
Tells the compiler to generate the assembler output file using Intel syntax.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-masm=att
.NL
The compiler generates the assembler output file using AT&T* syntax.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate the assembler output file using a selected dialect.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mcmodel=mem_model (L*X only)
.RS
.TP
Tells the compiler to use a specific memory model to generate code and store data.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fImem_model\fR
.NL
Is the memory model to use. Possible values are:
.RS
.TP 15
small
Tells the compiler to restrict code and data to the first 2GB of address space. All accesses of code and data can be done with Instruction Pointer (IP)\-relative addressing.
.TP 15
medium
Tells the compiler to restrict code to the first 2GB; it places no memory restriction on data. Accesses of code can be done with IP\-relative addressing, but accesses of data must be done with absolute addressing.
.TP 15
large
Places no memory restriction on code or data. All accesses of code and data must be done with absolute addressing.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-mcmodel=small
.NL
On systems using Intel(R) 64 architecture, the compiler restricts code and data to the first 2GB of address space. Instruction Pointer (IP)\-relative addressing can be used to access code and data.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use a specific memory model to generate code and store data. It can affect code size and performance. If your program has global and static data with a total size smaller than 2GB, \-mcmodel=small is sufficient. Global and static data larger than 2GB requires\-mcmodel=medium or \-mcmodel=large. 
Allocation of memory larger than 2GB can be done with any setting of \-mcmodel.
.NL
.PP
IP\-relative addressing requires only 32 bits, whereas absolute addressing requires 64\-bits. IP\-relative addressing is somewhat faster. So, the small memory model has the least impact on performance.
.NL
.PP
.B NOTE:
When you specify option \-mcmodel=medium or \-mcmodel=large, it sets option \-shared\-intel. This ensures that the correct dynamic versions of the Intel run\-time libraries are used.
.PP
If you specify option \-static\-intel while \-mcmodel=medium or \-mcmodel=large is set, an error will be displayed.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-MD
.RS
.TP
Preprocess and compile, generating output
file containing dependency information ending with extension .d. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate dependency
information.
.TP
\fBDescription:\fR 
.PP
Preprocess and compile, generating output file containing
dependency information ending with extension .d. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.RS
.TP
Tells the linker to search for unresolved references in a multithreaded, dynamic\-link run\-time library.  
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The linker searches for unresolved references in a single\-threaded, static run\-time library.
.TP
\fBDescription:\fR 
.PP
This option tells the linker to search for unresolved references in a multithreaded, dynamic\-link (DLL) run\-time library.  You can also specify /MDd, where d indicates a debug version.
.NL
.PP
This option is processed by the compiler, which adds directives to the compiled object file that are processed by the linker.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mdynamic\-no\-pic (M*X only)
.RS
.TP
Generates code that is not
position\-independent but has position\-independent external references. 
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on Intel(R) 64 architecture targeting Intel(R)
MIC Architecture
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
All references are generated as position
independent. 
.TP
\fBDescription:\fR 
.PP
This option generates code that is not
position\-independent but has position\-independent external references. 
.NL
.PP
The generated code is suitable for building executables,
but it is not suitable for building shared libraries. 
.NL
.PP
This option may reduce code size and produce more
efficient code. It overrides the 
\-fpic compiler option. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-MFfilename
.RS
.TP
Tells the compiler to generate makefile
dependency information in a file.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file where the makefile
dependency information should be placed.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate makefile dependency
information in files.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate makefile
dependency information in a file. To use this option, you must also specify 
/QM or 
/QMM. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-MG
.RS
.TP
Tells the compiler to generate makefile
dependency lines for each source file.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate makefile dependency
information in files.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate makefile
dependency lines for each source file. It is similar to 
/QM, but it treats
missing header files as generated files. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mgpu\-arch=arch (L*X only)
.RS
.TP
Builds the offload code for graphics to
run on a particular version of the processor graphics, as specified by the
option value. It causes the linker to invoke a compiler that translates the
virtual Instruction Set Architecture (ISA) of the offload executable into the
native ISA for the version of the processor graphics specified. This option
only applies to Intel(R) Graphics Technology. 
.NL
.TP
\fBArchitecture Restrictions:\fR  Only available on IA\-32 architecture targeting Intel(R)
Graphics Technology, and on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology 
.TP
\fBArguments:\fR 
.TP 18
arch
.NL
Indicates to the compiler the target ISA for the compilation.
Possible values are: 
.RS
.TP 15
skylake
May generate instructions for
the graphics processor that is on Intel(R) microarchitecture code name Skylake. 
.TP 15
broxton
May generate instructions for
the graphics processor that is on Intel(R) microarchitecture code name Broxton. 
.TP 15
broadwell
May generate instructions for the graphics
processor that is on Intel(R) microarchitecture code name Broadwell. 
.TP 15
haswell
May generate instructions for the graphics
processor that is on Intel(R) microarchitecture code name Haswell. 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler generates virtual ISA instructions.
At runtime, the virtual instructions must be compiled into native ISA code for
the platform on which the executable is to run. 
.TP
\fBDescription:\fR 
.PP
This option builds the offload code for graphics to runon
a particular version of the processor graphics, as specified by the option
value. It causes the linker to invoke a compiler that translates the virtual
Instruction Set Architecture (ISA) of the offload executable into the native
ISA for the version of the processor graphics specified. For information about
applicable operating systems for Intel(R) Graphics Technology, see Overview:
Intel(R) Graphics Technology. 
.NL
.PP
When this option is not used, the executable is based on
the virtual ISA, which is portable across platforms. In this case, the virtual
ISA is compiled at runtime by invoking the "Just\-In\-Time" compiler. 
.NL
.PP
This option should improve performance of native code
generation for graphics applications because the compilation will be performed
at link time instead of at runtime. It may also help you avoid some overhead
costs associated with compiling virtual ISA code at runtime. 
.NL
.PP
The following shows the current mapping table for the
possible ISA target values: 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-mgpu\-asm\-dump[=filename] (L*X only)
.RS
.TP
Tells the compiler to generate a native
assembly listing for the processor graphics code to be offloaded. This option
only applies to Intel(R) Graphics Technology. On IA\-32 architecture, you can only
specify this option on Windows*. 
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on IA\-32 architecture targeting Intel(R)
Graphics Technology, and on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology 
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
(Optional) Is the name of the output file in which to place the
native assembly listing. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No native assembly listing is generated for the
processor graphics code to be offloaded. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate a native assembly listing for the
processor graphics code to be offloaded. 
.NL
.PP
The assembly listing can only be generated when native code is generated at
link time. Both the assembly listing and the target executable are generated. 
.NL
.PP
To use this option, you must also specify option 
\-mgpu\-arch (Linux*) or 
/Qgpu\-arch (Windows*). 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-minstruction=[no]movbe
.RS
.TP
Determines whether MOVBE instructions are
generated for certain Intel processors.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
–minstruction=nomovbe 
.NL
The compiler does not generate MOVBE instructions
for Intel(R) Atom(TM) processors.
.TP
\fBDescription:\fR 
.PP
This option determines whether MOVBE instructions are
generated for Intel(R) Atom(TM) processors. To use this option, you must also
specify 
[Q]xATOM_SSSE3 or 
[Q]xATOM_SSE4.2.
.NL
.PP
If 
\-minstruction=movbe or 
/Qinstruction:movbe is
specified, the following occurs:
.NL
.IP \(bu 2
MOVBE instructions are generated that are specific to
the Intel(R) Atom(TM) processor.
.IP \(bu 2
Generated executables can only be run on Intel(R) Atom(TM)
processors or processors that support Supplemental Streaming SIMD Extensions 3
(Intel(R) SSSE3) or Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) and
MOVBE.
.PP
If 
\-minstruction=nomovbe or 
/Qinstruction:nomovbe is
specified, the following occurs:
.NL
.IP \(bu 2
The compiler optimizes code for the Intel(R) Atom(TM)
processor, but it does not generate MOVBE instructions.
.IP \(bu 2
Generated executables can be run on non\-Intel(R) Atom(TM)
processors that support Intel(R) SSE3 or Intel(R) SSE4.2.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mkl[=lib]
.RS
.TP
Tells the compiler to link to certain
libraries in the Intel(R) Math Kernel Library (Intel(R) MKL). On Windows systems,
you must specify this option at compile time. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIlib\fR
.NL
Indicates which Intel(R) MKL library files should be
linked. Possible values are: 
.RS
.TP 15
parallel
Tells the compiler to link using the threaded
libraries in the Intel(R) MKL. This is the default if the option is specified
with no 
\fIlib\fR. 
.TP 15
sequential
Tells the compiler to link using the
sequential libraries in the Intel(R) MKL. 
.TP 15
cluster
Tells the compiler to link using the
cluster\-specific libraries and the sequential libraries in the Intel(R) MKL. 
Cluster\-specific libraries are
not available for OS X*.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not link to the Intel(R) MKL. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to link to certain
libraries in the Intel(R) Math Kernel Library (Intel(R) MKL). 
.NL
.PP
On Linux* and OS X* systems, dynamic linking is the
default when you specify 
\-mkl. To link with Intel(R) MKL statically, you must specify: 
.NL
.PP
\-mkl \-static\-intel
.PP
.PP
On Windows* systems, static linking is the default when
you specify 
/Qmkl. To link with Intel(R) MKL dynamically, you must specify: 
.NL
.PP
/Qmkl /MD 
.PP
.PP
For more information about using MKL libraries, see the
article in Intel(R) Developer Zone titled: 
Intel(R) Math Kernel Library Link Line Advisor, which is located
in https://software.intel.com/en\-us/articles/intel\-mkl\-link\-line\-advisor . 
.NL
.PP
.B NOTE:
On Windows* systems, this option adds directives to the
compiled code, which the linker then reads without further input from the
driver. On Linux* and OS X systems, the driver must add the library names
explicitly to the link command. 
.PP
.B NOTE:
If you specify option 
[Q]mkl or 
[Q]mkl=parallel, and you also specify option 
[Q]tbb, the compiler links to the standard threaded version
of the Intel(R) MKL. However, if you specify 
[Q]mkl or 
[Q]mkl=parallel, and you also specify option 
[Q]tbb and option 
[q or Q]openmp, the compiler links to the OpenMP* threaded
version of the Intel(R) MKL. 
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-mlong\-double\-n (L*X only)
.RS
.TP
Lets you override the default
configuration of the long double data type. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology 
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Specifies the size of the long double data type.
Possible values are: 
.RS
.TP 15
64
Specifies that the size of the long double
data type is 64 bits. 
.TP 15
80
Specifies that the size of the long double
data type is 80 bits. This is the default. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-mlong\-double\-80
.NL
Specifies that the size of the long double data
type is 80 bits. 
.TP
\fBDescription:\fR 
.PP
This option lets you override the default configuration of the long double
data type. 
.NL
.PP
When you specify 
\-mlong\-double\-64, the size of the long double data type is 8
bytes and the macro __LONG_DOUBLE_64__ is defined. 
.NL
.PP
When you specify 
\-mlong\-double\-80, the size of the long double data type is 12
bytes on IA\-32 architecture and 16 bytes on Intel(R) 64 architecture. 
.NL
.PP
This option has no effect on floating\-point significand precision. That must
be specified by using the 
\-pc64 or 
\-pc80 option. 
.NL
.PP
Note that this option has no effect when you pass arguments. When you pass
arguments, the 64\-bit long double data type is treated as the double data type
and it is always 64\-bit. 
.NL
.PP
Remember to include the math.h and complex.h header files when you use this
option. 
.NL
.PP
The following restrictions apply to this option: 
.NL
.IP \(bu 2
__bultin_* functions using the long double type
should not be used in the non\-default mode with Intel compiler libraries. 
.IP \(bu 2
long double functions from the \[aq]std\[aq] namespace should
not be called from C++ sources when the non\-default mode is set. 
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None 
.NL
.PP
Windows: 
/Qlong\-double
.NL
.RE
.TP
.B
\-MM
.RS
.TP
Tells the compiler to generate makefile
dependency lines for each source file. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology 
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate makefile dependency
information in files. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate makefile
dependency lines for each source file. It is similar to 
/QM, but it does not
include system header files. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-MMD
.RS
.TP
Tells the compiler to generate an output
file containing dependency information. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology 
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate an output file
containing dependency information. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to preprocess and compile
a file, then generate an output file (with extension 
.d) containing dependency
information. 
.NL
.PP
It is similar to 
/QMD, but it does not
include system header files. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-mmic 
(L*X only)
.RS
.TP
Builds an application that runs natively
on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner).
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler builds a heterogeneous application.
You must specify this option to build an application that runs natively on
Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner).
.TP
\fBDescription:\fR 
.PP
This option enables the cross compiler to build an
application that runs natively on Intel(R) MIC Architecture. It is only available
on the command line. 
.NL
.PP
When you use this option, the compiler defines the macro 
__MIC__. 
.NL
.PP
.B NOTE:
When you specify Windows* option 
/Qmic, you must specify any other options on the command
line in the Linux* form. This is because all other options are passed directly
to the native compiler for Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
which is a Windows*\-hosted Linux* compiler. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-momit\-leaf\-frame\-pointer
.TP
.B
\-mno\-omit\-leaf\-frame\-pointer
.RS
.TP
Determines whether the frame pointer is
omitted or kept in leaf functions. 
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on IA\-32 architecture targeting Intel(R)
Graphics Technology or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology 
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
Varies
.NL
If you specify option 
\-fomit\-frame\-pointer (or it is set by default), the
default is 
\-momit\-leaf\-frame\-pointer. If you specify option 
\-fno\-omit\-frame\-pointer, the default is 
\-mno\-omit\-leaf\-frame\-pointer. 
.IP
.TP
\fBDescription:\fR 
.PP
This option determines whether the frame pointer is omitted or kept in leaf
functions. It is related to option 
\-f[no\-]omit\-frame\-pointer and the setting for that option has
an effect on this option. 
.NL
.PP
Consider the following option combinations: 
.NL
.TP 18
\fBOption Combination 
\fR
.NL
.NL
\fBResult 
\fR
.NL
.NL
.TP 18
\-fomit\-frame\-pointer \-momit\-leaf\-frame\-pointer
.TP 18
or 
.TP 18
\-fomit\-frame\-pointer
\-mno\-omit\-leaf\-frame\-pointer
.NL
Both combinations are the same as specifying 
\-fomit\-frame\-pointer. Frame pointers are omitted for
all routines. 
.NL
.TP 18
\-fno\-omit\-frame\-pointer \-momit\-leaf\-frame\-pointer
.NL
In this case, the frame pointer is omitted for leaf routines, but
other routines will keep the frame pointer. 
.TP 18
This is the intended effect of option 
\-momit\-leaf\-frame\-pointer. 
.NL
.TP 18
\-fno\-omit\-frame\-pointer
\-mno\-omit\-leaf\-frame\-pointer
.NL
In this case, 
\-mno\-omit\-leaf\-frame\-pointer is ignored since 
\-fno\-omit\-frame\-pointer retains frame pointers in
all routines . 
.TP 18
This combination is the same as specifying 
\-fno\-omit\-frame\-pointer. 
.NL
.PP
This option is provided for compatibility with gcc. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-MP
.RS
.TP
Tells the compiler to add a phony target for each dependency. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate dependency information unless it is told to do so.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to add a phony target for each dependency.
.NL
.PP
Note that this option is not related to Windows* option \fI/MP\fR.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mp1
.RS
.TP
Improves floating\-point precision and
consistency. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler provides good accuracy and run\-time
performance at the expense of less consistent floating\-point results. 
.TP
\fBDescription:\fR 
.PP
This option improves floating\-point consistency. It
ensures the out\-of\-range check of operands of transcendental functions and
improves the accuracy of floating\-point compares. 
.NL
.PP
This option prevents the compiler from performing
optimizations that change NaN comparison semantics and causes all values to be
truncated to declared precision before they are used in comparisons. It also
causes the compiler to use library routines that give better precision results
compared to the X87 transcendental instructions. 
.NL
.PP
This option disables fewer optimizations and has less
impact on performance than option 
\-fp\-model precise (Linux*
and OS X*) or option 
/fp:precise (Windows*). 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-MQtarget
.RS
.TP
Changes the default target rule for
dependency generation. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology 
.TP
\fBArguments:\fR 
.TP 18
\fItarget\fR
.NL
Is the target rule to use. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default target rule applies to dependency
generation. 
.TP
\fBDescription:\fR 
.PP
This option changes the default target rule for
dependency generation. It is similar to 
\-MT, but quotes special
Make characters. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-mregparm=n
.RS
.TP
Control the number registers used to pass integer arguments.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on IA\-32 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Specifies the number of registers to use when passing integer arguments. You can specify at most 3 registers. If you specify a nonzero value for \fIn\fR, you must build all modules, including startup modules, and all libraries, including system libraries, with the same value.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not use registers to pass arguments.
.TP
\fBDescription:\fR 
.PP
Control the number registers used to pass integer arguments.  This option is provided for compatibility with gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mregparm\-version=n
.RS
.TP
Determines which version of the Application Binary Interface (ABI) is used for the regparm parameter passing convention.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Specifies the ABI implementation to use. Possible values are:
.RS
.TP 15
0
Tells the compiler to use the most recent ABI implementation.
.TP 15
1
Tells the compiler to use the ABI implementation that is compatible with gcc 3.4.6 and icc 15.0.
.RE
.TP
\fBDefault:\fR 
.TP 18
0
.NL
The compiler uses the most recent ABI implementation.
.TP
\fBDescription:\fR 
.PP
This option determines which version of the Application Binary Interface (ABI) is used for the regparm parameter passing convention. This option allows compatibility with previous versions of gcc and icc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-MTtarget
.RS
.TP
Changes the default target rule for
dependency generation. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.TP 18
\fItarget\fR
.NL
Is the target rule to use.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default target rule applies to dependency
generation.
.TP
\fBDescription:\fR 
.PP
This option changes the default target rule for
dependency generation.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mtune=processor
.RS
.TP
Performs optimizations for specific
processors. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.TP 18
\fIprocessor\fR
.NL
Is the processor for which the compiler should
perform optimizations. Possible values are: 
.RS
.TP 15
generic
Optimizes code for the compiler\[aq]s default
behavior. 
.TP 15
broadwell haswell 
ivybridge 
knl 
sandybridge silvermont skylake
Optimizes code for processors
that support the specified Intel(R) microarchitecture code name. 
.IP
Keywords 
knl and 
silvermont are only available on Windows* and
Linux* systems. 
.TP 15
core\-avx2
Optimizes code for processors that support
Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2), Intel(R) AVX, SSE4.2, SSE4.1,
SSE3, SSE2, SSE, and SSSE3 instructions. 
.TP 15
core\-avx\-i
Optimizes code for processors that support 
Float\-16 conversion
instructions and 
the RDRND instruction, Intel(R) Advanced Vector Extensions
(Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions. 
.TP 15
corei7\-avx
Optimizes code for processors that support
Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3,
SSE2, SSE, and SSSE3 instructions. 
.TP 15
corei7
Optimizes code for processors that support
Intel(R) SSE4 Efficient Accelerated String and Text Processing instructions. May
also generate code for Intel(R) SSE4 Vectorizing Compiler and Media Accelerator,
Intel(R) SSE3, SSE2, SSE, and SSSE3 instructions. 
.TP 15
atom
Optimizes code for processors that support
MOVBE instructions, depending on the setting of option 
\-minstruction (Linux* and OS X*) or
/Qinstruction (Windows*). May also generate code for SSSE3
instructions and Intel(R) SSE3, SSE2, and SSE instructions. 
.TP 15
core2
Optimizes for the Intel(R) Core(TM) 2 processor
family, including support for MMX(TM), Intel(R) SSE, SSE2, SSE3 and SSSE3
instruction sets. 
.TP 15
pentium\-mmx
Optimizes for Intel(R) Pentium(R) with MMX
technology. 
.TP 15
pentiumpro
Optimizes for Intel(R) Pentium(R) Pro, Intel
Pentium II, and Intel Pentium III processors. 
.TP 15
pentium4m
Optimizes for Intel(R) Pentium(R) 4 processors
with MMX technology. 
.TP 15
pentium\-m pentium4 pentium3 pentium
Optimizes code for Intel(R) Pentium(R)
processors. Value 
pentium3 is only
available on Linux* systems. 
.RE
.TP
\fBDefault:\fR 
.TP 18
generic
.NL
Code is generated for the compiler\[aq]s default
behavior. 
.TP
\fBDescription:\fR 
.PP
This option performs optimizations for specific
processors. 
.NL
.PP
The resulting executable is backwards compatible and
generated code is optimized for specific processors. For example, code
generated with 
\-mtune=pentium4 will run
correctly on Core2 processors, but it might not run as fast as if it had been
generated using 
\-mtune=core2. 
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
\-mtune
.NL
Linux: 
\-mcpu (this is a
deprecated option) 
.IP
OS X: None 
.RE
.TP
.B
\-multibyte\-chars
.TP
.B
\-no\-multibyte\-chars
.RS
.TP
Determines whether multi\-byte characters
are supported.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-multibyte\-chars
.NL
Multi\-byte characters are supported.
.TP
\fBDescription:\fR 
.PP
This option determines whether multi\-byte characters are
supported.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-multiple\-processes[=n]
.RS
.TP
Creates multiple processes that can be
used to compile large numbers of source files at the same time. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the maximum number of processes that the
compiler should create. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
A single process is used to compile source files. 
.TP
\fBDescription:\fR 
.PP
This option creates multiple processes that can be used
to compile large numbers of source files at the same time. It can improve
performance by reducing the time it takes to compile source files on the
command line. 
.NL
.PP
This option causes the compiler to create one or more
copies of itself, each in a separate process. These copies simultaneously
compile the source files. 
.NL
.PP
If 
\fIn\fR is not specified
for this option, the default value is as follows: 
.NL
.IP \(bu 2
On Windows* systems, the value is based on the
setting of the NUMBER_OF_PROCESSORS environment variable. 
.IP \(bu 2
On Linux* and OS X* systems, the value is 2. 
.PP
This option applies to compilations, but not to linking
or link\-time code generation. 
.NL
.PP
To
override default heuristics, specify option 
/MP\-force. It ensures that 
\fIn\fR will be the maximum
number of processes created regardless of other heuristics that may limit the
number of processes. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-no\-bss\-init
.RS
.TP
Tells the compiler to place in the DATA section any uninitialized variables and explicitly zero\-initialized variables.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Uninitialized variables and explicitly zero\-initialized variables are placed in the BSS section.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to place in the DATA section any uninitialized variables and explicitly zero\-initialized variables.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-no\-libgcc (L*X only)
.RS
.TP
Prevents the linking of  certain gcc\-specific libraries.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
This option prevents the linking of  certain gcc\-specific libraries.
.NL
.PP
This option is not recommended for general use.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nodefaultlibs
.RS
.TP
Prevents the compiler from using standard libraries when linking.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The standard libraries are linked.
.TP
\fBDescription:\fR 
.PP
This option prevents the compiler from using standard libraries when linking.On Linux* systems,  it is provided for GNU compatibility.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nolib\-inline
.RS
.TP
Disables inline expansion of standard library or intrinsic functions.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler inlines many standard library and intrinsic functions.
.TP
\fBDescription:\fR 
.PP
This option disables inline expansion of standard library or intrinsic functions. It prevents the unexpected results that can arise from inline expansion of these functions.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nostartfiles
.RS
.TP
Prevents the compiler from using standard startup files when linking.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses standard startup files when linking.
.TP
\fBDescription:\fR 
.PP
This option prevents the compiler from using standard startup files when linking.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nostdinc++
.RS
.TP
Do not search for header files in the standard directories for C++, but search the other standard directories.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Do not search for header files in the standard directories for C++, but search the other standard directories.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nostdlib
.RS
.TP
Prevents the compiler from using standard libraries and startup files when linking.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses standard startup files and standard libraries when linking.
.TP
\fBDescription:\fR 
.PP
This option prevents the compiler from using standard libraries and startup files when linking. On Linux* systems, it is provided for GNU compatibility.
.NL
.PP
This option is not related to option \-stdlib.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-o
filename
.RS
.TP
Specifies the name for an output file. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name for the output file. The space before 
\fIfilename\fR is
optional. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses the default file name for an
output file. 
.TP
\fBDescription:\fR 
.PP
This option specifies the name for an output file as
follows: 
.NL
.IP \(bu 2
If 
\-c is specified, it
specifies the name of the generated object file. 
.IP \(bu 2
If 
\-S is specified, it
specifies the name of the generated assembly listing file. 
.IP \(bu 2
If 
\-P is specified,
it specifies the name of the generated preprocessor file. 
.PP
Otherwise, it specifies the name of the executable file. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None 
.NL
.PP
Windows: 
/Fe
.NL
.RE
.TP
.B
\-O[n]
.RS
.TP
Specifies the code optimization for
applications.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the optimization level. Possible values are 1,
2, or 3. On Linux* and OS X* systems, you can also specify 0.
.TP
\fBDefault:\fR 
.TP 18
O2
.NL
Optimizes for code speed. This default may change
depending on which other compiler options are specified. For details, see
below.
.TP
\fBDescription:\fR 
.PP
This option specifies the code optimization for
applications.
.NL
.TP 18
\fBOption
\fR
.NL
.NL
\fBDescription
\fR
.NL
.NL
.TP 18
O (Linux* and OS X*)
.NL
This is the same as specifying 
O2.
.NL
.TP 18
O0 (Linux and OS X)
.NL
Disables all optimizations. 
.TP 18
This option may set other options. This is
determined by the compiler, depending on which operating system and
architecture you are using. The options that are set may change from release to
release.
.NL
.TP 18
O1
.NL
Enables optimizations for speed and disables
some optimizations that increase code size and affect speed. To limit code size, this option:
.RS
.IP \(bu 2
Enables global optimization; this includes
data\-flow analysis, code motion, strength reduction and test replacement,
split\-lifetime analysis, and instruction scheduling.
.IP \(bu 2
Disables inlining of some intrinsics.
.RE
.TP 18
This option may set other options. This is
determined by the compiler, depending on which operating system and
architecture you are using. The options that are set may change from release to
release.
.TP 18
The 
O1 option may improve performance for applications
with very large code size, many branches, and execution time not dominated by
code within loops.
.NL
.TP 18
O2
.NL
Enables optimizations for speed. This is the
generally recommended optimization level.  Vectorization is enabled at 
O2 and higher levels.
.TP 18
On systems using IA\-32 architecture: Some
basic loop optimizations such as Distribution, Predicate Opt, Interchange,
multi\-versioning, and scalar replacements are performed.
.TP 18
This option also enables:
.RS
.IP \(bu 2
Inlining of intrinsics
.IP \(bu 2
Intra\-file interprocedural optimization,
which includes:
.RS
.IP \(bu 2
inlining
.IP \(bu 2
constant propagation
.IP \(bu 2
forward substitution
.IP \(bu 2
routine attribute propagation
.IP \(bu 2
variable address\-taken analysis
.IP \(bu 2
dead static function elimination
.IP \(bu 2
removal of unreferenced variables
.RE
.IP \(bu 2
The following capabilities for performance
gain:
.RS
.IP \(bu 2
constant propagation
.IP \(bu 2
copy propagation
.IP \(bu 2
dead\-code elimination
.IP \(bu 2
global register allocation
.IP \(bu 2
global instruction scheduling and
control speculation
.IP \(bu 2
loop unrolling
.IP \(bu 2
optimized code selection
.IP \(bu 2
partial redundancy elimination
.IP \(bu 2
strength reduction/induction variable
simplification
.IP \(bu 2
variable renaming
.IP \(bu 2
exception handling optimizations
.IP \(bu 2
tail recursions
.IP \(bu 2
peephole optimizations
.IP \(bu 2
structure assignment lowering and
optimizations
.IP \(bu 2
dead store elimination
.RE
.RE
.TP 18
This option may set other options, especially
options that optimize for code speed. This is determined by the compiler,
depending on which operating system and architecture you are using. The options
that are set may change from release to release.
.TP 18
On Linux systems, the 
\-debug inline\-debug\-info option will be enabled by
default if you compile with optimizations (option 
\-O2 or higher) and debugging is enabled (option 
\-g).
.TP 18
Many routines in the shared libraries are more
highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.NL
.TP 18
O3
.NL
Performs 
O2
optimizations and enables more aggressive loop transformations such as Fusion,
Block\-Unroll\-and\-Jam, and collapsing IF statements.
.TP 18
This option may set other options. This is
determined by the compiler, depending on which operating system and
architecture you are using. The options that are set may change from release to
release.
.TP 18
When 
O3 is used with
options 
\-ax or 
\-x (Linux) or
with options 
/Qax or 
/Qx (Windows),
the compiler performs more aggressive data dependency analysis than for 
O2, which may
result in longer compilation times.
.TP 18
The 
O3
optimizations may not cause higher performance unless loop and memory access
transformations take place. The optimizations may slow down code in some cases
compared to 
O2
optimizations.
.TP 18
The 
O3 option is
recommended for applications that have loops that heavily use floating\-point
calculations and process large data sets. 
.TP 18
Many routines in the shared libraries are more
highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.NL
.PP
The last 
O option specified on the
command line takes precedence over any others.
.NL
.RE
.TP
.B
\-Ofast
.RS
.TP
Sets certain aggressive options to improve the speed of your application.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The aggressive optimizations that improve speed are not enabled.
.TP
\fBDescription:\fR 
.PP
This option improves the speed  of your
application.
.NL
.PP
It sets compiler options \-O3, \-no\-prec\-div, and \-fp\-model fast=2. 
.NL
.PP
On Linux* systems, this option is
provided for compatibility with gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Os
.RS
.TP
Enables optimizations that do not increase code size; it produces smaller code size than O2. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Optimizations are made for code speed. However, if O1 is specified, Os is the default.
.TP
\fBDescription:\fR 
.PP
This option enables optimizations that do not increase code size; it produces smaller code size than O2. It disables some optimizations that increase code size for a small speed benefit.
.NL
.PP
This option tells the compiler to favor transformations that reduce code size over transformations that produce maximum performance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-p
.RS
.TP
Compiles and links for function profiling
with gprof(1). 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Files are compiled and linked without profiling. 
.TP
\fBDescription:\fR 
.PP
This option compiles and links for function profiling
with gprof(1). 
.NL
.PP
When you specify this
option, inlining is disabled. However, you can override this by specifying
pragma forceinline, declspec forceinline (Windows*), attribute always_inline
(Linux* and OS X*), or a compiler option such as 
[Q]inline\-forceinline. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: 
\-qp (this is a deprecated
option) 
.NL
.RE
.TP
.B
\-P
.RS
.TP
Tells the compiler to stop the compilation process and write the results to a file. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Normal compilation is performed.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to stop the compilation process after C or C++ source files have been preprocessed and write the results to files named according to the compiler\[aq]s default file\-naming conventions.
.NL
.PP
On Linux systems, this option causes the preprocessor to expand your source module and direct the output to a .i file instead of stdout. Unlike the \-E option, the output from \-P on Linux does not include #line number directives. By default, the preprocessor creates the name of the output file using the prefix of the source file name with a .i extension. You can change this by using the \-o option. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-F
.NL
.PP
Windows: None
.NL
.RE
.TP
.B
\-parallel
.RS
.TP
Tells the auto\-parallelizer to generate
multithreaded code for loops that can be safely executed in parallel.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Multithreaded code is not generated for loops that
can be safely executed in parallel.
.TP
\fBDescription:\fR 
.PP
This option tells the auto\-parallelizer to generate
multithreaded code for loops that can be safely executed in parallel. 
.NL
.PP
To use this option, you must also specify option 
O2 or 
O3.
.NL
.PP
This option sets option 
[q or Q]opt\-matmul if option 
O3 is also specified.
.NL
.PP
.B NOTE:
On OS X* systems, when you enable automatic
parallelization, you must also set the DYLD_LIBRARY_PATH environment variable
within Xcode* or an error will be displayed.
.PP
.B NOTE:
Using this option enables parallelization for both
Intel(R) microprocessors and non\-Intel microprocessors. The resulting executable
may get additional performance gain on Intel microprocessors than on non\-Intel
microprocessors. The parallelization can also be affected by certain options,
such as 
/arch or 
/Qx (Windows*) or 
\-m or 
\-x (Linux* and OS X).
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-parallel\-source\-info[=n]
.TP
.B
\-no\-parallel\-source\-info
.RS
.TP
Enables or disables source location
emission when OpenMP* or auto\-parallelism code is generated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of source location emission. Possible
values are:
.RS
.TP 15
0
Disables the emission of source location
information when OpenMP* code or auto\-parallelism code is generated. This is
the same as specifying \-no\-parallel\-source\-info (Linux* and OS
X*) or /Qparallel\-source\-info\- (Windows*).
.TP 15
1
Tells the compiler to emit routine name and
line information. This is the same as specifying 
[Q]parallel\-source\-info with no 
\fIn\fR.
.TP 15
2
Tells the compiler to emit path, file,
routine name, and line information.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-parallel\-source\-info=1 
.NL
When OpenMP* code or auto\-parallelism code is
generated, the routine name and line information is emitted.
.TP
\fBDescription:\fR 
.PP
This option enables or disables source location emission when OpenMP code or
auto\-parallelism code is generated. It also lets you set the level of emission.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-affinity=[modifier,...]type[,permute][,offset] (L*X only)
.RS
.TP
Specifies thread affinity.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fImodifier\fR
.NL
Is one of the following values:
granularity={fine|thread|core}, [no]respect, [no]verbose, [no]warnings, proclist=proc_list.
The default is granularity=core, respect, and noverbose. 
.TP 18
\fItype\fR
.NL
Indicates the thread affinity. This argument is required and must be one of the following values: 
compact, disabled, explicit, none, scatter, logical, physical.  The default is none.
Values logical and physical are deprecated. Use compact and scatter, respectively, with no \fIpermute\fR value.
.TP 18
\fIpermute\fR
.NL
Is a positive integer. You cannot use this argument with \fItype\fR setting explicit, none, or disabled. The default is 0.
.TP 18
\fIoffset\fR
.NL
Is a positive integer. You cannot use this argument with \fItype\fR setting explicit, none, or disabled. The default is 0.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The thread affinity is determined by the run\-time environment.
.TP
\fBDescription:\fR 
.PP
This option specifies thread affinity, which binds threads to physical processing units. It has the same effect as environment variable KMP_AFFINITY.
.NL
.PP
This option overrides the environment variable when both are specified. 
.NL
.PP
This option only has an effect if the following is true:
.NL
.IP \(bu 2
You have specified option [Q]parallel or option [q or Q]openmp (or both).
.IP \(bu 2
You are compiling the main program.
.PP
.B NOTE:
This option may behave differently on Intel(R) microprocessors than on non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-num\-threads=n
.RS
.TP
Specifies the number of threads to use in a parallel region.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the number of threads to use. It must be a positive integer.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The number of threads to use is determined by the run\-time environment.
.TP
\fBDescription:\fR 
.PP
This option specifies the number of threads to
use in a parallel region. It has the same effect as environment
variable OMP_NUM_THREADS.
.NL
.PP
This option overrides the environment variable
when both are specified.
.NL
.PP
This option only has an effect if the following
is true:
.NL
.IP \(bu 2
You have specified option [Q]parallel or option [q or Q]openmp (or both).
.IP \(bu 2
You are compiling the
main program.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-runtime\-control[n]
.TP
.B
\-no\-par\-runtime\-control
.RS
.TP
Generates code to perform run\-time checks
for loops that have symbolic loop bounds. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a value denoting what kind of runtime checking
to perform. Possible values are: 
.RS
.TP 15
0
Performs no runtime check based on
auto\-parallelization. This is the same as specifying 
\-no\-par\-runtime\-control (Linux* and OS X*) or 
/Qpar\-runtime\-control\- (Windows*). 
.TP 15
1
Generates runtime check code under
conservative mode. This is the default if you do not specify 
\fIn\fR. 
.TP 15
2
Generates runtime check code under heuristic
mode. 
.TP 15
3
Generates runtime check code under
aggressive mode. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-no\-par\-runtime\-control 
.NL
The compiler uses default heuristics when checking
loops. 
.TP
\fBDescription:\fR 
.PP
This option generates code to perform run\-time checks for
loops that have symbolic loop bounds. 
.NL
.PP
If the granularity of a loop is greater than the
parallelization threshold, the loop will be executed in parallel. 
.NL
.PP
If you do not specify this option, the compiler may not
parallelize loops with symbolic loop bounds if the compile\-time granularity
estimation of a loop can not ensure it is beneficial to parallelize the loop. 
.NL
.PP
.B NOTE:
This option may behave differently on Intel(R)
microprocessors than on non\-Intel microprocessors. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-par\-schedule\-keyword[=n]
.RS
.TP
Lets you specify a scheduling algorithm for loop iterations. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies the scheduling algorithm or tuning method. Possible values are:
.RS
.TP 15
auto
Lets the compiler or run\-time system determine the scheduling algorithm.
.TP 15
static
Divides iterations into contiguous pieces.
.TP 15
static\-balanced
Divides iterations into even\-sized chunks.
.TP 15
static\-steal
Divides iterations into even\-sized chunks, but allows threads to steal parts of chunks
from neighboring threads. 
.TP 15
dynamic
Gets a set of iterations dynamically.
.TP 15
guided
Specifies a minimum number of iterations.
.TP 15
guided\-analytical
Divides iterations by using exponential distribution or dynamic distribution. 
.TP 15
runtime
Defers the scheduling decision until run time.
.RE
.TP 18
\fIn\fR
.NL
Is the size of the chunk or the number of iterations for each chunk. This setting
can only be specified for static, dynamic, and guided. For more information, see
the descriptions of each keyword below. 
.TP
\fBDefault:\fR 
.TP 18
static\-balanced
.NL
Iterations are divided into even\-sized chunks and the chunks are assigned to the
threads in the team in a round\-robin fashion in the order of the thread number.
.TP
\fBDescription:\fR 
.PP
This option lets you specify a scheduling algorithm for loop iterations.
It specifies how iterations are to be divided among the threads of the team. 
.NL
.PP
This option is only useful when specified with option [Q]parallel.
.NL
.PP
This option affects performance tuning and can provide better performance during
auto\-parallelization. It does nothing if it is used with option [q or Q]openmp.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
[Q]par\-schedule\-auto
.NL
Lets the compiler or run\-time system determine the scheduling algorithm. Any possible
mapping may occur for iterations to threads in the team.
.NL
.TP 18
[Q]par\-schedule\-static
.NL
Divides iterations into contiguous pieces (chunks) of size \fIn\fR. The chunks are assigned
to threads in the team in a round\-robin fashion in the order of the thread number.
Note that the last chunk to be assigned may have a smaller number of iterations.
.TP 18
If no \fIn\fR is specified, the iteration space is divided into chunks that are approximately
equal in size, and each thread is assigned at most one chunk.
.NL
.TP 18
[Q]par\-schedule\-static\-balanced
.NL
Divides iterations into even\-sized chunks. The chunks are assigned to the threads
in the team in a round\-robin fashion in the order of the thread number. 
.NL
.TP 18
[Q]par\-schedule\-static\-steal
.NL
Divides iterations into even\-sized chunks, but when a thread completes its chunk,
it can steal parts of chunks assigned to neighboring threads. 
.TP 18
Each thread keeps track
of L and U, which represent the lower and upper bounds of its chunks respectively.
Iterations are executed starting from the lower bound, and simultaneously, L is updated
to represent the new lower bound.
.NL
.TP 18
[Q]par\-schedule\-dynamic
.NL
Can be used to get a set of iterations dynamically. Assigns iterations to threads
in chunks as the threads request them. The thread executes the chunk of iterations,
then requests another chunk, until no chunks remain to be assigned.
.TP 18
As each thread finishes a piece of the iteration space, it dynamically gets the next
set of iterations. Each chunk contains \fIn\fR iterations, except for the last chunk to
be assigned, which may have fewer iterations. If no \fIn\fR is specified, the default is
1.
.NL
.TP 18
[Q]par\-schedule\-guided
.NL
Can be used to specify a minimum number of iterations. Assigns iterations to threads
in chunks as the threads request them. The thread executes the chunk of iterations,
then requests another chunk, until no chunks remain to be assigned. 
.TP 18
For a chunk of size 1, the size of each chunk is proportional to the number of unassigned
iterations divided by the number of threads, decreasing to 1.
.TP 18
For an \fIn\fR with value
\fIk\fR (greater than 1), the size of each chunk is determined in the same way with the
restriction that the chunks do not contain fewer than \fIk\fR iterations (except for the
last chunk to be assigned, which may have fewer than \fIk\fR iterations). If no \fIn\fR is specified,
the default is 1.
.NL
.TP 18
[Q]par\-schedule\-guided\-analytical
.NL
Divides iterations by using exponential distribution or dynamic distribution. The
method depends on run\-time implementation. Loop bounds are calculated with faster
synchronization and chunks are dynamically dispatched at run time by threads in the
team.
.NL
.TP 18
[Q]par\-schedule\-runtime
.NL
Defers the scheduling decision until run time. The scheduling algorithm and chunk
size are then taken from the setting of environment variable OMP_SCHEDULE.
.NL
.PP
.B NOTE:
This option may behave differently on Intel(R) microprocessors than on non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-threshold[n]
.RS
.TP
Sets a threshold for the auto\-parallelization of loops. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an integer whose value is the threshold for the auto\-parallelization of loops. Possible values are 0 through 100.
.IP
If \fIn\fR is 0, loops get auto\-parallelized always, regardless of computation work volume.
.IP
If \fIn\fR is 100, loops get auto\-parallelized when performance gains are predicted based on the compiler analysis data. Loops get auto\-parallelized only if profitable parallel execution is almost certain.
.IP
The intermediate 1 to 99 values represent the percentage probability for profitable speed\-up. For example, \fIn\fR=50 directs the compiler to parallelize only if there is a 50% probability of the code speeding up if executed in parallel.
.TP
\fBDefault:\fR 
.TP 18
\-par\-threshold100 
.NL
Loops get auto\-parallelized only if profitable parallel execution is almost certain. This is also the default if you do not specify \fIn\fR.
.TP
\fBDescription:\fR 
.PP
This option sets a threshold for the auto\-parallelization of loops based on the probability of profitable execution of the loop in parallel. To use this option, you must also specify option [Q]parallel.
.NL
.PP
This option is useful for loops whose computation work volume cannot be determined at compile\-time. The threshold is usually relevant when the loop trip count is unknown at compile\-time. 
.NL
.PP
The compiler applies a heuristic that tries to balance the overhead of creating multiple threads versus the amount of work available to be shared amongst the threads.
.NL
.PP
.B NOTE:
This option may behave differently on Intel(R) microprocessors than on non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pcn
.RS
.TP
Enables control of floating\-point significand precision.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the floating\-point significand precision. Possible values are:
.RS
.TP 15
32
Rounds the significand to 24 bits (single precision).
.TP 15
64
Rounds the significand to 53 bits (double precision).
.TP 15
80
Rounds the significand to 64 bits (extended precision).
.RE
.TP
\fBDefault:\fR 
.TP 18
\-pc80 
.NL
On Linux* and OS X* systems, the floating\-point significand is rounded to 64 bits. 
.TP
\fBDescription:\fR 
.PP
This option enables control of floating\-point significand precision.
.NL
.PP
Some floating\-point algorithms are sensitive to the accuracy of the significand, or fractional part of the floating\-point value. For example, iterative operations like division and finding the square root can run faster if you lower the precision with the this option.
.NL
.PP
Note that a change of the default precision control or rounding mode, for example, by using the [Q]pc32 option or by user intervention, may affect the results returned by some of the mathematical functions.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pch
.RS
.TP
Tells the compiler to use appropriate
precompiled header files. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not create or use precompiled
headers unless you tell it to do so.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use appropriate
precompiled header (PCH) files. If none are available, they are created as 
sourcefile.pchi. This
option is supported for multiple source files.
.NL
.PP
The 
\-pch option will use PCH
files created from other sources if the headers files are the same. For
example, if you compile 
source1.cpp using 
\-pch, then 
source1.pchi is created.
If you then compile 
source2.cpp using 
\-pch, the compiler will
use 
source1.pchi if it
detects the same headers.
.NL
.PP
.B CAUTION:
Depending on how you organize the header files listed
in your sources, this option may increase compile times. 
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pch\-create 
filename
.RS
.TP
Tells the compiler to create a
precompiled header file. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name for the precompiled header file. A
space must appear before the file name. It can include a path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not create or use precompiled
headers unless you tell it to do so.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to create a precompiled
header (PCH) file. It is supported only for single source file compilations.
.NL
.PP
Note that the .pchi extension is not automatically
appended to the file name. 
.NL
.PP
This option cannot be used in the same compilation as the
\-pch\-use option.
.NL
.PP
On Windows* systems, option 
\-pch\-create is equivalent to the 
/Yc option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.PP
Windows: 
/Yc
.NL
.RE
.TP
.B
\-pch\-dir dir
.RS
.TP
Tells the compiler the location for precompiled header files.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the path for precompiled header files. The path must exist.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not create or use precompiled headers unless you tell it to do so.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler the location for precompiled header files.  It denotes where to find precompiled header files, and where new PCH files should be placed.
.NL
.PP
This option can be used with the \-pch, \-pch\-create, and \-pch\-use options.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pch\-use 
filename
.RS
.TP
Tells the compiler to use a precompiled
header file. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the precompiled header file to use.
A space must appear before the file name. It can include a path. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not create or use precompiled
headers unless you tell it to do so. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use a precompiled
header (PCH) file. 
.NL
.PP
It is supported for multiple source files when all source
files use the same .pchi file. 
.NL
.PP
This option cannot be used in the same compilation as the
\-pch\-create option. 
.NL
.PP
To learn how to optimize compile times using the PCH
options, see "Using Precompiled Header Files" in the User\[aq]s Guide. 
.NL
.PP
On Windows* systems, option 
\-pch\-use is equivalent to the 
/Yu option. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None 
.NL
.PP
Windows: 
/Yu
.NL
.RE
.TP
.B
\-pie
.TP
.B
\-no\-pie
.RS
.TP
Determines whether the compiler
generates position\-independent code that will be linked into an executable.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
varies
.NL
On Linux* and on OS X* versions less than 10.7,
the default is \-no\-pie. On OS X* 10.7 or greater, the default is \-pie.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler generates
position\-independent code that will be linked into an executable. To enable
generation of position\-independent code that will be linked into an executable,
specify 
\-pie.
.NL
.PP
To disable generation of position\-independent code that
will be linked into an executable, specify 
\-no\-pie.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pragma\-optimization\-level=interpretation
.RS
.TP
Specifies which interpretation of the optimization_level pragma should be used if no prefix is specified.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIinterpretation\fR
.NL
Compiler\-specific interpretation of optimization_level pragma. Possible values are:
.RS
.TP 15
Intel
Specify the Intel interpretation.
.TP 15
GCC
Specify the GCC interpretation.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-pragma\-optimization\-level=Intel
.NL
Use the Intel interpretation of the optimization_level pragma.
.TP
\fBDescription:\fR 
.PP
Specifies which interpretation of the optimization_level pragma should be used if no prefix is specified.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prec\-div
.TP
.B
\-no\-prec\-div
.RS
.TP
Improves precision of floating\-point
divides.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-prec\-div 
.NL
The compiler uses this method for floating\-point
divides.
.TP
\fBDescription:\fR 
.PP
This option improves precision of floating\-point divides.
It has a slight impact on speed.
.NL
.PP
With some optimizations, such as 
\-msse2 (Linux*) or 
/arch:SSE2 (Windows*),
the compiler may change floating\-point division computations into
multiplication by the reciprocal of the denominator. For example, A/B is
computed as A * (1/B) to improve the speed of the computation.
.NL
.PP
However, sometimes the value produced by this
transformation is not as accurate as full IEEE division. When it is important
to have fully precise IEEE division, use this option to disable the
floating\-point division\-to\-multiplication optimization. The result is more
accurate, with some loss of performance.
.NL
.PP
If you specify 
\-no\-prec\-div (Linux* and
OS X*) or 
/Qprec\-div\- (Windows*),
it enables optimizations that give slightly less precise results than full IEEE
division.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prec\-sqrt
.TP
.B
\-no\-prec\-sqrt
.RS
.TP
Improves precision of square root implementations.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-prec\-sqrt 
.NL
The compiler uses a faster but less precise implementation of square root.
.IP
However, the default is \-prec\-sqrt if any of the following options are specified: \-O0  or \-mp1 on Linux* and OS X* systems. 
.TP
\fBDescription:\fR 
.PP
This option improves precision of square root implementations. It has a slight impact on speed. 
.NL
.PP
This option inhibits any optimizations that can adversely affect the precision of a square root computation. The result is fully precise square root implementations, with some loss of performance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-print\-multi\-lib
.RS
.TP
Prints information about where system
libraries should be found.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No information is printed unless the option is
specified.
.TP
\fBDescription:\fR 
.PP
This option prints information about where system
libraries should be found, but no compilation occurs. On Linux* systems, it is
provided for compatibility with gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-print\-sysroot (L*X only)
.RS
.TP
Prints the target sysroot directory that
is used during compilation.
.NL
.TP
\fBArchitectures:\fR Not available on Intel(R) 64 architecture targeting Intel(R)
MIC Architecture, on IA\-32 architecture
targeting Intel(R) Graphics Technology, or on Intel(R) 64 architecture targeting
Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Nothing is printed.
.TP
\fBDescription:\fR 
.PP
This option prints the target sysroot directory that is used during
compilation.
.NL
.PP
This is the target sysroot directory that is specified in an environment
file or in option 
\-\-sysroot. This option is only effective if a target sysroot
has been specified.
.NL
.PP
This option is provided for compatibility
with gcc.
.NL
.PP
.B NOTE:
Even though this option is not supported for a
Windows\-to\-Windows native compiler, it is supported for a Windows\-host to
Linux\-target compiler.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-data\-order (L*X only)
.TP
.B
\-no\-prof\-data\-order (L*X only)
.RS
.TP
Enables or disables data ordering if
profiling information is enabled.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-data\-order 
.NL
Data ordering is disabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables data ordering if
profiling information is enabled. It controls the use of profiling information
to order static program data items. 
.NL
.PP
For this option to be effective, you must do the
following:
.NL
.IP \(bu 2
For instrumentation compilation, you must specify
option 
[Q]prof\-gen setting
globdata. 
.IP \(bu 2
For feedback compilation, you must specify the 
[Q]prof\-use option. You
must not use multi\-file optimization by specifying options such as 
[Q]ipo or 
[Q]ipo\-c. 
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-dir 
dir
.RS
.TP
Specifies a directory for profiling
information output files. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory. You can specify a
relative pathname or an absolute pathname. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Profiling output files are placed in the directory
where the program is compiled. 
.TP
\fBDescription:\fR 
.PP
This option specifies a directory for profiling
information output files (*.dyn and *.dpi). The specified directory must
already exist. 
.NL
.PP
You should specify this option using the same directory
name for both instrumentation and feedback compilations. If you move the .dyn
files, you need to specify the new path. 
.NL
.PP
Option 
/Qprof\-dir is equivalent to option 
/Qcov\-dir. If you specify both options, the last option
specified on the command line takes precedence. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-prof\-file 
filename
.RS
.TP
Specifies an alternate file name for the
profiling summary files.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the profiling summary file.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The profiling summary files have the file name
pgopti.*
.TP
\fBDescription:\fR 
.PP
This option specifies an alternate file name for the
profiling summary files. The 
\fIfilename\fR is used as
the base name for files created by different profiling passes.
.NL
.PP
If you add this option to profmerge, the .dpi file will
be named 
\fIfilename\fR.dpi instead
of pgopti.dpi.
.NL
.PP
If you specify this option with option 
[Q]prof\-use, the .dpi
file will be named 
\fIfilename\fR.dpi instead
of pgopti.dpi.
.NL
.PP
Option 
/Qprof\-file is equivalent to option 
/Qcov\-file. If you specify both options, the last option
specified on the command line takes precedence.
.NL
.PP
.B NOTE:
When you use option 
[Q]prof\-file, you can only specify a file name. If you want
to specify a path (relative or absolute) for 
\fIfilename\fR, you must also use option 
[Q]prof\-dir. 
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-func\-groups (L*X only)
.TP
.B
\-no\-prof\-func\-groups (L*X only)
.RS
.TP
Enables or disables function grouping if
profiling information is enabled.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-func\-groups
.NL
Function grouping is disabled. 
.TP
\fBDescription:\fR 
.PP
This option enables or disables function grouping if
profiling information is enabled.
.NL
.PP
A "function grouping" is a profiling optimization in
which entire routines are placed either in the cold code section or the hot
code section.
.NL
.PP
If profiling information is enabled by option 
\-prof\-use, option 
\-prof\-func\-groups is set
and function grouping is enabled. However, if you explicitly enable 
\-prof\-func\-order,
function ordering is performed instead of function grouping.
.NL
.PP
If you want to disable function grouping when profiling
information is enabled, specify 
\-no\-prof\-func\-groups.
.NL
.PP
To set the hotness threshold for function grouping, use
option 
\-prof\-hotness\-threshold.
.NL
.RE
.TP
.B
\-prof\-func\-order (L*X only)
.TP
.B
\-no\-prof\-func\-order (L*X only)
.RS
.TP
Enables or disables function ordering if
profiling information is enabled. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-func\-order 
.NL
Function ordering is disabled. 
.TP
\fBDescription:\fR 
.PP
This option enables or disables function ordering if
profiling information is enabled. 
.NL
.PP
For this option to be effective, you must do the
following: 
.NL
.IP \(bu 2
For instrumentation compilation, you must specify
option 
[Q]prof\-gen setting
srcpos. 
.IP \(bu 2
For feedback compilation, you must specify 
[Q]prof\-use. You must not
use multi\-file optimization by specifying options such as 
[Q]ipo or 
[Q]ipo\-c. 
.PP
If you enable profiling information by specifying option 
[Q]prof\-use, option 
[Q]prof\-func\-groups is
set and function grouping is enabled. However, if you explicitly enable the 
[Q]prof\-func\-order
option, function ordering is performed instead of function grouping. 
.NL
.PP
On Linux* systems, this option is only available for
Linux linker 2.15.94.0.1, or later. 
.NL
.PP
To set the hotness threshold for function grouping and
function ordering, use option 
[Q]prof\-hotness\-threshold. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-prof\-gen[=keyword[,
keyword],...]
.TP
.B
\-no\-prof\-gen
.RS
.TP
Produces an instrumented object file that
can be used in profile guided optimization. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology 
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies details for the instrumented file.
Possible values are: 
.RS
.TP 15
default
Produces an instrumented object file. This
is the same as specifying the 
[Q]prof\-gen
option with no keyword. 
.TP 15
srcpos
Produces an instrumented object file that
includes extra source position information. 
.TP 15
globdata
Produces an instrumented object file that
includes information for global data layout. 
.TP 15
[no]threadsafe
Produces an instrumented object file that
includes the collection of PGO data on applications that use a high level of
parallelism. If 
[Q]prof\-gen is specified with no keyword, the
default is 
nothreadsafe. 
.IP
On
Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
the only valid mode is keyword 
threadsafe. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-gen
.NL
Profile generation is disabled. 
.TP
\fBDescription:\fR 
.PP
This option produces an instrumented object file that
can be used in profile guided optimization. It gets the execution count of each
basic block. 
.NL
.PP
You can specify more than one setting for 
[Q]prof\-gen. For example, you can specify the following: 
.NL
.PP
–prof\-gen=scrpos \-prof\-gen=threadsafe (Linux* and OS X*) 
\-prof\-gen=scrpos, threadsafe (this is equivalent to the above)
.PP
.PP
/Qprof\-gen:scrpos /Qprof\-gen:threadsafe (Windows*)
/Qprof\-gen:scrpos, threadsafe (this is equivalent to the above)
.PP
.PP
If you specify keyword 
srcpos or 
globdata, a static profile
information file (.spi) is created. These settings may increase the time needed
to do a parallel build using \-prof\-gen, because of contention writing the .spi
file. 
.NL
.PP
These options are used in phase 1 of the Profile Guided
Optimizer (PGO) to instruct the compiler to produce instrumented code in your
object files in preparation for instrumented execution. 
.NL
.PP
When the 
[Q]prof\-gen option is used to produce an instrumented binary
file for profile generation, some optimizations are disabled. Those
optimizations are not disabled for any subsequent profile\-guided compilation
with option 
[Q]prof\-use that makes use of the generated profiles. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-prof\-hotness\-threshold=n (L*X only)
.RS
.TP
Lets you set the hotness threshold for
function grouping and function ordering. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the hotness threshold. 
\fIn\fR is a
percentage having a value between 0 and 100 inclusive. If you specify 0, there
will be no hotness threshold setting in effect for function grouping and
function ordering. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler\[aq]s default hotness threshold setting of
10 percent is in effect for function grouping and function ordering. 
.TP
\fBDescription:\fR 
.PP
This option lets you set the hotness threshold for
function grouping and function ordering.
.NL
.PP
The "hotness threshold" is the percentage of functions in
the application that should be placed in the application\[aq]s hot region. The hot
region is the most frequently executed part of the application. By grouping
these functions together into one hot region, they have a greater probability
of remaining resident in the instruction cache. This can enhance the
application\[aq]s performance.
.NL
.PP
For this option to take effect, you must specify option 
[Q]prof\-use and one of
the following:
.NL
.IP \(bu 2
On Linux systems: 
\-prof\-func\-groups or 
\-prof\-func\-order
.IP \(bu 2
On Windows systems: 
/Qprof\-func\-order
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-src\-dir
.TP
.B
\-no\-prof\-src\-dir
.RS
.TP
Determines whether directory information
of the source file under compilation is considered when looking up profile data
records.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
prof\-src\-dir
.NL
Directory information is used when looking up
profile data records in the .dpi file.
.TP
\fBDescription:\fR 
.PP
This option determines whether directory information of
the source file under compilation is considered when looking up profile data
records in the .dpi file. To use this option, you must also specify the 
[Q]prof\-use option. 
.NL
.PP
If the option is enabled, directory information is
considered when looking up the profile data records within the .dpi file. You
can specify directory information by using one of the following options:
.NL
.IP \(bu 2
Linux and OS X: 
\-prof\-src\-root or 
\-prof\-src\-root\-cwd
.IP \(bu 2
Windows: 
/Qprof\-src\-root or 
/Qprof\-src\-root\-cwd
.PP
If the option is disabled, directory information is
ignored and only the name of the file is used to find the profile data record.
.NL
.PP
Note that option 
[Q]prof\-src\-dir controls
how the names of the user\[aq]s source files get represented within the .dyn or
.dpi files. Option 
[Q]prof\-dir specifies the
location of the .dyn or the .dpi files.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-src\-root=dir
.RS
.TP
Lets you use relative directory paths
when looking up profile data and specifies a directory as the base. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the base for the relative paths. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The setting of relevant options determines the path
used when looking up profile data records. 
.TP
\fBDescription:\fR 
.PP
This option lets you use relative directory paths when
looking up profile data in .dpi files. It lets you specify a directory as the
base. The paths are relative to a base directory specified during the 
[Q]prof\-gen compilation
phase. 
.NL
.PP
This option is available during the following phases of
compilation: 
.NL
.IP \(bu 2
Linux* and OS X* systems: 
\-prof\-gen and 
\-prof\-use phases 
.IP \(bu 2
Windows* systems: 
/Qprof\-gen and 
/Qprof\-use phases 
.PP
When this option is specified during the 
[Q]prof\-gen phase, it
stores information into the .dyn or .dpi file. Then, when .dyn files are merged
together or the .dpi file is loaded, only the directory information below the
root directory is used for forming the lookup key. 
.NL
.PP
When this option is specified during the 
[Q]prof\-use phase, it
specifies a root directory that replaces the root directory specified at the 
[Q]prof\-gen phase for
forming the lookup keys. 
.NL
.PP
To be effective, this option or option 
[Q]prof\-src\-root\-cwd must
be specified during the 
[Q]prof\-gen phase. In
addition, if one of these options is not specified, absolute paths are used in
the .dpi file. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-prof\-src\-root\-cwd
.RS
.TP
Lets you use relative directory paths
when looking up profile data and specifies the current working directory as the
base. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The setting of relevant options determines the path
used when looking up profile data records. 
.TP
\fBDescription:\fR 
.PP
This option lets you use relative directory paths when
looking up profile data in .dpi files. It specifies the current working
directory as the base. To use this option, you must also specify option 
[Q]prof\-use. 
.NL
.PP
This option is available during the following phases of
compilation: 
.NL
.IP \(bu 2
Linux* and OS X* systems: 
\-prof\-gen and 
\-prof\-use phases 
.IP \(bu 2
Windows* systems: 
/Qprof\-gen and 
/Qprof\-use phases 
.PP
When this option is specified during the 
[Q]prof\-gen phase, it
stores information into the .dyn or .dpi file. Then, when .dyn files are merged
together or the .dpi file is loaded, only the directory information below the
root directory is used for forming the lookup key. 
.NL
.PP
When this option is specified during the 
[Q]prof\-use phase, it
specifies a root directory that replaces the root directory specified at the 
[Q]prof\-gen phase for
forming the lookup keys. 
.NL
.PP
To be effective, this option or option 
[Q]prof\-src\-root must be
specified during the 
[Q]prof\-gen phase. In
addition, if one of these options is not specified, absolute paths are used in
the .dpi file. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-prof\-use[=keyword]
.TP
.B
\-no\-prof\-use
.RS
.TP
Enables the use of profiling information
during optimization. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies additional instructions. Possible values
are: 
.RS
.TP 15
weighted
Tells the profmerge utility to apply a
weighting to the .dyn file values when creating the .dpi file to normalize the
data counts when the training runs have differentexecution durations. This
argument only has an effect when the compiler invokes the profmerge utility to
create the .dpi file. This argument does not have an effect if the .dpi file
was previously created without weighting. 
.TP 15
[no]merge
Enables or disables automatic invocation of
the profmerge utility. The default is 
merge. Note that you
cannot specify both 
weighted and 
nomerge. If you try
to specify both values, a warning will be displayed and 
nomerge takes
precedence. 
.TP 15
default
Enables the use of profiling information
during optimization. The profmerge utility is invoked by default. This value is
the same as specifying 
[Q]prof\-use
with no argument. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-use
.NL
Profiling information is not used during
optimization. 
.TP
\fBDescription:\fR 
.PP
This option enables the use of profiling information
(including function splitting and function grouping) during optimization. It
enables option /Qfnsplit (Windows*). 
.NL
.PP
This option instructs the compiler to produce a
profile\-optimized executable and it merges available profiling output files
into a pgopti.dpi file. 
.NL
.PP
Note that there is no way to turn off function grouping
if you enable it using this option. 
.NL
.PP
To set the hotness threshold for function grouping and
function ordering, use option 
[Q]prof\-hotness\-threshold. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-prof\-value\-profiling[=keyword]
.RS
.TP
Controls which values are value profiled.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Controls which type of value profiling is
performed. Possible values are:
.RS
.TP 15
none
Prevents all types of value profiling.
.TP 15
nodivide
Prevents value profiling of non\-compile time
constants used in division or remainder operations.
.TP 15
noindcall
Prevents value profiling of function
addresses at indirect call sites.
.TP 15
all
Enables all types of value profiling.
.RE
.PP
You can specify more than one keyword, but they must be
separated by commas.
.NL
.TP
\fBDefault:\fR 
.TP 18
all
.NL
All value profile types are enabled and value
profiling is performed.
.TP
\fBDescription:\fR 
.PP
This option controls which features are value profiled.
.NL
.PP
If this option is specified with option 
[Q]prof\-gen, it turns off instrumentation of operations of the
specified type. This also prevents feedback of values for the operations.
.NL
.PP
If this option is specified with option 
[Q]prof\-use, it turns off feedback of values collected of the
specified type.
.NL
.PP
If you specify level 2 or higher for option[q or
Q]opt\-report, the value profiling specialization information will be
reported within the PGO optimization report.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-profile\-functions
.RS
.TP
Inserts instrumentation calls at a
function\[aq]s entry and exit points.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No instrumentation calls are inserted at a
function\[aq]s entry and exit points.
.TP
\fBDescription:\fR 
.PP
This option inserts instrumentation calls at a function\[aq]s entry and exit
points within a single\-threaded application to collect the cycles spent within
the function to produce reports that can help in identifying code hotspots.
.NL
.PP
When the instrumented application is run, this option causes the generation
of a loop_prof_funcs_<name>.dump file, where <name> is a timestamp
for the run. 
.NL
.PP
The same data values are also dumped into the file
loop_prof_<name>.xml for use with the data viewer application, unless you
turn off the output format by setting the environment variable
INTEL_LOOP_PROF_XML_DUMP to 0. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-profile\-loops=keyword
.RS
.TP
Inserts instrumentation calls at a
function\[aq]s entry and exit points, and before and after instrumentable loops.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies which type of loops should have
instrumentation. Possible values are:
.RS
.TP 15
inner
Inserts instrumentation before and after
inner loops.
.TP 15
outer
Inserts instrumentation before and after
outer loops.
.TP 15
all
Inserts instrumentation before and after all
loops.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No instrumentation calls are inserted at a
function\[aq]s entry and exit points, or before and after instrumentable loop.
.TP
\fBDescription:\fR 
.PP
This option inserts instrumentation calls at a function\[aq]s entry and exit
points within a single\-threaded application. For unthreaded applications, it
also inserts instrumentation before and after instrumentable loops of the type
listed in 
\fIkeyword\fR.
.NL
.PP
When the instrumented application is run, this option causes the generation
of a loop_prof_funcs_<name>.dump file and a
loop_prof_funcs_<name>.dump file, where <name> is a timestamp for
the run. 
.NL
.PP
The same timestamp is used for the loop file and function file. This
identifies that the loop data and function data were from the same program run.
.NL
.PP
The same data values are also dumped into the file
loop_prof_<name>.xml for use with the data viewer application, unless you
turn off the output format by setting the environment variable
INTEL_LOOP_PROF_XML_DUMP to 0. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-profile\-loops\-report[=n]
.RS
.TP
Controls the level of detail for the data
collected when instrumentation occurs before and after certain loops.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a value denoting the level of detail to report.
Possible values are:
.RS
.TP 15
1
Reports the cycle counts on entry and exits
of loops. This is the default if 
\fIn\fR is not specified.
.TP 15
2
Reports the level 1 default details, but
also includes the loop min/max and average loop iteration counts. 
.IP
To collect the loop iteration counts,
additional instrumentation is inserted. This can increase overhead in the
instrumented application and slow performance.
.RE
.TP
\fBDefault:\fR 
.TP 18
1
.NL
The report shows the cycle counts on entry and
exits of loops.
.TP
\fBDescription:\fR 
.PP
This option controls the level of detail for the data collected when
instrumentation occurs before and after certain loops. To use this option, you
must also specify option 
[Q]profile\-loops. 
.NL
.PP
The report appears in file
loop_prof_loops_<name>.dump, where <name> is a timestamp value for
the run. The columns listed in the report will be based on the level of detail
that was selected during instrumentation. 
.NL
.PP
It is recommended that the same report level be used for
all files that are instrumented for the application. If different files of the
application were instrumented with different levels, the report will contain
all the columns of the highest detail level, but with default values for
unavailable fields for files that were instrumented at lower levels. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pthread
.RS
.TP
Tells the compiler to use pthreads library for multithreading support. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not use pthreads library for multithreading support.
.TP
\fBDescription:\fR 
.PP
Tells the compiler to use pthreads library for multithreading support.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qoffload[=keyword] (L*X only)
.TP
.B
\-qno\-offload (L*X only)
.RS
.TP
Lets you specify the mode for offloading
or tell the compiler to ignore language constructs for offloading. This option
only applies to Intel(R) MIC Architecture. 
Options /Qoffload\- and /Qoffload:none are
also available for Intel(R) Graphics Technology. Option \-q[no\-]offload is
the replacement option for \-[no\-]offload, which is deprecated. 
.NL
.TP
\fBArchitecture Restrictions:\fR Keywords mandatory and optional: Only
available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture 
/Qoffload\- and /Qoffload:none: Only
available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture, on IA\-32
architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64 architecture
targeting Intel(R) Graphics Technology 
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the mode for offloading or it disables
offloading. Possible values are: 
.RS
.TP 15
none
Tells the compiler to ignore language
constructs for offloading. Warnings are issued by the compiler. This is
equivalent to the negative form of the option. 
.TP 15
mandatory
Specifies that offloading is mandatory
(required). If the target is not available, one of the following occurs: 
.RS
.IP \(bu 2
If no 
status clause is specified for the 
offload pragma, the program fails with an
error message. 
.IP \(bu 2
If the 
status clause is specified, the program
continues execution on the CPU. 
.RE
.TP 15
optional
Specifies that offloading is optional
(requested). If the target is not available, the program is executed on the
CPU, not the target. 
.RE
.TP
\fBDefault:\fR 
.TP 18
mandatory
.NL
The compiler recognizes language constructs for
offloading if they are specified. If option 
\-qoffload 
(Linux*) or 
/Qoffload (Windows*) is specified with no 
\fIkeyword\fR, the default is 
mandatory. 
.TP
\fBDescription:\fR 
.PP
This option lets you specify the mode for offloading or tell the compiler
to ignore language constructs for offloading. 
.NL
.PP
Option \-q[no\-]offload is the replacement option for
\-[no\-]offload, which is deprecated. 
.NL
.PP
On Intel(R) Graphics Technology, the only
options you can specify are 
/Qoffload\- or /Qoffload:none, which tells the
compiler to ignore language constructs for offloading. By default, offloading
is optional for Intel(R) Graphics Technology. 
.NL
.PP
If no 
\-qoffload (Linux*) or 
/Qoffload (Windows*) option appears on the command line, then 
offload pragmas are processed and: 
.NL
.IP \(bu 2
The 
mandatory or 
optional clauses are obeyed if present 
.IP \(bu 2
If no 
mandatory or 
optional clause is present, the offload is
mandatory 
.PP
If any of the following appears on the command line, then 
offload pragmas are ignored: 
.NL
.IP \(bu 2
Linux* systems: 
\-qoffload=none or 
\-qno\-offload
.IP \(bu 2
Windows* systems: 
/offload:none or 
/Qoffload\-
.PP
However, OpenMP* 
pragmas for coprocessor control (for
example, omp target) are recognized if the 
[q or Q]openmp option is specified, regardless of whether or
not 
offload pragmas are recognized or ignored.
.NL
.PP
If 
\fIkeyword\fR mandatory or 
optional appears for 
[Q]offload, then 
offload pragmas are processed and: 
.NL
.IP \(bu 2
The 
mandatory or 
optional clauses are obeyed, regardless of
the 
\-qoffload 
(Linux*) or 
/Qoffload (Windows*) 
\fIkeyword\fR
.IP \(bu 2
If no 
mandatory or 
optional clause is present, then the 
\-qoffload 
(Linux*) or 
/Qoffload (Windows*) 
\fIkeyword\fR is obeyed 
.PP
If the 
status clause is specified for an 
offload pragma, it affects run\-time
behavior. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qoffload\-arch=arch[:visa] (L*X only)
.RS
.TP
Lets you specify the target architecture
to use when offloading code. This option only applies to Intel(R) MIC
Architecture and Intel(R) Graphics
Technology. 
For Intel(R) Graphics Technology, you can
also specify a virtual ISA (vISA). 
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R)
MIC Architecture, on IA\-32 architecture
targeting Intel(R) Graphics Technology, or on Intel(R) 64 architecture targeting
Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.TP 18
\fIarch\fR
.NL
Specifies the target architecture. 
.IP
On Intel(R) 64 architecture targeting Intel(R) MIC
Architecture, 
\fIarch\fR can be one of the following: 
.RS
.IP \(bu 2
mic, targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.IP \(bu 2
mic\-avx512, targeting the 
Intel(R) Xeon Phi(TM) coprocessor (code name
Knights Landing)
.RE
.IP
On
IA\-32 and Intel(R) 64 architectures targeting Intel(R) Graphics Technology, 
\fIarch\fR can be haswell, broadwell, skylake, or broxton.
.TP 18
\fIvisa\fR
.NL
Specifies the virtual ISA (vISA) version to be
used. 
.IP
This optional argument is only
allowed on IA\-32 and Intel(R) 64 architectures targeting Intel(R) Graphics
Technology. You can only specify visa3.1 or visa3.2. 
.TP
\fBDefault:\fR 
.TP 18
varies
.NL
On Intel(R) 64 architecture targeting Intel(R) MIC
Architecture, the default 
\fIarch\fR is assumed to be 
mic. 
On IA\-32 and Intel(R) 64
architectures targeting Intel(R) Graphics Technology, the default 
\fIarch\fR is haswell and the default 
\fIvisa\fR is visa3.1.
.TP
\fBDescription:\fR 
.PP
This option lets you specify the target architecture to
use when offloading code. For Intel(R)
Graphics Technology, you can also specify a virtual ISA (vISA).
.NL
.PP
On IA\-32 and Intel(R) 64
architectures targeting Intel(R) Graphics Technology, the compiler will check
that the values specified for 
\fIarch\fR and 
\fIvisa\fR are compatible. For architectures where multiple vISA
versions are supported, the vISA version selected must be <= the vISA
version supported by the driver installed on the system where the application
is to be executed. 
.NL
.PP
The following table shows
the vISA version that each 
\fIarch\fR supports: 
.NL
.PP
The following are various combinations
and settings of command line options for offloading: 
.NL
.IP \(bu 2
Offload: Intel(R) 64 architecture host and 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
target code generation: 
.IP
icc …                         ! default for Linux
icc … \-qoffload\-arch=mic      ! explicit KNC for Linux
icl …                         ! default for Windows
icl … /Qoffload\-arch=mic      ! explicit KNC for Windows
.IP \(bu 2
Offload: Intel(R) 64 architecture host and 
Intel(R) Xeon Phi(TM) coprocessor (code name
Knights Landing)
target code generation: 
.IP
icc … \-qoffload\-arch=mic\-avx512     ! Linux
icl … /Qoffload\-arch=mic\-avx512     ! Windows
.IP \(bu 2
Offload : 
Intel(R) Xeon Phi(TM) coprocessor (code name
Knights Landing)
host and target code generation (for this host, target defaults to 
Intel(R) Xeon Phi(TM) coprocessor (code name
Knights Landing)):
.IP
icc … \-xmic\-avx512      ! Linux
icl … /Qxmic\-avx512     ! Windows
.IP \(bu 2
Native : Code Generation for 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner):
.IP
icc … \-mmic             ! Linux
icl … /Qmic             ! Windows
.IP \(bu 2
Native : Code Generation for 
Intel(R) Xeon Phi(TM) coprocessor (code name
Knights Landing):
.IP
icc … \-xmic\-avx512 –qno\-offload     ! Linux
icl … /Qxmic\-avx512 /Qno\-offload    ! Windows
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qoffload\-attribute\-target=target\-name (L*X only)
.RS
.TP
Causes the compiler to flag 
file\-scope functions and data
objects in the source file with the offload attribute target(mic) or target(gfx). This option only applies
to Intel(R) MIC Architecture and Intel(R)
Graphics Technology. Option \-qoffload\-attribute\-target is the replacement
option for \-offload\-attribute\-target, which is deprecated. 
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R)
MIC Architecture, on IA\-32 architecture
targeting Intel(R) Graphics Technology, or on Intel(R) 64 architecture targeting
Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.TP 18
\fItarget\-name\fR
.NL
Is a specific
target or application. The supported values for this argument are: 
.RS
.IP \(bu 2
mic for Intel(R) MIC
Architecture 
.IP \(bu 2
gfx
for Intel(R) Graphics Technology 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not flag 
file\-scope functions and data
objects in the source file with the offload attribute 
target(mic) or 
target(gfx). 
.TP
\fBDescription:\fR 
.PP
This option causes the compiler to flag 
file\-scope functions and data
objects in the source file with the offload attribute target(mic) or 
target(gfx). 
.NL
.PP
This option is similar to using the pragma 
offload_attribute target(mic) to
set the attribute 
target(mic), or 
offload_attribute target(gfx) to
set the attribute 
target(gfx), for all functions and data objects in the
file scope. 
.NL
.PP
Target
declspecs/attributes on individual declarations take precedence over any 
offload_attribute pragma in
effect, and declspecs, attributes, and pragmas all take precedence over this
option. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qoffload\-option,target,tool,"option\-list" (L*X only)
.RS
.TP
Lets you explicitly specify options to be
used for the specified target and tool. This option only applies to Intel(R) MIC
Architecture and Intel(R) Graphics
Technology. Option \-qoffload\-option is the replacement option for
\-offload\-option, which is deprecated. 
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R)
MIC Architecture, on IA\-32 architecture
targeting Intel(R) Graphics Technology, or on Intel(R) 64 architecture targeting
Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.TP 18
\fItarget\fR
.NL
Is the target
architecture or application. The supported values for this argument are: 
.RS
.IP \(bu 2
mic for Intel(R) MIC
Architecture 
.IP \(bu 2
gfx
for Intel(R) Graphics Technology 
.RE
.TP 18
\fItool\fR
.NL
Is the tool that the 
\fIoption\-list\fR is associated with. It can be one of the
following values: 
ld, 
link, 
as, or 
compiler. 
.IP
ld is the linker tool on Linux*;
link is the linker tool on Windows*. 
.TP 18
\fIoption\-list\fR
.NL
Is one or more options that are specific to the
tool. The quotation mark delimiters are required. Each option in the 
\fIoption\-list\fR must be separated by a space. 
.IP
For tool 
compiler, use compiler\-specific options; for tool 
ld, use linker\-specific options; for tool 
as, use assembler\-specific options. The options for
the tools always use the Linux form even when compiling on Windows. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not pass additional options to
the separate tools on the target architecture. 
.TP
\fBDescription:\fR 
.PP
This option lets you explicitly specify options to be used for the specified
target and tool. It can be specified multiple times on the command line. 
.NL
.PP
When building a heterogeneous application, the driver passes all compiler
options specified on the command\-line to the host compilation and only certain
options to the offload compilation. To see a list of options passed to the
offload compilation, specify option 
watch=mic\-cmd. 
.NL
.PP
If you want to pass additional options to the offload compilation, or you
would like to override the command line options passed to offload compilation,
you must use option 
[q or Q]offload\-option to specify the additional or overriding
options. 
.NL
.PP
.B NOTE:
If you specify the options 
I, 
L, 
D, or 
U with the option 
[q or Q]offload\-option, they override any other 
I, 
L, 
D, and 
U options that are automatically passed from host to offload
compilation. 
.PP
To achieve the overriding effect, the 
I, 
L, 
D, and 
U options specified using 
[q or Q]offload\-option are placed ahead of the 
I, 
L, 
D, and 
U options automatically copied over from the host
compilation. All other options specified using 
[q or Q]offload\-option are placed after the options copied
over from host to offload compilation. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qoffload\-svm (L*X only)
.TP
.B
\-qno\-offload\-svm (L*X only)
.RS
.TP
Determines whether the compiler uses Shared Virtual Memory (SVM) mode.  This option only applies to Intel(R) Graphics Technology.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-offload\-svm or /Qoffload\-svm\-
.NL
The compiler does not use SVM mode.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler uses Shared Virtual Memory (SVM) mode. When you specify [q or Q]offload\-svm, virtual address space is shared between the CPU and the architecture targeting Intel(R) Graphics Technology. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopenmp
.TP
.B
\-qno\-openmp
.RS
.TP
Enables the parallelizer to generate
multi\-threaded code based on OpenMP* directives. Option \-qopenmp is the
replacement option for \-openmp, which is deprecated. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-openmp
.NL
No OpenMP* multi\-threaded code is generated by the
compiler. 
.TP
\fBDescription:\fR 
.PP
This option enables the parallelizer to generate
multi\-threaded code based on OpenMP* directives. The code can be executed in
parallel on both uniprocessor and multiprocessor systems. 
.NL
.PP
This option works with any optimization level. Specifying
no optimization (\-O0 on
Linux* or 
/Od on Windows*) helps to
debug OpenMP applications. 
.NL
.PP
.B NOTE:
On OS X* systems, when you enable OpenMP* API, you must
also set the DYLD_LIBRARY_PATH environment variable within Xcode* or an error
will be displayed. 
.PP
.B NOTE:
Options that use OpenMP* API are available for both
Intel(R) microprocessors and non\-Intel microprocessors, but these options may
perform additional optimizations on Intel(R) microprocessors than they perform on
non\-Intel microprocessors. The list of major, user\-visible OpenMP constructs
and features that may perform differently on Intel(R) microprocessors versus
non\-Intel microprocessors include: locks (internal and user visible), the
SINGLE construct, barriers (explicit and implicit), parallel loop scheduling,
reductions, memory allocation, thread affinity, and binding. 
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: 
\-fopenmp
.NL
.RE
.TP
.B
\-qopenmp\-lib=type
.RS
.TP
Lets you specify an OpenMP* run\-time
library to use for linking. Option \-qopenmp\-lib is the replacement option for
\-openmp\-lib, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fItype\fR
.NL
Specifies the type of library to use; it implies
compatibility levels. Currently, the only possible value is:
.RS
.TP 15
compat
Tells the compiler to use the compatibility
OpenMP* run\-time library (libiomp). This setting provides compatibility with
object files created using Microsoft* and GNU* compilers.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopenmp\-lib=compat 
.NL
The compiler uses the compatibility OpenMP*
run\-time library (libiomp).
.TP
\fBDescription:\fR 
.PP
This option lets you specify an OpenMP* run\-time library
to use for linking.
.NL
.PP
The compatibility OpenMP run\-time libraries are
compatible with object files created using the Microsoft* OpenMP run\-time
library (vcomp) or the GNU OpenMP run\-time library (libgomp).
.NL
.PP
To use the compatibility OpenMP run\-time library, compile
and link your application using the compat setting for option 
[q or Q]openmp\-lib. To use this option, you must also specify
one of the following compiler options:
.NL
.IP \(bu 2
Linux* systems: 
\-qopenmp or 
\-qopenmp\-stubs
.IP \(bu 2
Windows* systems: 
/Qopenmp or 
/Qopenmp\-stubs
.PP
On Windows* systems, the compatibility OpenMP* run\-time
library lets you combine OpenMP* object files compiled with the Microsoft*
C/C++ compiler with OpenMP* object files compiled with the Intel(R) C, Intel(R)
C++, or Intel(R) Fortran compilers. The linking phase results in a single,
coherent copy of the run\-time library.
.NL
.PP
On Linux* systems, the compatibility Intel OpenMP*
run\-time library lets you combine OpenMP* object files compiled with the GNU*
gcc or gfortran compilers with similar OpenMP* object files compiled with the
Intel(R) C, Intel(R) C++, or Intel(R) Fortran compilers. The linking phase results in
a single, coherent copy of the run\-time library.
.NL
.PP
.B NOTE:
The compatibility OpenMP run\-time library is not
compatible with object files created using versions of the Intel compilers
earlier than 10.0.
.PP
.B NOTE:
On Windows* systems, this option is processed by the
compiler, which adds directives to the compiled object file that are processed
by the linker. On Linux* and OS X* systems, this option is processed by the 
icc/icpc command that
initiates linking, adding library names explicitly to the link command.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopenmp\-link=library
.RS
.TP
Controls whether the compiler links to
static or dynamic OpenMP* run\-time libraries. Option \-qopenmp\-link is the
replacement option for \-openmp\-link, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIlibrary\fR
.NL
Specifies the OpenMP library to use. Possible
values are: 
.RS
.TP 15
static
Tells the compiler to link to static OpenMP
run\-time libraries. Note that static OpenMP libraries are deprecated. 
.TP 15
dynamic
Tells the compiler to link to dynamic OpenMP
run\-time libraries. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopenmp\-link=dynamic
.NL
The compiler links to dynamic OpenMP* run\-time
libraries. However, if Linux* option 
\-static is
specified, the compiler links to static OpenMP run\-time libraries. 
.TP
\fBDescription:\fR 
.PP
This option controls whether the compiler links to static
or dynamic OpenMP* run\-time libraries. 
.NL
.PP
To link to the static OpenMP run\-time library (RTL) and
create a purely static executable, you must specify 
\-qopenmp\-link=static.
However, we strongly recommend you use the default setting, 
\-qopenmp\-link=dynamic. 
.NL
.PP
.B NOTE:
Compiler options 
\-static\-intel and 
\-shared\-intel (Linux*
and OS X*) have no effect on which OpenMP run\-time library is linked. 
.PP
.B NOTE:
On Linux* systems, 
\-qopenmp\-link=dynamic
cannot be used in conjunction with option 
\-static. If you try to
specify both options together, an error will be displayed. 
.PP
.B NOTE:
On Linux systems, the OpenMP runtime library depends on
using libpthread and libc (libgcc when compiled with gcc). Libpthread and libc
(libgcc) must both be static or both be dynamic. If both libpthread and libc
(libgcc) are static, then the static version of the OpenMP runtime should be
used. If both libpthread and libc (libgcc) are dynamic, then either the static
or dynamic version of the OpenMP runtime may be used. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopenmp\-offload[=device] (L*X only)
.TP
.B
\-qno\-openmp\-offload (L*X only)
.RS
.TP
Enables or disables OpenMP* offloading
compilation for the 
target pragmas. This option only applies
to Intel(R) MIC Architecture and Intel(R)
Graphics Technology. Option \-qopenmp\-offload is the replacement option for
\-openmp\-offload, which is deprecated. 
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R)
MIC Architecture, on
IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.TP 18
device
.NL
Specifies the default device for target pragmas. Possible values are:
.RS
.TP 15
mic
Specifies the target device is Intel(R) MIC
Architecture; this is the default. This value is available for Windows* and
Linux* systems on Intel(R) 64 architecture 
.TP 15
gfx
Specifies the target device is Intel(R)
Graphics Technology. This value is available for Windows* and Linux* systems on
Intel(R) 64 architecture, and on Windows* systems on IA\-32 architecture. 
.TP 15
host
Causes the target code to run on the host
system, while still doing the outlining for offload. This lets you test 
#pragma omp target
when no target device is available. This value is available for Windows* and
Linux* systems on IA\-32 and Intel(R) 64 architecture. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qno\-openmp\-offload
.NL
OpenMP* offloading compilation is disabled.
However, if option 
[q or Q]openmp is specified, the default is ON and
OpenMP offloading compilation is enabled. 
.TP
\fBDescription:\fR 
.PP
This option enables or disables OpenMP* offloading compilation for the 
target pragmas. When enabling offloading,
it lets you specify what the default target device should be for the 
target pragmas. The default is 
mic. 
.NL
.PP
You can also use this option if you want to enable or disable the
offloading feature with no impact on other OpenMP* features. In this case, no
OpenMP runtime library is needed to link and the compiler does not need to
generate OpenMP runtime initialization code. 
.NL
.PP
If you specify this option with the 
[q or Q]openmp option, it can impact other OpenMP* features. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopenmp\-simd
.TP
.B
\-qno\-openmp\-simd
.RS
.TP
Enables or disables OpenMP* SIMD
compilation. Option \-qopenmp\-simd is the replacement option for \-openmp\-simd,
which is deprecated. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-openmp\-simd
.NL
OpenMP* SIMD compilation is disabled. However, if
option 
[q or Q]openmp is specified, the default is ON and
OpenMP SIMD compilation is enabled. 
.TP
\fBDescription:\fR 
.PP
This option enables or disables OpenMP* SIMD compilation. 
.NL
.PP
You can use this option if you want to enable or disable the SIMD support
with no impact on other OpenMP features. In this case, no OpenMP runtime
library is needed to link and the compiler does not need to generate OpenMP
runtime initialization code. 
.NL
.PP
If you specify this option with the 
[q or Q]openmp option, it can impact other OpenMP features. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopenmp\-stubs
.RS
.TP
Enables compilation of OpenMP* programs
in sequential mode. Option \-qopenmp\-stubs is the replacement option for
\-openmp\-stubs, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The library of OpenMP* function stubs is not
linked.
.TP
\fBDescription:\fR 
.PP
This option enables compilation of OpenMP* programs in
sequential mode. The OpenMP directives are ignored and a stub OpenMP library is
linked. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopenmp\-task=model
.RS
.TP
Lets you choose an OpenMP* tasking model. Option \-qopenmp\-task is the replacement option for \-openmp\-task, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fImodel\fR
.NL
Is an OpenMP tasking model. Possible values are:
.RS
.TP 15
intel
Tells the compiler to accept Intel taskqueuing pragmas (#pragma intel_omp_taskq and #pragma intel_omp_task). When this value is specified, OpenMP API 3.0 tasking pragmas are ignored; if they are specified, warnings are issued.
.TP 15
omp
Tells the compiler to accept OpenMP* API 3.0 tasking pragmas (#pragma omp_task). When this value is specified, Intel taskqueuing pragmas are ignored; if they are specified, warnings are issued.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopenmp\-task=omp
.NL
The compiler accepts OpenMP 3.0 tasking pragmas.
.TP
\fBDescription:\fR 
.PP
The option lets you choose an OpenMP tasking model.
.NL
.PP
To use this option, you must also specify option [q or Q]openmp.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopenmp\-threadprivate=type (L*X only)
.RS
.TP
Lets you specify an OpenMP* threadprivate
implementation. Option \-qopenmp\-threadprivate is the replacement option for
\-openmp\-threadprivate, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fItype\fR
.NL
Specifies the type of threadprivate implementation.
Possible values are:
.RS
.TP 15
legacy
Tells the compiler to use the legacy OpenMP*
threadprivate implementation used in the previous releases of the Intel(R)
compiler. This setting does not provide compatibility with the implementation
used by other compilers. 
.TP 15
compat
Tells the compiler to use the compatibility
OpenMP* threadprivate implementation 
based on applying the
__declspec(thread) attribute to each threadprivate variable. The limitations of
the attribute on a given platform also apply to the threadprivate
implementation. This setting provides compatibility with the
implementation provided by the Microsoft* and GNU* compilers. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopenmp\-threadprivate=legacy 
.NL
The compiler uses the legacy OpenMP* threadprivate
implementation used in the previous releases of the Intel compiler. 
.TP
\fBDescription:\fR 
.PP
This option lets you specify an OpenMP* threadprivate
implementation.
.NL
.PP
The threadprivate implementation of the legacy OpenMP
run\-time library may not be compatible with object files created using OpenMP
run\-time libraries supported in other compilers.
.NL
.PP
To use this option, you must also specify one of the
following compiler options: 
.NL
.IP \(bu 2
Linux* systems: 
\-qopenmp or 
\-qopenmp\-stubs
.IP \(bu 2
Windows* systems: 
/Qopenmp or 
/Qopenmp\-stubs
.PP
The value specified for this option is independent of the
value used for the 
[q or Q]openmp\-lib option.
.NL
.PP
.B NOTE:
On OS X* systems, legacy is the only type of
threadprivate supported. Option 
\-qopenmp\-threadprivate
is not recognized by the compiler.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-args\-in\-regs[=keyword]
.RS
.TP
Determines whether calls to routines are optimized by passing parameters  in registers instead of on the stack. Option \-qopt\-args\-in\-regs is the replacement option for \-opt\-args\-in\-regs, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on IA\-32 architecture
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies whether the optimization should be performed 
and under what conditions.
Possible values are:
.RS
.TP 15
none
The optimization is not performed. No parameters 
are passed in registers. They are put on the stack.
.TP 15
seen
Causes parameters 
to be passed in registers when they are passed to routines whose definition can be seen in the same compilation unit.
.TP 15
all
Causes parameters 
to be passed in registers, whether they are passed to routines whose definition can be seen in the same compilation unit, or not. This value is only available on Linux* systems.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-args\-in\-regs=seen
.NL
Parameters 
are passed in registers when they are passed to routines whose
definition is seen in the same compilation unit.
.TP
\fBDescription:\fR 
.PP
This option determines whether calls to
routines are optimized by passing parameters 
in registers instead of on the stack. It also indicates the conditions when the optimization
will be performed.
.NL
.PP
This option can improve performance for
Application Binary Interfaces (ABIs) that
require parameters 
to be passed in memory and compiled without
interprocedural optimization (IPO).
.NL
.PP
Note that on Linux* systems, if all is specified, a small
overhead may be paid when calling "unseen" routines that have not
been compiled with the same option. This is because the call will
need to go through a "thunk" to ensure that parameters 
are placed back on the stack where the callee
expects them.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-assume\-safe\-padding (L*X only)
.TP
.B
\-qno\-opt\-assume\-safe\-padding (L*X only)
.RS
.TP
Determines whether the compiler assumes
that variables and dynamically allocated memory are padded past the end of the
object. Option \-qopt\-assume\-safe\-padding is the replacement option for
\-opt\-assume\-safe\-padding, which is deprecated. 
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-assume\-safe\-padding 
.NL
The compiler will not assume that variables and
dynamically allocated memory are padded past the end of the object. It will
adhere to the sizes specified in your program. 
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler assumes that variables and
dynamically allocated memory are padded past the end of the object. 
.NL
.PP
When you specify option 
[q or Q]opt\-assume\-safe\-padding, the compiler assumes that
variables and dynamically allocated memory are padded. This means that code can
access up to 64 bytes beyond what is specified in your program. 
.NL
.PP
The compiler does not add any padding for static and
automatic objects when this option is used, but it assumes that code can access
up to 64 bytes beyond the end of the object, wherever the object appears in the
program. To satisfy this assumption, you must increase the size of static and
automatic objects in your program when you use this option. 
.NL
.PP
This option may improve performance of memory operations. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-block\-factor=n
.RS
.TP
Lets you specify a loop blocking factor. Option \-qopt\-block\-factor is the replacement option for \-opt\-block\-factor, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the blocking factor. It must be an integer. The compiler may ignore the blocking factor if the value is 0 or 1. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics for loop blocking.
.TP
\fBDescription:\fR 
.PP
This option lets you specify a loop blocking factor.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-calloc (L*X only)
.TP
.B
\-qno\-opt\-calloc (L*X only)
.RS
.TP
Tells the compiler to substitute a call to _intel_fast_calloc() for a call to calloc(). Option \-qopt\-calloc is the replacement option for \-opt\-calloc, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-calloc
.NL
The compiler does not substitute a call to _intel_fast_calloc() for a call to calloc().
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to substitute a call to_intel_fast_calloc() for a call to calloc().
.NL
.PP
This option may increase the performance of long\-running programs that use calloc() frequently. It is recommended for these programs over combinations of options \-inline\-calloc and \-qopt\-malloc\-options=3 because this option causes less memory fragmentation.
.NL
.PP
.B NOTE:
Many routines in the LIBIRC library are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-class\-analysis
.TP
.B
\-qno\-opt\-class\-analysis
.RS
.TP
Determines whether C++ class hierarchy information is used to analyze and resolve C++ virtual function calls at compile time. Option \-qopt\-class\-analysis is the replacement option for \-opt\-class\-analysis, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-class\-analysis 
.NL
C++ class hierarchy information is not used to analyze and resolve C++ virtual function calls at compile time. 
.TP
\fBDescription:\fR 
.PP
This option determines whether C++ class hierarchy information is used to analyze and resolve C++ virtual function calls at compile time. The option is turned on by default with the \-ipo compiler option, enabling improved C++ optimization. If a C++ application contains non\-standard C++ constructs, such as pointer down\-casting, it may result in different behaviors.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-dynamic\-align
.TP
.B
\-qno\-opt\-dynamic\-align
.RS
.TP
Enables or disables dynamic data alignment optimizations. Option \-qopt\-dynamic\-align is the replacement option for \-opt\-dynamic\-align, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-dynamic\-align 
.NL
The compiler may generate code dynamically dependent on alignment. It may do optimizations based on data location for the best performance. The result of execution on some algorithms may depend on data layout.
.TP
\fBDescription:\fR 
.PP
This option enables or disables dynamic data alignment optimizations. 
.NL
.PP
If you specify \-qno\-opt\-dynamic\-align or /Qopt\-dynamic\-align\-, the compiler generates no code dynamically dependent on alignment. It will not do any optimizations based on data location and results will depend on the data values themselves.
.NL
.PP
When you specify [q or Q]qopt\-dynamic\-align, the compiler may implement conditional optimizations based on dynamic alignment of the input data.  These dynamic alignment optimizations may result in different bitwise results for aligned and unaligned data with the same values. 
.NL
.PP
Dynamic alignment optimizations can improve the performance of vectorized code, especially for long trip count loops. Disabling such optimizations can decrease performance, but it may improve bitwise reproducibility of results, factoring out data location from possible sources of discrepancy.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-gather\-scatter\-unroll=n (L*X only)
.TP
.B
\-qno\-opt\-gather\-scatter\-unroll (L*X only)
.RS
.TP
Lets you specify an alternative loop
unroll sequence for gather and scatter loops. Option
\-qopt\-gather\-scatter\-unroll is the replacement option for
\-opt\-gather\-scatter\-unroll, which is deprecated. 
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the unroll factor for the gather and scatter loops. It must be an
integer between 0 and 8. If you specify value 0 for 
\fIn\fR, it is the same as specifying the negative form of
the option. 
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-gather\-scatter\-unroll or 
/Qopt\-gather\-scatter\-unroll
.NL
The compiler uses default heuristics when
unrolling gather and scatter loops. 
.TP
\fBDescription:\fR 
.PP
This option lets you specify an alternative loop unroll sequence for gather
and scatter loops. 
.NL
.PP
This option may improve performance of gather/scatter operations. 
.NL
.PP
The value of 
\fIn\fR that provides the best performance is data\-dependent. 
.NL
.PP
In cases where the gather/scatter operation accesses data in a small number
of cache\-lines (such as 1 or 2), the default sequence (using a small value for 
\fIn\fR) works best. In cases where each individual data item
falls in a different cache\-line, it may be better to use a large value for 
\fIn\fR. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-jump\-tables=keyword
.TP
.B
\-qno\-opt\-jump\-tables
.RS
.TP
Enables or disables generation of jump
tables for switch statements. Option \-qopt\-jump\-tables is the replacement
option for \-opt\-jump\-tables, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is the instruction for generating jump tables.
Possible values are: 
.RS
.TP 15
never
Tells the compiler to never generate jump
tables. All switch statements are implemented as chains of if\-then\-elses. This
is the same as specifying 
\-qno\-opt\-jump\-tables (Linux* and
OS X*) or 
/Qopt\-jump\-tables\- (Windows*).
.TP 15
default
The compiler uses default heuristics to
determine when to generate jump tables. 
.TP 15
large
Tells the compiler to generate jump tables up
to a certain pre\-defined size (64K entries). 
.TP 15
n
Must be an integer. Tells the compiler to
generate jump tables up to 
\fIn\fR
entries in size. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-jump\-tables=default 
.NL
The compiler uses default heuristics to determine
when to generate jump tables for switch statements.
.TP
\fBDescription:\fR 
.PP
This option enables or disables generation of jump tables
for switch statements. When the option is enabled, it may improve performance
for programs with large switch statements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-malloc\-options=n
.RS
.TP
Lets you specify an alternate algorithm for malloc(). Option \-qopt\-malloc\-options is the replacement option for \-opt\-malloc\-options, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Specifies the algorithm to use for malloc(). Possible values are:
.RS
.TP 15
0
Tells the compiler to use the default algorithm for malloc(). This is the default.
.TP 15
1
Causes the following adjustments to the malloc() algorithm: M_MMAP_MAX=2 and M_TRIM_THRESHOLD=0x10000000.
.TP 15
2
Causes the following adjustments to the malloc() algorithm: M_MMAP_MAX=2 and M_TRIM_THRESHOLD=0x40000000.
.TP 15
3
Causes the following adjustments to the malloc() algorithm: M_MMAP_MAX=0 and M_TRIM_THRESHOLD=\-1.
.TP 15
4
Causes the following adjustments to the malloc() algorithm: M_MMAP_MAX=0, M_TRIM_THRESHOLD=\-1, M_TOP_PAD=4096.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-malloc\-options=0
.NL
The compiler uses the default algorithm when malloc() is called. No call is made to mallopt().
.TP
\fBDescription:\fR 
.PP
This option lets you specify an alternate algorithm for malloc().
.NL
.PP
If you specify a non\-zero value for \fIn\fR, it causes alternate configuration parameters to be set for how malloc() allocates and frees memory. It tells the compiler to insert calls to mallopt() to adjust these parameters to malloc() for dynamic memory allocation. This may improve speed.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-matmul (L*X only)
.TP
.B
\-qno\-opt\-matmul (L*X only)
.RS
.TP
Enables or disables a compiler\-generated
Matrix Multiply (matmul) library call. Option \-qopt\-matmul is the replacement
option for \-opt\-matmul, which is deprecated. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-matmul 
.NL
The matmul library call optimization does not
occur unless this option is enabled or certain other compiler options are
specified (see below). 
.TP
\fBDescription:\fR 
.PP
This option enables or disables a compiler\-generated
Matrix Multiply (MATMUL) library call. 
.NL
.PP
The 
[q or Q]opt\-matmul option tells the compiler to identify
matrix multiplication loop nests (if any) and replace them with a matmul
library call for improved performance. The resulting executable may get
additional performance gain on Intel(R) microprocessors than on non\-Intel
microprocessors. 
.NL
.PP
.B NOTE:
This option is dependent upon the OpenMP* library. If
your product does not support OpenMP, this option will have no effect. 
.PP
This option is enabled by default if options 
O3 and 
[Q]parallel are specified. To disable this optimization,
specify 
\-qno\-opt\-matmul or 
/Qopt\-matmul\-. 
.NL
.PP
This option has no effect unless option 
O2 or higher is set. 
.NL
.PP
.B NOTE:
Many routines in the MATMUL library are more highly
optimized for Intel(R) microprocessors than for non\-Intel microprocessors. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-mem\-layout\-trans[=n]
.TP
.B
\-qno\-opt\-mem\-layout\-trans
.RS
.TP
Controls the level of memory layout
transformations performed by the compiler. Option \-qopt\-mem\-layout\-trans is the
replacement option for \-opt\-mem\-layout\-trans, which is deprecated. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of memory layout transformations.
Possible values are: 
.RS
.TP 15
0
Disables memory layout transformations. This
is the same as specifying 
\-qno\-opt\-mem\-layout\-trans (Linux* and OS X*) or 
/Qopt\-mem\-layout\-trans\- (Windows*). 
.TP 15
1
Enables basic memory layout transformations.
.TP 15
2
Enables more memory layout transformations.
This is the same as specifying 
[q or Q]opt\-mem\-layout\-trans with no argument. 
.TP 15
3
Enables aggressive memory layout
transformations. You should only use this setting if your system has more than
4GB of physical memory per core. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-mem\-layout\-trans=2
.NL
The compiler performs moderate memory layout
transformations. 
.TP
\fBDescription:\fR 
.PP
This option controls the level of memory layout
transformations performed by the compiler. This option can improve cache reuse
and cache locality. 
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-multi\-version\-aggressive
.TP
.B
\-qno\-opt\-multi\-version\-aggressive
.RS
.TP
Tells the compiler to use aggressive
multi\-versioning to check for pointer aliasing and scalar replacement. Option
\-qopt\-multi\-version\-aggressive is the replacement option for
\-opt\-multi\-version\-aggressive, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-multi\-version\-aggressive 
.NL
The compiler uses default heuristics when checking
for pointer aliasing and scalar replacement.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use aggressive
multi\-versioning to check for pointer aliasing and scalar replacement. This
option may improve performance.
.NL
.PP
The performance can be affected by certain options, such
as 
/arch or 
/Qx (Windows*) or 
\-m or 
\-x (Linux* and OS X*).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-prefetch[=n]
.TP
.B
\-qno\-opt\-prefetch
.RS
.TP
Enables or disables prefetch insertion
optimization. Option \-qopt\-prefetch is the replacement option for
\-opt\-prefetch, which is deprecated. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of software prefetching optimization
desired. Possible values are: 
.RS
.TP 15
0
Disables software prefetching. This is the
same as specifying 
\-qno\-opt\-prefetch (Linux* and OS
X*) or 
/Qopt\-prefetch\- (Windows*). 
.TP 15
1 to 
5
Enables different levels of software
prefetching. If you do not specify a value for 
\fIn\fR, the
default is 
2. Use lower values
to reduce the amount of prefetching. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-prefetch 
.NL
Prefetch insertion optimization is disabled. 
.TP
\fBDescription:\fR 
.PP
This option enables or disables prefetch insertion
optimization. The goal of prefetching is to reduce cache misses by providing
hints to the processor about when data should be loaded into the cache. 
.NL
.PP
On Intel(R) 64
architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
option 
\-qopt\-prefetch=3 (Linux* and OS X*) and 
/Qopt\-prefetch:3 (Windows*) are enabled by default if option 
O2 or higher is set. To
disable prefetching at these optimization levels, specify option 
\-qno\-opt\-prefetch or 
/Qopt\-prefetch\-. 
.NL
.PP
This option enables prefetching when higher optimization
levels are specified. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-prefetch\-distance=n1[, 
n2] (L*X only)
.RS
.TP
Specifies the prefetch distance to be
used for compiler\-generated prefetches inside loops. Option
\-qopt\-prefetch\-distance is the replacement option for \-opt\-prefetch\-distance,
which is deprecated. 
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology 
.TP
\fBArguments:\fR 
.TP 18
\fIn1,
n2\fR
.NL
Is the prefetch distance in terms of the number of
(possibly\-vectorized) iterations. Possible values are non\-negative numbers
>=0. 
.IP
\fIn2\fR is
optional. 
.IP
\fIn1\fR = 0 turns off all compiler issued prefetches
from memory to L2. 
\fIn2 
\fR= 0 turns off all compiler issued prefetches from L2 to L1.
If 
\fIn2\fR is
specified and 
\fIn1\fR > 0, 
\fIn1\fR should be >= 
\fIn2\fR. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics to determine
the prefetch distance. 
.TP
\fBDescription:\fR 
.PP
This option specifies the prefetch distance to be used for
compiler\-generated prefetches inside loops. The unit (\fIn1\fR and
optionally 
\fIn2\fR) is the number of iterations. If the loop is vectorized
by the compiler, the unit is the number of vectorized iterations. 
.NL
.PP
The value of 
\fIn1\fR will be used as the distance for prefetches from memory
to L2 (for example, the vprefetch1 instruction). If 
\fIn2\fR is specified, it will be used as the distance for
prefetches from L2 to L1 (for example, the vprefetch0 instruction). 
.NL
.PP
This option is ignored if option 
\-qopt\-prefetch=0 (Linux*) or 
/Qopt\-prefetch:0 (Windows*) is specified. On Intel(R) MIC
Architecture, 
\-qopt\-prefetch=3 and 
/Qopt\-prefetch:3 is the default at option levels 
O2 and above. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-prefetch\-issue\-excl\-hint (L*X only)
.RS
.TP
Supports the prefetchW instruction in
Intel(R) microarchitecture code name Broadwell and later. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not support the PREFETCHW
instruction for this microarchitecture. 
.TP
\fBDescription:\fR 
.PP
This option supports the PREFETCHW instruction in Intel(R) microarchitecture
code name Broadwell and later. 
.NL
.PP
When you specify this option, you must also specify option 
[q or Q]opt\-prefetch. 
.NL
.PP
The prefetch instruction is merely a hint and does not affect program
behavior. If executed, this instruction moves data closer to the processor and
invalidates any other cached copy in anticipation of the line being written to
in the future. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-ra\-region\-strategy[=keyword]
.RS
.TP
Selects the method that the register allocator uses to partition each routine into regions. Option \-qopt\-ra\-region\-strategy is the replacement option for \-opt\-ra\-region\-strategy, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is the method used for partitioning. Possible values are: 
.RS
.TP 15
routine
Creates a single region for each routine.
.TP 15
block
Partitions each routine into one region per basic block.
.TP 15
trace
Partitions each routine into one region per trace.
.TP 15
loop
Partitions each routine into one region per loop.
.TP 15
default
The compiler determines which method is used for partitioning.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-ra\-region\-strategy=default 
.NL
The compiler determines which method is used for partitioning. This is also the default if keyword is not specified.
.TP
\fBDescription:\fR 
.PP
This option selects the method that the register allocator uses to partition each routine into regions.
.NL
.PP
When setting default is in effect, the compiler attempts to optimize the tradeoff between compile\-time performance and generated code performance.
.NL
.PP
This option is only relevant when optimizations are enabled (option O1 or higher).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report[=n]
.RS
.TP
Tells the compiler to generate an
optimization report. Option \-qopt\-report is the replacement option for
\-opt\-report, which is deprecated. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
(Optional) Indicates the level of detail in the
report. You can specify values 0 through 5. If you specify zero, no report is
generated. For levels 
\fIn\fR=1 through 
\fIn\fR=5, each level includes all the information of the
previous level, as well as potentially some additional information. Level 5
produces the greatest level of detail. If you do not specify 
\fIn\fR, the default is level 2, which produces a medium
level of detail. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate a collection
of optimization report files, one per object; this is the same output produced
by option 
[q or Q]opt\-report\-per\-object. 
.NL
.PP
If you prefer another form of output, you can specify
option 
[q or Q]opt\-report\-file. 
.NL
.PP
If you specify a level (\fIn\fR) higher than
5, a warning will be displayed and you will get a level 5 report. 
.NL
.PP
When optimization reporting is enabled, the default is 
\-qopt\-report\-phase=all (Linux* and OS X*) or 
/Qopt\-report\-phase:all (Windows*). 
.NL
.PP
For a description of the information that each 
\fIn\fR level provides, see the Example section in option 
[q or Q]opt\-report\-phase. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-report\-annotate[=keyword]
.RS
.TP
Enables the annotated source listing
feature and specifies its format.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the format for the annotated source
listing. You can specify one of the following:
.RS
.TP 15
text
Indicates that the listing should be in text
format. This is the default if you do not specify 
\fIkeyword\fR.
.TP 15
html
Indicates that the listing should be in html
format.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No annotated source listing is generated
.TP
\fBDescription:\fR 
.PP
This option enables the annotated source listing feature and specifies its
format. The feature annotates source files with compiler optimization reports.
.NL
.PP
By default, one annotated source file is output per object. The annotated
file is written to the same directory where the object files are generated. If
the object file is a temporary file and an executable is generated, annotated
files are placed in the directory where the executable is placed. You cannot
generate annotated files to a directory of your choosing.
.NL
.PP
However, you can output annotated listings to stdout, stderr, or to a file
if you also specify option 
[q or Q]opt\-report\-file.
.NL
.PP
By default, this option sets option 
[q or Q]opt\-report with default level 2.
.NL
.PP
The following shows the file extension and listing details for the two
possible 
\fIkeyword\fRs.
.NL
.TP 18
\fBFormat
\fR
.NL
.NL
\fBListing Details
\fR
.NL
.NL
.TP 18
text
.NL
The annotated source listing has an .annot
extension. It includes line numbers and compiler diagnostics placed after
correspondent lines. IPO footnotes are inserted at the end of annotated file.
.NL
.TP 18
html
.NL
The annotated source listing has an .annot.html
extension. It includes line numbers and compiler diagnostics placed after
correspondent lines (as the text format does). It also provides hyperlinks in
compiler messages and quick navigation with the routine list. IPO footnotes are
displayed as tooltips.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-annotate\-position=keyword
.RS
.TP
Enables the annotated source listing
feature and specifies the site where optimization messages appear in the
annotated source in inlined cases of loop optimizations. 
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the site where optimization messages
appear in the annotated source. You can specify one of the following: 
.RS
.TP 15
caller
Indicates that the messages should appear in
the caller site. 
.TP 15
callee
Indicates that the messages should appear in
the callee site. 
.TP 15
both
Indicates that the messages should appear in
both the caller and the callee sites. 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No annotated source listing is generated 
.TP
\fBDescription:\fR 
.PP
This option enables the annotated source listing feature and specifies the
site where optimization messages appear in the annotated source in inlined
cases of loop optimizations. 
.NL
.PP
This option enables option 
[q or Q]opt\-report\-annotate if it is not explicitly specified.
.NL
.PP
If annotated source listing is enabled
and this option is not passed to compiler, loop optimizations are placed in
caller position by default. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-report\-embed
.TP
.B
\-qno\-opt\-report\-embed
.RS
.TP
Determines whether special loop
information annotations will be embedded in the object file and/or the assembly
file when it is generated. Option \-qopt\-report\-embed is the replacement option
for \-opt\-report\-embed, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
When an assembly file is being generated, special
loop information annotations will not be embedded in the assembly file. 
.IP
However, if option 
\-g (Linux* and OS X*) or 
/Zi (Windows*) is specified, special loop information
annotations will be embedded in the assembly file unless option 
\-qno\-opt\-report\-embed (Linux and OS X) or 
/Qopt\-report\-embed\- (Windows) is specified.
.TP
\fBDescription:\fR 
.PP
This option determines whether special loop information annotations will be
embedded in the object file and/or the assembly file when it is generated.
Specify the positive form of the option to include the annotations in the
assembly file.
.NL
.PP
If an object file (or executable) is being generated, the annotations will
be embedded in the object file (or executable). 
.NL
.PP
If you use this option, you do not have to specify option
[q or Q]opt\-report.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-file=keyword
.RS
.TP
Specifies that the output for the
optimization report goes to a file, stderr, or stdout. Option \-qopt\-report\-file
is the replacement option for \-opt\-report\-file, which is deprecated. 
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the output for the report. You can
specify one of the following: 
.RS
.TP 15
filename
Specifies the name of the file where the
output should go. 
.TP 15
stderr
Indicates that the output should go to
stderr. 
.TP 15
stdout
Indicates that the output should go to
stdout. 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated. 
.TP
\fBDescription:\fR 
.PP
This option specifies that the output for the
optimization report goes to a file, stderr, or stdout. 
.NL
.PP
If you use this option, you do not have to specify option
[q or Q]opt\-report. 
.NL
.PP
When optimization reporting is enabled, the default is 
\-qopt\-report\-phase=all (Linux* and OS X*) or 
/Qopt\-report\-phase:all (Windows*). 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-report\-filter=string
.RS
.TP
Tells the compiler to find the indicated
parts of your application, and generate optimization reports for those parts of
your application. Option \-qopt\-report\-filter is the replacement option for
\-opt\-report\-filter, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Is the information to search for. The 
\fIstring\fR must appear within quotes. It can take one or
more of the following forms: 
\fIfilename\fR\fIfilename\fR, 
\fIroutine\fR\fIfilename\fR, 
\fIrange\fR [, 
\fIrange\fR]... 
\fIfilename\fR, 
\fIroutine\fR, 
\fIrange\fR [, 
\fIrange\fR]... 
.IP
If you specify more than one of the above forms in
a string, a semicolon must appear between each form. If you specify more than
one 
\fIrange\fR in a string, a comma must appear between each 
\fIrange\fR. Optional blanks can follow each parameter in
the forms above and they can also follow each form in a string.
.RS
.TP 15
\fIfilename\fR
Specifies the name of a file to be found. It can include a
path.
.IP
If you do not specify a path, the compiler looks for the
filename in the current working directory.
.TP 15
\fIroutine\fR
Specifies the name of a routine to be found. You can include an
identifying parameter. 
.IP
The name, including any
parameter, must be
enclosed in single quotes.
.IP
The compiler tries to uniquely identify the routine that
corresponds to the specified routine name. 
.IP
It may select multiple routines to analyze,
especially if more than one routine has the specified routine name, so the
routine cannot be uniquely identified.
.TP 15
\fIrange\fR
Specifies a range of line numbers to be found in the file or
routine specified. The 
\fIrange\fR must be specified in integers in the
form:
.IP
\fIfirst_line_number\-last_line_number\fR
.IP
The hyphen between the line numbers is required.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to find the indicated parts of your
application, and generate optimization reports for those parts of your
application. Optimization reports will only be generated for the routines that
contain the specified 
\fIstring\fR.
.NL
.PP
On Linux* and OS X*, if you specify both 
\-qopt\-report\-routine=string1 and 
\-qopt\-report\-filter=string2, it is treated as 
\-qopt\-report\-filter=string1;string2. On Windows*, if you
specify both 
/Qopt\-report\-routine:string1 and 
/Qopt\-report\-filter:string2, it is treated
as/Qopt\-report\-filter:string1;string2.
.NL
.PP
If you use this option, you do not have to specify option
[q or Q]opt\-report.
.NL
.PP
When optimization reporting is enabled, the default is 
\-qopt\-report\-phase=all (Linux* and OS X*) or 
/Qopt\-report\-phase:all (Windows*).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-format=keyword
.RS
.TP
Specifies the format for an optimization
report. Option \-qopt\-report\-format is the replacement option for
\-opt\-report\-format, which is deprecated. 
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the format for the report. You can specify one of the
following: 
.RS
.TP 15
text
Indicates that the report should be in text
format. 
.TP 15
vs
Indicates that the report should be in
Visual Studio* (IDE) format. The Visual Studio IDE uses the information to
visualize the optimization report in the context of your program source code. 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated. 
.TP
\fBDescription:\fR 
.PP
This option specifies the format for an optimization report. If you use this
option, you must specify either 
text or 
vs. 
.NL
.PP
If you do not specify this option and another option causes an optimization
report to be generated, the default format is 
text. 
.NL
.PP
If the 
[q or Q]opt\-report\-file option is also specified, it will
affect where the output goes: 
.NL
.IP \(bu 2
If 
filename is specified, output goes to the specified
file. 
.IP \(bu 2
If 
stdout is specified, output goes to stdout. 
.IP \(bu 2
If 
stderr is specified, output goes to stderr. 
.PP
If you use this option, you do not have to specify option
[q or Q]opt\-report. 
.NL
.PP
When optimization reporting is enabled, the default is 
\-qopt\-report\-phase=all (Linux* and OS X*) or 
/Qopt\-report\-phase:all (Windows*). 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-report\-help
.RS
.TP
Displays the optimizer phases available for report generation and a short description of what is reported at each level. Option \-qopt\-report\-help is the replacement option for \-opt\-report\-help, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option displays the optimizer phases available for report generation using [q or Q]opt\-report\-phase, and a short description of what is reported at each level.  No compilation is performed.
.NL
.PP
To indicate where output should go, you can specify one of the following options:
.NL
.IP \(bu 2
[q or Q]opt\-report\-file
.IP \(bu 2
[q or Q]opt\-report\-per\-object
.PP
If you use this option, you do not have to specify option [q or Q]opt\-report.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-names=keyword
.RS
.TP
Specifies whether mangled or unmangled
names should appear in the optimization report.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the form for the names. You can specify one of the
following: 
.RS
.TP 15
mangled
Indicates that the optimization report
should contain mangled names.
.TP 15
unmangled
Indicates that the optimization report
should contain unmangled names.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option specifies whether mangled or unmangled names should appear in
the optimization report. If you use this option, you must specify either 
mangled or 
unmangled.
.NL
.PP
If this option is not specified, unmangled names are used by default.
.NL
.PP
If you specify 
mangled, encoding (also known as decoration) is added to
names in the optimization report. This is appropriate when you want to match
annotations with the assembly listing.
.NL
.PP
If you specify 
unmangled, no encoding (or decoration) is added to names
in the optimization report. This is appropriate when you want to match
annotations with the source listing.
.NL
.PP
If you use this option, you do not have to specify option 
[q or Q]opt\-report.
.NL
.PP
When optimization reporting is enabled, the default is 
\-qopt\-report\-phase=all (Linux* and OS X*) or 
/Qopt\-report\-phase:all (Windows*).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-per\-object
.RS
.TP
Tells the compiler that optimization
report information should be generated in a separate file for each object.
Option \-qopt\-report\-per\-object is the replacement option for
\-opt\-report\-per\-object, which is deprecated. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler that optimization report information should
be generated in a separate file for each object. 
.NL
.PP
If you specify this option for a
single\-file compilation, a file with a .optrpt extension is produced for every
object file or assembly file that is generated by the compiler. For a multifile
Interprocedural Optimization (IPO) compilation, one file is produced for each
of the N true objects generated in the compilation. If only one true object
file is generated, the optimization report file generated is called
ipo_out.optrpt. If multiple true object files are generated (N>1), the names
used are ipo_out1.optprt, ipo_out2.optrpt, …ipo_outN.optrpt. 
.NL
.PP
The .optrpt files are written to the target directory of the compilation
process. If an object or assembly file is explicitly generated, the
corresponding .optrpt file is written to the same directory where the object
file is generated. If the object file is just a temporary file and an
executable is generated, the corresponding .optrpt files are placed in the
directory in which the executable is placed. 
.NL
.PP
If you use this option, you do not have to specify option
[q or Q]opt\-report. 
.NL
.PP
When optimization reporting is enabled, the default is 
\-qopt\-report\-phase=all (Linux* and OS X*) or 
/Qopt\-report\-phase:all (Windows*). 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-report\-phase[=list]
.RS
.TP
Specifies one or more optimizer phases
for which optimization reports are generated. Option \-qopt\-report\-phase is the
replacement option for \-opt\-report\-phase, which is deprecated. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIlist\fR
.NL
(Optional) Specifies one or more phases to generate
reports for. If you specify more than one phase, they must be separated with
commas. The values you can specify are: 
.RS
.TP 15
cg
The phase for code generation 
.TP 15
ipo
The phase for Interprocedural Optimization 
.TP 15
loop
The phase for loop nest optimization 
.TP 15
offload
The phase for Intel(R) MIC Architecture or Intel(R) Graphics Technology, depending on
which you are using. This phase has no effect if option 
\-no\-qoffload or option 
/Qoffload\- is specified. This phase only applies
to Intel(R) MIC Architecture or to Intel(R)
Graphics Technology. 
.TP 15
openmp
The phase for OpenMP 
.TP 15
par
The phase for auto\-parallelization 
.TP 15
pgo
The phase for Profile Guided Optimization 
.TP 15
tcollect
The phase for trace collection 
.TP 15
vec
The phase for vectorization 
.TP 15
all
All optimizer phases. This is the default if
you do not specify 
\fIlist\fR. 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated. 
.TP
\fBDescription:\fR 
.PP
This option specifies one or more optimizer phases for
which optimization reports are generated. 
.NL
.PP
Note that phase
offload causes the compiler to print a report of the input
or output of variables that the host sends to the offload target and variables
that the host receives from the target. 
.NL
.PP
For certain phases, you also need to specify other
options: 
.NL
.IP \(bu 2
If you specify phase 
cg, you must also specify option 
O1, 
O2 (default), or 
O3.
.IP \(bu 2
If you specify phase 
ipo, you must also specify option 
[Q]ipo.
.IP \(bu 2
If you specify phase 
loop, you must also specify option 
O2 (default) or 
O3.
.IP \(bu 2
If you specify phase 
openmp, you must also specify option 
[q or Q]openmp. 
.IP \(bu 2
If you specify phase 
par, you must also specify option 
[Q]parallel. 
.IP \(bu 2
If you specify phase 
pgo, you must also specify option 
[Q]prof\-use.
.IP \(bu 2
If you specify phase 
tcollect, you must also specify option 
[Q]tcollect.
.IP \(bu 2
If you specify phase 
vec, you must also specify option 
O2 (default) or 
O3. If you are interested in explicit vectorization by OpenMP*
SIMD, you must also specify option 
[q or Q]openmp.
.PP
To find all phase possibilities, specify option 
[q or Q]opt\-report\-help. 
.NL
.PP
If you use this option, you do not have to specify option
[q or Q]opt\-report. 
.NL
.PP
However, if you want to get more details for each phase,
specify option 
[q or Q]opt\-report=\fIn\fR along with this option
and indicate the level of detail you want by specifying an appropriate value
for 
\fIn\fR. (See also the Example section below.) 
.NL
.PP
When optimization reporting is enabled, the default is 
\-qopt\-report\-phase=all (Linux* and OS X*) or 
/Qopt\-report\-phase:all (Windows*). 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-report\-routine=substring
.RS
.TP
Tells the compiler to generate an
optimization report for each of the routines whose names contain the specified
substring. Option \-qopt\-report\-routine is the replacement option for
\-opt\-report\-routine, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIsubstring\fR
.NL
Is the text (string) to look for.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate an
optimization report for each of the routines whose names contain the specified
substring.
.NL
.PP
You can also specify a sequence of substrings separated
by commas. If you do this, the compiler will generate an optimization report
for each of the routines whose name contains one or more of these substrings. 
.NL
.PP
If you use this option, you do not have to specify option
[q or Q]opt\-report.
.NL
.PP
When optimization reporting is enabled, the default is 
\-qopt\-report\-phase=all (Linux* and OS X*) or 
/Qopt\-report\-phase:all (Windows*).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-streaming\-cache\-evict[=n] (L*X only)
.RS
.TP
Specifies the cache eviction level to be
used by the compiler for streaming loads and stores. Option
\-qopt\-streaming\-cache\-evict is the replacement option for
\-opt\-streaming\-cache\-evict, which is deprecated. 
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a value denoting the cache eviction (clevict)
level to use for streaming loads and stores. Possible values are: 
.RS
.TP 15
0
Tells the compiler to use no cache eviction
level. 
.TP 15
1
Tells the compiler to use the L1 cache
eviction level. 
.TP 15
2
Tells the compiler to use the L2 cache
eviction level. 
.TP 15
3
Tells the compiler to use the L1 and L2
cache eviction level. This is the default of you do not specify 
\fIn\fR. 
.RE
.TP
\fBDefault:\fR 
.TP 18
2
.NL
The compiler uses the L2 cache eviction level. 
.TP
\fBDescription:\fR 
.PP
This option specifies the cache eviction (clevict) level to be used by the
compiler for streaming loads and stores. 
.NL
.PP
Depending on the level used, the compiler will generate clevict0 and/or
clevict1 instructions that evict the cache\-line (corresponding to the load or
the store) from the first\-level and second\-level caches. These cache eviction
instructions will be generated after performing the corresponding load/store
operation. 
.NL
.PP
For more information on how to mark loads/stores as streaming, see the
description of the 
vector nontemporal pragma. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-qopt\-streaming\-stores=keyword
.RS
.TP
Enables generation of streaming stores for optimization. Option \-qopt\-streaming\-stores is the replacement option for \-opt\-streaming\-stores, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies whether streaming stores are generated. Possible values are:
.RS
.TP 15
always
Enables generation of streaming stores for optimization. The compiler optimizes under the assumption that the application is memory bound.
.TP 15
never
Disables generation of streaming stores for optimization. Normal stores are performed.
.TP 15
auto
Lets the compiler decide which instructions to use.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-streaming\-stores=auto 
.NL
The compiler decides whether to use streaming stores or normal stores.
.TP
\fBDescription:\fR 
.PP
This option enables generation of streaming stores for optimization. This method stores data with instructions that use a non\-temporal buffer, which minimizes memory hierarchy pollution.
.NL
.PP
This option may be useful for applications that can benefit from streaming stores.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-subscript\-in\-range
.TP
.B
\-qno\-opt\-subscript\-in\-range
.RS
.TP
Determines whether the compiler assumes that there are no "large" integers being used or being computed inside loops. Option \-qopt\-subscript\-in\-range is the replacement option for \-opt\-subscript\-in\-range, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-subscript\-in\-range 
.NL
The compiler assumes  there are "large" integers being used or being computed within loops.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler assumes that there are no "large" integers being used or being computed inside loops.
.NL
.PP
If you specify [q or Q]opt\-subscript\-in\-range, the compiler assumes that there are no "large" integers being used or being computed inside loops. A "large" integer is typically > 231. 
.NL
.PP
This feature can enable more loop transformations.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-threads\-per\-core=n (L*X only)
.RS
.TP
Informs the compiler about the number of hardware threads per core that will be used for an application. This option only applies to Intel(R) MIC Architecture. Option \-qopt\-threads\-per\-core is the replacement option for \-opt\-threads\-per\-core, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the number of hardware threads per core that the compiler should assume that will be used while executing the application. Possible values are 1, 2, 3, or 4.
.TP
\fBDefault:\fR 
.TP 18
4
.NL
Four hardware threads per core are used for the application.
.TP
\fBDescription:\fR 
.PP
This option informs the
compiler about the number of hardware threads per core that
will be used for an application. This enables the
compiler to perform better code optimizations (such as instruction
scheduling).
.NL
.PP
You should choose a value for \fIn\fR that is
based on how many threads will be used per core while executing the
application. For example, if the application is parallelized using
OpenMP* API, use the value of \fIn\fR that uses the same number of
threads per core as the OpenMP* API affinity setting will use when
executing the application code on the Intel(R) Xeon Phi(TM)
coprocessor.
.NL
.PP
This option does not affect the number of
threads per core that will be used at run time.
.NL
.PP
Code compiled with this option can run
correctly on any (hardware\-supported) number of threads per
core.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Qinstalldir
.RS
.TP
Specifies the root directory where the
compiler installation was performed. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the root directory where the installation was
performed. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default root directory for compiler
installation is searched for the compiler. 
.TP
\fBDescription:\fR 
.PP
This option specifies the root directory where the
compiler installation was performed. It is useful if you want to use a
different compiler or if you did not use the compilervars shell script to set
your environment variables. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-Qlocation,string,dir
.RS
.TP
Specifies the directory for supporting
tools.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Is the name of the tool.
.TP 18
\fIdir\fR
.NL
Is the directory (path) where the tool is located.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler looks for tools in a default area.
.TP
\fBDescription:\fR 
.PP
This option specifies the directory for supporting tools.
.NL
.PP
\fIstring\fR can be any of the
following:
.NL
.IP \(bu 2
c \- Indicates the Intel(R) C++ compiler.
.IP \(bu 2
cpp (or fpp) \- Indicates the Intel(R) C++ preprocessor.
.IP \(bu 2
cxxinc \- Indicates C++ header files.
.IP \(bu 2
cinc \- Indicates C header files.
.IP \(bu 2
asm \- Indicates the assembler.
.IP \(bu 2
link \- Indicates the linker.
.IP \(bu 2
prof \- Indicates the profiler.
.IP \(bu 2
On Windows* systems, the following is also available:
.RS
.IP \(bu 2
masm \- Indicates the Microsoft assembler.
.RE
.IP \(bu 2
On Linux* and OS X* systems, the following are also
available: 
.RS
.IP \(bu 2
as \- Indicates the assembler.
.IP \(bu 2
gas \- Indicates the GNU assembler. This setting
is for Linux* only.
.IP \(bu 2
ld \- Indicates the loader.
.IP \(bu 2
gld \- Indicates the GNU loader. This setting is
for Linux* only.
.IP \(bu 2
lib \- Indicates an additional library.
.IP \(bu 2
crt \- Indicates the crt%.o files linked into
executables to contain the place to start execution.
.RE
.PP
On Windows and OS X* systems, you can also specify a tool
command name. 
.NL
.PP
The following shows an example on OS X* systems:
.NL
.PP
\-Qlocation,ld,/usr/bin               ! This tells the driver to use /usr/bin/ld for the loader
\-Qlocation,ld,/usr/bin/gld           ! This tells the driver to use /usr/bin/gld as the loader
.PP
.PP
The following shows an example on Windows* systems:
.NL
.PP
/Qlocation,link,”c:\Program Files\tools\”            ! This tells the driver to use c:\Program Files\tools\link.exe for the loader
/Qlocation,link,”c:\Program Files\tools\my_link.exe” ! This tells the driver to use c:\Program Files\tools\my_link.exe as the loader
.PP
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.RS
.TP
Changes the default size of the long
double data type. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default size of the long double data type is 64
bits.
.TP
\fBDescription:\fR 
.PP
This option changes the default size of the long double
data type to 80 bits. 
.NL
.PP
However, the alignment requirement of the data type is 16
bytes, and its size must be a multiple of its alignment, so the size of a long
double on Windows is also 16 bytes. Only the lower 10 bytes (80 bits) of the 16
byte space will have valid data stored in it.
.NL
.PP
Note that the Microsoft compiler and Microsoft\-provided
library routines (such as 
printf or 
long double math functions) do not provide support for
80\-bit floating\-point values. As a result, this option should only be used when
referencing symbols within parts of your application built with this option or
symbols in libraries that were built with this option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Qoption,string,options
.RS
.TP
Passes options to a specified tool.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Is the name of the tool.
.TP 18
\fIoptions\fR
.NL
Are one or more comma\-separated, valid options for
the designated tool.
.IP
Note that certain tools may require that options
appear within quotation marks (" ").
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed to tools.
.TP
\fBDescription:\fR 
.PP
This option passes options to a specified tool.
.NL
.PP
If an argument contains a space or tab character, you
must enclose the entire argument in quotation marks (" "). You must separate
multiple arguments with commas.
.NL
.PP
\fIstring\fR can be any of the
following:
.NL
.IP \(bu 2
cpp \- Indicates the Intel compiler preprocessor.
.IP \(bu 2
c \- Indicates the C++ compiler.
.IP \(bu 2
asm \- Indicates the assembler.
.IP \(bu 2
link \- Indicates the linker.
.IP \(bu 2
prof \- Indicates the profiler.
.IP \(bu 2
On Windows* systems, the following is also available:
.RS
.IP \(bu 2
masm \- Indicates the Microsoft assembler.
.RE
.IP \(bu 2
On Linux* and OS X* systems, the following are also
available:
.RS
.IP \(bu 2
as \- Indicates the assembler.
.IP \(bu 2
gas \- Indicates the GNU assembler.
.IP \(bu 2
ld \- Indicates the loader.
.IP \(bu 2
gld \- Indicates the GNU loader.
.IP \(bu 2
lib \- Indicates an additional library.
.IP \(bu 2
crt \- Indicates the crt%.o files linked into
executables to contain the place to start execution.
.RE
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-rcd
.RS
.TP
Enables fast float\-to\-integer conversions.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Floating\-point values are truncated when a conversion to an integer is involved. 
.TP
\fBDescription:\fR 
.PP
This option enables fast float\-to\-integer conversions. It can improve the performance of code that requires floating\-point\-to\-integer conversions.
.NL
.PP
The system default floating\-point rounding mode is round\-to\-nearest. However, the C language requires floating\-point values to be truncated when a conversion to an integer is involved. To do this, the compiler must change the rounding mode to truncation before each floating\-point\-to\-integer conversion and change it back afterwards.
.NL
.PP
This option disables the change to truncation of the rounding mode for all floating\-point calculations, including floating point\-to\-integer conversions. This option can improve performance, but floating\-point conversions to integer will not conform to C semantics.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-regcall
.RS
.TP
Tells the compiler that the __regcall calling convention should be used for functions that do not directly specify a calling convention.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The __regcall calling convention will only be used if a function explicitly specifies it.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler that the __regcall calling convention should be used for functions that do not directly specify a calling convention. This calling convention ensures that as many values as possible are passed or returned in registers.
.NL
.PP
It ensures that __regcall is the default calling convention for functions in the compilation, unless another calling convention is specified in a declaration.
.NL
.PP
This calling convention is ignored if it is specified for a function with variable arguments. 
.NL
.PP
Note that all __regcall functions must have prototypes.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-restrict
.TP
.B
\-no\-restrict
.RS
.TP
Determines whether pointer disambiguation
is enabled with the restrict qualifier. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-restrict
.NL
Pointers are not qualified with the restrict
keyword.
.TP
\fBDescription:\fR 
.PP
This option determines whether pointer disambiguation is
enabled with the restrict qualifier. Option 
\-restrict and 
/Qrestrict enable the
recognition of the restrict keyword as defined by the ANSI standard.
.NL
.PP
By qualifying a pointer with the restrict keyword, you
assert that an object accessed by the pointer is only accessed by that pointer
in the given scope. You should use the restrict keyword only when this is true.
When the assertion is true, the restrict option will have no effect on program
correctness, but may allow better optimization.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-S
.RS
.TP
Causes the compiler to compile to an assembly file only and not link.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Normal compilation and linking occur.
.TP
\fBDescription:\fR 
.PP
This option causes the compiler to compile to an assembly file only and not link.
.NL
.PP
On Linux* and OS X* systems, the assembly file name has a .s suffix. On Windows* systems, the assembly file name has an .asm suffix.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-save\-temps
.TP
.B
\-no\-save\-temps
.RS
.TP
Tells the compiler to save intermediate
files created during compilation.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
Linux* and OS X* systems: 
\-no\-save\-temps 
.NL
On Linux and OS X systems, the compiler deletes
intermediate files after compilation is completed. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to save intermediate files
created during compilation. The names of the files saved are based on the name
of the source file; the files are saved in the current working directory.
.NL
.PP
If option 
[Q]save\-temps is
specified, the following occurs:
.NL
.IP \(bu 2
The object .o file (Linux and OS X) or .obj file
(Windows) is saved.
.IP \(bu 2
The assembler .s file (Linux and OS X) or .asm file
(Windows) is saved if you specified the 
[Q]use\-asm option.
.PP
If 
\-no\-save\-temps is
specified on Linux or OS X systems, the following occurs:
.NL
.IP \(bu 2
The .o file is put into 
/tmp and deleted after
calling 
ld.
.IP \(bu 2
The preprocessed file is not saved after it has been
used by the compiler.
.PP
If 
/Qsave\-temps\- is
specified on Windows systems, the following occurs:
.NL
.IP \(bu 2
The .obj file is not saved after the linker step.
.IP \(bu 2
The preprocessed file is not saved after it has been
used by the compiler.
.PP
.B NOTE:
This option only saves intermediate files that are
normally created during compilation.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-scalar\-rep
.TP
.B
\-no\-scalar\-rep
.RS
.TP
Enables or disables the scalar replacement optimization done by the compiler as part of loop transformations.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-scalar\-rep 
.NL
Scalar replacement is performed during loop transformation at optimization levels of O2 and above.
.TP
\fBDescription:\fR 
.PP
This option enables or disables the scalar replacement optimization done by the compiler as part of loop transformations. This option takes effect only if you specify an optimization level of O2 or higher.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-shared (L*X only)
.RS
.TP
Tells the compiler to produce a dynamic shared object instead of an executable.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler produces an executable.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to produce a dynamic shared object (DSO) instead of an executable. This includes linking in all libraries dynamically and passing \-shared to the linker.
.NL
.PP
You must specify option fpic for the compilation of each object file you want to include in the shared library.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-shared\-intel
.RS
.TP
Causes Intel\-provided libraries to be linked in dynamically.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Intel(R)
libraries are linked in statically, with the exception of Intel\[aq]s OpenMP* runtime support library, which is linked in dynamically.
.TP
\fBDescription:\fR 
.PP
This option causes Intel\-provided libraries to be linked in dynamically. It is the opposite of \-static\-intel.
.NL
.PP
This option is processed by the ifort (icc/icpc) command that initiates linking, adding library names explicitly to the link command.
.NL
.PP
If you specify option \-mcmodel=medium or \-mcmodel=large, it sets option \-shared\-intel. 
.NL
.PP
.B NOTE:
On OS X* systems, when you set "Intel Runtime Libraries" to "Dynamic", you must also set the DYLD_LIBRARY_PATH environment variable within Xcode* or an error will be displayed.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-shared\-libgcc (L*X only)
.RS
.TP
Links the GNU libgcc library dynamically.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-shared\-libgcc
.NL
The compiler links the libgcc library dynamically.
.TP
\fBDescription:\fR 
.PP
This option links the GNU libgcc library dynamically. It is the opposite of option static\-libgcc.
.NL
.PP
This option is processed by the ifort (icc/icpc) command that initiates linking, adding library names explicitly to the link command.
.NL
.PP
This option is useful when you want to override the default behavior of the static option, which causes all libraries to be linked statically.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-simd
.TP
.B
\-no\-simd
.RS
.TP
Enables or disables compiler
interpretation of 
simd pragmas. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-simd 
.NL
SIMD 
pragmas are enabled. 
.TP
\fBDescription:\fR 
.PP
This option enables or disables compiler interpretation of 
simd pragmas. 
.NL
.PP
To disable interpretation of 
simd pragmas, specify 
\-no\-simd (Linux* and OS X*) or 
/Qsimd\- (Windows*). Note that the compiler may still vectorize
loops based on its own heuristics (leading to generation of SIMD instructions)
even when 
\-no\-simd (or 
/Qsimd\-) is specified. 
.NL
.PP
To disable all compiler vectorization, use the "\-no\-vec
\-no\-simd" (Linux* and OS X*) or "/Qvec\- /Qsimd\-"
(Windows*) compiler options. The option 
\-no\-vec (and 
/Qvec\-) disables all auto\-vectorization, including
vectorization of array notation statements. The option 
\-no\-simd (and 
/Qsimd\-) disables vectorization of loops that have 
simd pragmas. 
.NL
.PP
.B NOTE:
If you specify option 
\-mia32 or option 
/arch:IA32, 
simd pragmas are disabled by default.
When you specify option 
\-mia32 or option 
/arch:IA32, vector instructions cannot be used. Therefore,
you cannot explicitly enable SIMD 
pragmas by specifying option 
[Q]simd. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-simd\-function\-pointers
.TP
.B
\-no\-simd\-function\-pointers
.RS
.TP
Enables or disables pointers to
simd\-enabled functions. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-simd\-function\-pointers 
.NL
Pointers to simd\-enabled functions are disabled.
Vector specifications can only be placed in function declarations and
definitions. 
.TP
\fBDescription:\fR 
.PP
This option enables or disables pointers to simd\-enabled functions. 
.NL
.PP
When option 
[Q]simd\-function\-pointers is specified, it defines
simd\-enabled (vector) function pointers by placing vector specifications with
all usual clauses in function pointer declarations. The vector specifications
must be indicated in an attribute vector declaration or in pragma 
omp declare simd. 
.NL
.PP
These pointers can enable indirect calls to appropriate vector versions of
the function from a simd loop or another simd\-enabled function. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-sox[=keyword[,keyword]] (L*X only)
.TP
.B
\-no\-sox (L*X only)
.RS
.TP
Tells the compiler to save the compilation options and version number in the executable file.  It also lets you choose whether to include lists of certain functions.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is the function information to include. Possible values are:
.RS
.TP 15
inline
Includes a list of the functions that were inlined in each object.
.TP 15
profile
Includes a list of the functions that were compiled with the \-prof\-use option and for which the .dpi file had profile information, and an indication for each as to whether the profile information was USED (matched) or IGNORED (mismatched).
.RE
.TP
\fBDefault:\fR 
.TP 18
\-no\-sox
.NL
The compiler does not save these informational strings in the object file.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to save the compilation options and version number in the executable file.  It also lets you choose whether to include lists of certain functions.  The information is embedded as a string in each object file or assembly output.
.NL
.PP
If you specify option sox with no \fIkeyword\fR,
the compiler saves the compiler options and version number used in
the compilation of the objects that make up the
executable.
.NL
.PP
When you specify this option, the size of the executable on disk is
increased slightly. Each \fIkeyword\fR  you specify
increases the size of the executable.
When you link the object files into an executable file, the linker
places each of the information strings into the header of the
executable. It is then possible to use a tool, such as a strings
utility, to determine what options were used to build the
executable file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-static (L*X only)
.RS
.TP
Prevents linking with shared libraries.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler links with shared libraries.
.TP
\fBDescription:\fR 
.PP
This option prevents linking with shared libraries. It causes the executable to link all libraries statically.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-static\-intel
.RS
.TP
Causes Intel\-provided libraries to be linked in statically.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
ON
.NL
Intel
libraries are linked in statically, with the exception of Intel\[aq]s OpenMP* runtime support library, which is linked in dynamically.
.TP
\fBDescription:\fR 
.PP
This option causes Intel\-provided libraries to be linked in statically. It is the opposite of \-shared\-intel.
.NL
.PP
This option is processed by the ifort (icc/icpc) command that initiates linking, adding library names explicitly to the link command.
.NL
.PP
If you specify option \-static\-intel while option \-mcmodel=medium or \-mcmodel=large is set, an error will be displayed.
.NL
.PP
If you specify option static\-intel and any of the Intel\-provided libraries have no static version, a diagnostic will be displayed.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-staticlib (M*X only)
.RS
.TP
Invokes the libtool command to generate static libraries.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler produces an executable.
.TP
\fBDescription:\fR 
.PP
This option invokes the libtool command to generate static libraries. This option is processed by the command that initiates linking, adding library names explicitly to the link command.
.NL
.PP
When passed this option, the compiler uses the libtool command to produce a static library instead of an executable when linking. 
.NL
.PP
To build dynamic libraries, you should specify option \-dynamiclib or libtool \-dynamic <objects>.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-static\-libgcc (L*X only)
.RS
.TP
Links the GNU libgcc library statically.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler links the GNU libgcc library dynamically.
.TP
\fBDescription:\fR 
.PP
This option links the GNU libgcc library statically. It is the opposite of option \-shared\-libgcc.
.NL
.PP
This option is processed by the ifort (icc/icpc) command that initiates linking, adding library names explicitly to the link command.
.NL
.PP
This option is useful when you want to override the default behavior, which causes the library to be linked dynamically.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-static\-libstdc++ (L*X only)
.RS
.TP
Links the GNU libstdc++ library statically.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler links the GNU libstdc++ library dynamically.
.TP
\fBDescription:\fR 
.PP
This option links the GNU libstdc++ library statically.  This option is processed by the ifort (icc/icpc) command that initiates linking, adding library names explicitly to the link command.
.NL
.PP
This option is useful when you want to override the default behavior, which causes the library to be linked dynamically.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-std=val
.RS
.TP
Tells the compiler to conform to a
specific language standard. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIval\fR
.NL
Specifies the specific language standard to conform
to. Possible values are: 
.RS
.TP 15
c++14
Enables support for the 2014 ISO C++ standard
features. The following features are available: 
.RS
.IP \(bu 2
Tweaked working for contextual conversion
.IP \(bu 2
Binary literals 
.IP \(bu 2
decltype(auto), return type deduction for
normal functions 
.IP \(bu 2
Initialized lambda captures:
simple\-capture, init\-captur 
.IP \(bu 2
Generic lambda expressions 
.IP \(bu 2
Variable templates 
.IP \(bu 2
Extended constexpr 
.IP \(bu 2
NSDMIs for aggregates 
.IP \(bu 2
Avoiding/fusing allocations 
.IP \(bu 2
[deprecated] attributes 
.IP \(bu 2
Sized deallocation 
.IP \(bu 2
Single\-Quotation\-Mark as a digit
separator 
.RE
.TP 15
c++11
Enables support for many C++11 (formerly
known as C++0x) features. The following features are available: 
.RS
.IP \(bu 2
Defining move special member functions
(N3053) 
.IP \(bu 2
Explicit virtual overrides
(N2928,N3206,N3272) 
.IP \(bu 2
Full implementation of constexpr (this
feature is only available on Linux* and OS X* systems) 
.IP \(bu 2
Full implementation of initializer lists 
.IP \(bu 2
Full implementation of noexcept 
.IP \(bu 2
Full implementation of non static data
members (i.e. field initializers) 
.IP \(bu 2
Raw string literals and UTF\-8 literals 
.IP \(bu 2
Delegating constructors 
.IP \(bu 2
Ref\-qualifiers on member functions 
.IP \(bu 2
Additional type trait helpers (for example,
__is_nothrow_assignable, __is_trivially_assignable,
__is_trivially_constructible, __bases, __direct_bases, etc.) 
.RE
.IP
For a list of C++11 features that were
previously implemented by the Intel(R) C++ Compiler, see the article titled 
C++11 Features Supported by Intel(R) C++ Compiler,
which is located in
http://software.intel.com/en\-us/articles/c0x\-features\-supported\-by\-intel\-c\-compiler/
.TP 15
c89
Conforms to the ISO/IEC 9899:1990
International Standard. This value is only available on Linux* and OS X*
systems. 
.TP 15
c99
Conforms to The ISO/IEC 9899:1999
International Standard. 
.TP 15
gnu89
Conforms to ISO C90 plus GNU* extensions.
This value is only available on Linux* and OS X* systems. 
.TP 15
gnu99
Conforms to ISO C99 plus GNU* extensions.
This value is only available on Linux* and OS X* systems. 
.TP 15
gnu++98
Conforms to the 1998 ISO C++ standard plus
GNU extensions. This value is only available on Linux* and OS X* systems. 
.TP 15
c++0x
This value is equivalent to specifying value 
c++11. 
.TP 15
gnu++0x
This value is equivalent to specifying value 
c++0x. This value is only available on Linux*
and OS X* systems. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-std=gnu89 (default for
C)
.NL
Conforms to ISO C90 plus GNU extensions. 
.TP 18
\-std=gnu++98 (default for
C++)
.NL
Conforms to the 1998 ISO C++ standard plus GNU*
extensions. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to conform to a specific
language standard. 
.NL
.PP
On Windows* systems, you can only specify values 
c99 and 
c++0x. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-stdlib[=keyword] (M*X only)
.TP
.B
(M*X only)
.RS
.TP
Lets you select the C++ library to be
used for linking. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is the function information to include. Possible
values are: 
.RS
.TP 15
libc++
Links using the libc++ library. 
.TP 15
libstdc++
Links using the GNU libstdc++ library. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-stdlib=libc++
.NL
The compiler links using the libc++ library. 
.TP
\fBDescription:\fR 
.PP
This option lets you select the C++ library to be used
for linking. This option is processed by the command that initiates linking,
adding library names explicitly to the link command. 
.NL
.PP
Currently, if you do not specify this option, the libc++
headers and library are used. 
.NL
.PP
.B NOTE:
The IDE provides another possible setting for option 
\-stdlib, which lets you choose the compiler default rather
than a specific library. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-strict\-ansi
.RS
.TP
Tells the compiler to implement strict
ANSI conformance dialect. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler conforms to default standards.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to implement strict ANSI
conformance dialect. On Linux* systems, if you need to be compatible with gcc,
use the 
\-ansi option.
.NL
.PP
This option sets option 
fmath\-errno, which tells the compiler to assume that the
program tests errno after calls to math library functions. This restricts
optimization because it causes the compiler to treat most math functions as
having side effects.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Tfilename (L*X only)
.RS
.TP
Tells the linker to read link commands from a file.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The linker does not read link commands from a file.
.TP
\fBDescription:\fR 
.PP
This option tells the linker to read link commands from a file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-tbb
.RS
.TP
Tells the compiler to link to the Intel(R)
Threading Building Blocks (Intel(R) TBB) libraries. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not link to the Intel(R) TBB
libraries. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to link to the Intel(R)
Threading Building Blocks (Intel(R) TBB) libraries and include the Intel(R) TBB
headers. 
.NL
.PP
.B NOTE:
On Windows* systems, this option is processed by the
compiler, which adds directives to the compiled object file that are processed
by the linker. On Linux* and OS X* systems, this option is processed by the
icc/icpc command that initiates linking, adding library names explicitly to the
link command. 
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-tcollect[lib] (L*X only)
.RS
.TP
Inserts instrumentation probes calling the Intel(R) Trace Collector API.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics Technology
.TP
\fBArguments:\fR 
.TP 18
\fIlib\fR
.NL
Is one of the Intel(R) Trace Collector libraries; for example, VT, VTcs, VTmc, or VTfs. If you do not specify \fIlib\fR, the default library is VT.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Instrumentation probes are not inserted into compiled applications.
.TP
\fBDescription:\fR 
.PP
This option inserts instrumentation probes calling the Intel(R) Trace Collector API. 
.NL
.PP
This trace analyzing/collecting feature requires installation of another product. For more information, see Feature Requirements.
.NL
.PP
This option provides a flexible and convenient way of instrumenting functions of a compiled application. For every function, the entry and exit points are instrumented at compile time to let the Intel(R) Trace Collector record functions beyond the default MPI calls. For non\-MPI applications (for example, threaded or serial), you must ensure that the Intel(R) Trace Collector is properly initialized (VT_initialize/VT_init).
.NL
.PP
.B CAUTION:
Be careful with full instrumentation because this feature can produce very large trace files.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-tcollect\-filter filename (L*X only)
.RS
.TP
Lets you enable or disable the
instrumentation of specified functions.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is a configuration file that lists filters, one per
line. Each filter consists of a regular expression string and a switch. Strings
with leading or trailing white spaces must be quoted. Other strings do not have
to be quoted. The switch value can be ON, on, OFF, or off.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Functions are not instrumented. However, if option 
\-tcollect
(Linux) is specified, the filter setting is ".* ON" and all functions
get instrumented. 
.TP
\fBDescription:\fR 
.PP
This option lets you enable or disable the
instrumentation of specified functions. 
.NL
.PP
During instrumentation, the regular expressions in the
file are matched against the function names. The switch specifies whether
matching functions are to be instrumented or not. Multiple filters are
evaluated from top to bottom with increasing precedence. 
.NL
.PP
The names of the functions to match against are formatted
as follows:
.NL
.IP \(bu 2
C++ function names are demangled and the C++ class
hierarchy is used. Function parameters are stripped to keep the function names
shorter. 
.IP \(bu 2
The source file name is followed by a colon\-separated
function name. Source file names should contain the full path, if available.
For example: 
.IP
/home/joe/src/foo.c:FOO_bar
.IP \(bu 2
Classes and function names are separated by double
colons. For example:
.IP
/home/joe/src/foo.cpp:app::foo::bar
.PP
You can use option 
[q or Q]opt\-report to get
a full list of file and function names that the compiler recognizes from the
compilation unit. This list can be used as the basis for filtering in the
configuration file.
.NL
.PP
This trace analyzing/collecting feature requires
installation of another product. For more information, see 
Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-traceback
.TP
.B
\-notraceback
.RS
.TP
Tells the compiler to generate extra information in the object file to provide source file traceback information when a severe error occurs at run time.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
notraceback
.NL
No extra information is generated in the object file to produce traceback information.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate extra information in the object file to provide source file traceback information when a severe error occurs at run time. This is intended for use with C code that is to be linked into a Fortran program.
.NL
.PP
When the severe error occurs, source file, routine name, and line number correlation information is displayed along with call stack hexadecimal addresses (program counter trace).
.NL
.PP
Note that when a severe error occurs, advanced users can also locate the cause of the error using a map file and the hexadecimal addresses of the stack displayed when the error occurs.
.NL
.PP
This option increases the size of the executable program, but has no impact on run\-time execution speeds.
.NL
.PP
It functions independently of the debug option.
.NL
.PP
On Windows* systems, traceback sets the /Oy\- option, which forces the compiler to use EBP as the stack frame pointer.
.NL
.PP
On Windows* systems, the linker places the traceback information in the executable image, in a section named ".trace". To see which sections are in an image, use the command:
.NL
.PP
link \-dump \-summary your_app_name.exe
.PP
.PP
To see more detailed information, use the command:
.NL
.PP
link \-dump \-headers your_app_name.exe
.PP
.PP
On Linux* systems, to display the section headers in the image (including the header for the .trace section, if any), use the command:
.NL
.PP
objdump \-h your_app_name.exe
.PP
.PP
On OS X* systems, to display the section headers in the image, use the command:
.NL
.PP
otool \-l your_app_name.exe
.PP
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wtrigraphs
.TP
.B
\-Wno\-trigraphs
.RS
.TP
Determines whether warnings are issued if any trigraphs are encountered that might change the meaning of the program.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-trigraphs
.NL
No warnings are issued if any trigraphs are encountered that might change the meaning of the program.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued if any trigraphs are encountered that might change the meaning of the program.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-u symbol
.RS
.TP
Tells the compiler the specified symbol is undefined.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Standard rules are in effect for variables.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler the specified \fIsymbol\fR is undefined.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Uname
.RS
.TP
Undefines any definition currently in effect for the specified macro.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the macro to be undefined.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Macro definitions are in effect until they are undefined.
.TP
\fBDescription:\fR 
.PP
This option undefines any definition currently in effect for the specified macro. It is equivalent to an #undef preprocessing directive.
.NL
.PP
On Windows systems, use the /u option to undefine all previously defined preprocessor values.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-unroll[=n]
.RS
.TP
Tells the compiler the maximum number of times to unroll loops.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the maximum number of times a loop can be unrolled. To disable loop enrolling, specify 0.
.TP
\fBDefault:\fR 
.TP 18
\-unroll 
.NL
The compiler uses default heuristics when unrolling loops.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler the maximum number of times to unroll loops.
.NL
.PP
If you do not specify \fIn\fR, the optimizer determines how many times loops can be unrolled.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-funroll\-loops
.NL
.RE
.TP
.B
\-unroll\-aggressive
.TP
.B
\-no\-unroll\-aggressive
.RS
.TP
Determines whether the compiler uses more aggressive unrolling for certain loops.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-unroll\-aggressive 
.NL
The compiler uses default heuristics when unrolling loops.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler uses more aggressive unrolling for certain loops. The positive form of the option may improve performance.
.NL
.PP
This option enables aggressive, complete unrolling for loops with small constant trip counts.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-use\-intel\-optimized\-headers
.RS
.TP
Determines whether the performance
headers directory is added to the include path search list. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
on IA\-32 architecture targeting Intel(R) Graphics Technology, or on Intel(R) 64
architecture targeting Intel(R) Graphics Technology 
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-use\-intel\-optimized\-headers
.NL
The performance headers directory is not added to
the include path search list. 
.TP
\fBDescription:\fR 
.PP
This option determines whether the performance headers
directory is added to the include path search list. 
.NL
.PP
The performance headers directory is added if you specify
[Q]use\-intel\-optimized\-headers. Appropriate libraries are also
linked in, as needed, for proper functionality. 
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-use\-msasm
.RS
.TP
Enables the use of blocks and entire functions of assembly code within a C or C++ file.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler allows a GNU*\-style inline assembly format.
.TP
\fBDescription:\fR 
.PP
This option enables the use of blocks and entire functions of assembly code within a C or C++ file.
.NL
.PP
It allows a Microsoft* MASM\-style inline assembly block not a GNU*\-style inline assembly block.
.NL
.TP
\fBAlternate Options:\fR 
.PP
\-fasm\-blocks
.NL
.RE
.TP
.B
\-V
.RS
.TP
Displays the compiler version information.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler version information is not displayed.
.TP
\fBDescription:\fR 
.PP
This option displays the startup banner, which contains the following compiler information:
.NL
.IP \(bu 2
The name of the compiler and its applicable architecture
.IP \(bu 2
The major and minor version of the compiler, the update number, and the package number(for example, Version 12.1.0.047)
.IP \(bu 2
The specific build and build date (for example, Build <builddate>)
.IP \(bu 2
The copyright date of the software
.PP
This option can be placed anywhere on the command line.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-v [filename]
.RS
.TP
Specifies that driver tool commands should be displayed and executed.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of a source file to be compiled. A space must appear before the file name.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No tool commands are shown.
.TP
\fBDescription:\fR 
.PP
This option specifies that driver tool commands should be displayed and executed. 
.NL
.PP
If you use this option without specifying a source file name, the compiler displays only the version of the compiler.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-vec
.TP
.B
\-no\-vec
.RS
.TP
Enables or disables vectorization.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-vec 
.NL
Vectorization is enabled if option 
O2 or higher is in effect.
.TP
\fBDescription:\fR 
.PP
This option enables or disables vectorization.
.NL
.PP
To disable vectorization, specify 
\-no\-vec (Linux* and OS
X*) or 
/Qvec\- (Windows*). 
.NL
.PP
To disable interpretation of SIMD 
pragmas, specify 
\-no\-simd (Linux* and OS X*) or 
/Qsimd\- (Windows*).
.NL
.PP
To disable all compiler vectorization, use the "\-no\-vec
\-no\-simd" (Linux* and OS X*) or "/Qvec\- /Qsimd\-"
(Windows*) compiler options. The option 
\-no\-vec (and 
/Qvec\-) disables all auto\-vectorization, including
vectorization of array notation statements. The option 
\-no\-simd (and 
/Qsimd\-) disables vectorization of loops that have SIMD 
pragmas. 
.NL
.PP
.B NOTE:
Using this option enables vectorization at default
optimization levels for both Intel(R) microprocessors and non\-Intel
microprocessors. Vectorization may call library routines that can result in
additional performance gain on Intel microprocessors than on non\-Intel
microprocessors. The vectorization can also be affected by certain options,
such as 
/arch (Windows), 
\-m (Linux and OS X), or 
[Q]x.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-vec\-guard\-write
.TP
.B
\-no\-vec\-guard\-write
.RS
.TP
Tells the compiler to perform a conditional check in a vectorized loop.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-vec\-guard\-write 
.NL
The  compiler  performs a conditional check in a vectorized loop.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to perform a conditional check in a vectorized loop. This checking avoids unnecessary stores and may improve performance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-vec\-threshold[n]
.RS
.TP
Sets a threshold for the vectorization of
loops. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an integer whose value is the threshold for the
vectorization of loops. Possible values are 0 through 100. 
.IP
If 
\fIn\fR is 0, loops
get vectorized always, regardless of computation work volume. 
.IP
If 
\fIn\fR is 100,
loops get vectorized when performance gains are predicted based on the compiler
analysis data. Loops get vectorized only if profitable vector\-level parallel
execution is almost certain. 
.IP
The intermediate 1 to 99 values represent the
percentage probability for profitable speed\-up. For example, 
\fIn\fR=50 directs
the compiler to vectorize only if there is a 50% probability of the code
speeding up if executed in vector form. 
.TP
\fBDefault:\fR 
.TP 18
\-vec\-threshold100 
.NL
Loops get vectorized only if profitable
vector\-level parallel execution is almost certain. This is also the default if
you do not specify 
\fIn\fR. 
.TP
\fBDescription:\fR 
.PP
This option sets a threshold for the vectorization of
loops based on the probability of profitable execution of the vectorized loop
in parallel. 
.NL
.PP
This option is useful for loops whose computation work
volume cannot be determined at compile\-time. The threshold is usually relevant
when the loop trip count is unknown at compile\-time. 
.NL
.PP
The compiler applies a heuristic that tries to balance
the overhead of creating multiple threads versus the amount of work available
to be shared amongst the threads. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-vecabi=keyword
.RS
.TP
Determines which vector function
application binary interface (ABI) the compiler uses to create or call vector
functions. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies which vector function ABI to use.
Possible values are: 
.RS
.TP 15
compat
Tells the compiler to use the
compatibility vector function ABI. This ABI includes Intel(R)\-specific features. 
.TP 15
cmdtarget
Tells the compiler to
generate an extended set of vector functions. The option is very similar to
setting 
compat. However, for 
compat, only one vector function is created,
while for 
cmdtarget, several vector functions are
created for each vector specification. Vector variants are created for targets
specified by compiler options 
[Q]x and/or 
[Q]ax. No change is made to the source code. 
.TP 15
gcc
Tells the compiler to use
the gcc vector function ABI. Use this setting only in cases when you want to
link with modules compiled by gcc. This setting is not available on Windows*
systems. 
.TP 15
legacy
Tells the compiler to use the
legacy vector function ABI. Use this setting if you need to keep the generated
vector function binary backward compatible with the vectorized binary generated
by older versions of the Intel(R) compilers (V13.1 or older). 
.RE
.TP
\fBDefault:\fR 
.TP 18
compat
.NL
The compiler uses the compatibility vector function
ABI. 
.TP
\fBDescription:\fR 
.PP
This option determines which vector function application binary interface
(ABI) the compiler uses to create or call vector functions. 
.NL
.PP
.B NOTE:
To avoid possible link\-time and run\-time errors, use
identical 
[Q]vecabi settings when compiling all files in an
application that define or use vector functions, including libraries. If
setting 
cmdtarget is specified, options 
[Q]x and/or 
[Q]ax must have identical values. 
.PP
Be careful using setting 
cmdtarget with libraries or program modules/routines
with vector function definitions that cannot be recompiled. In such cases,
setting 
cmdtarget may cause link errors. 
.PP
On Linux* systems, since the default is 
compat, you must specify 
legacy if you need to keep the generated vector function
binary backward compatible with the vectorized binary generated by the previous
version of Intel(R) compilers. 
.NL
.PP
When 
cmdtarget is specified, the additional vector function
versions are created by copying each vector specification and changing target
processor in the copy. The number of vector functions is determined by the
settings specified in options 
[Q]x and/or 
[Q]ax. 
.NL
.PP
For example, suppose we have the following function
declaration: 
.NL
.PP
__declspec (vector(processor(core_2_duo_sse4_1))) int foo(int a);
.PP
.PP
and the following options are specified:
\-axAVX,CORE\-AVX2
.NL
.PP
The following table shows the different
results for the above declaration and option specifications when setting 
compat or setting 
cmdtarget is used: 
.NL
.TP 18
\fBcompat 
\fR
.NL
.NL
\fBcmdtarget 
\fR
.NL
.NL
.TP 18
One vector version is created for Intel(R) SSE4.1 (by vector
function specification). 
.NL
Four vector versions are created for the following targets: 
.RS
.IP \(bu 2
Intel(R) SSE2 (default because no 
\-x option is used) 
.IP \(bu 2
Intel(R) SSE4.1 (by vector function specification) 
.IP \(bu 2
Intel(R) AVX (by the first 
\-ax option value) 
.IP \(bu 2
Intel(R) AVX2 (by the second 
\-ax option value) 
.RE
.NL
.PP
For more information about the Intel(R)\-compatible vector
functions ABI, see the Vector Function ABI document available in the Open
Specifications section at cilkplus.org. 
.NL
.PP
For more information about the GCC vector functions ABI,
see the item Libmvec \- vector math library document in the GLIBC wiki at
sourceware.org. 
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-\-version
.RS
.TP
Tells the compiler to display GCC\-style
version information. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner)
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Tells the compiler to display GCC\-style version
information. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-w
.RS
.TP
Disables all warning messages.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Default warning messages are enabled.
.TP
\fBDescription:\fR 
.PP
This option disables all warning messages.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: 
\-w0
.NL
.PP
Windows: 
/W0
.NL
.RE
.TP
.B
\-wn
.RS
.TP
Specifies the level of diagnostic messages to be generated by the compiler.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of diagnostic messages to be generated. Possible values are:
.RS
.TP 15
0
Enables diagnostics for errors. Disables diagnostics
for warnings.
.TP 15
1
Enables diagnostics for warnings and errors. 
.TP 15
2
Enables diagnostics for warnings and errors. On Linux* and OS X* systems, additional warnings are
enabled. On
Windows* systems, this setting is equivalent to level 1 (\fIn  \fR= 1).
.TP 15
3
Enables diagnostics for remarks, warnings, and errors. Additional warnings are also enabled above level 2 (\fIn\fR = 2). This level is recommended for production
purposes.
.TP 15
4
Enables diagnostics for all level 3 (\fIn\fR = 3) warnings plus informational warnings  and remarks, which in most cases can be safely ignored. This value is only available on Windows* systems.
.TP 15
5
Enables diagnostics for all remarks, warnings, and errors. This setting produces the most diagnostic messages. This value is only available on Windows* systems.
.RE
.TP
\fBDefault:\fR 
.TP 18
n=1
.NL
The compiler displays  diagnostics for warnings and errors.
.TP
\fBDescription:\fR 
.PP
This option specifies the level of diagnostic messages to be generated by the compiler.
.NL
.PP
On Windows systems, option /W4 is equivalent to option /Wall.
.NL
.PP
The \-w\fIn\fR, /W\fIn\fR, and  Wall options can override each other.  The last option specified on the command line takes precedence.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wa,option1[,option2,...]
.RS
.TP
Passes options to the assembler for processing.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIoption\fR
.NL
Is an assembler option. This option is not processed by the driver and is directly passed to the assembler.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed to the assembler.
.TP
\fBDescription:\fR 
.PP
This option passes one or more options to the assembler for processing. If the assembler is not invoked, these options are ignored.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wabi
.TP
.B
\-Wno\-abi
.RS
.TP
Determines whether a warning is issued if generated code is not C++ ABI compliant.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-abi
.NL
No warning is issued when generated code is not C++ ABI compliant.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued if generated code is not C++ ABI compliant.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wall
.RS
.TP
Enables warning and error diagnostics.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Only default warning diagnostics are enabled.
.TP
\fBDescription:\fR 
.PP
This option enables many warning and error diagnostics.
.NL
.PP
On Windows* systems, this option is equivalent to the /W4 option. It enables diagnostics for all level 3 warnings plus informational warnings and remarks.
.NL
.PP
However, on Linux* and OS X* systems, this
option is similar to gcc option \-Wall.  It displays all errors and some of the warnings that are typically reported by gcc option \-Wall. If you want to display all warnings, specify the \-w2 or \-w3 option. If you want to display remarks and
comments, specify the \-Wremarks option.
.NL
.PP
The Wall, \-w\fIn\fR, and /W\fIn\fR options can override each other.  The last option specified on the command line takes precedence.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-watch[=keyword[, 
keyword...]]
.TP
.B
\-nowatch
.RS
.TP
Tells the compiler to display certain
information to the console output window. 
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Determines what information is displayed. Possible
values are: 
.RS
.TP 15
none
Disables 
cmd and 
source. 
.TP 15
[no]cmd
Determines whether driver tool commands are
displayed and executed. 
.TP 15
[no]source
Determines whether the name of the file being
compiled is displayed. 
.TP 15
mic\-cmd
Enables display of compiler options that are
passed to the offload compilation. This keyword is only available on Intel(R) 64
architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner).
.TP 15
all
Enables 
cmd and 
source. 
.RE
.TP
\fBDefault:\fR 
.TP 18
nowatch
.NL
Pass information and source file names are not
displayed to the console output window. 
.TP
\fBDescription:\fR 
.PP
Tells the compiler to display processing information
(pass information and source file names) to the console output window. 
.NL
.TP 18
\fBOption 
watchkeyword\fR
.NL
.NL
\fBDescription 
\fR
.NL
.NL
.TP 18
none
.NL
Tells the compiler to not display pass
information and source file names to the console output window. This is the
same as specifying 
nowatch. 
.NL
.TP 18
cmd
.NL
Tells the compiler to display and execute
driver tool commands. 
.NL
.TP 18
source
.NL
Tells the compiler to display the name of the
file being compiled. 
.NL
.TP 18
mic\-cmd
.NL
Tells the compiler to display the compiler
options that are passed to the offload compilation. Only the options that are
automatically passed are displayed. If this keyword is specified on an
architecture other than Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner),
results vary. It may be ignored, have no effect, or produce an error. 
.NL
.TP 18
all
.NL
Tells the compiler to display pass information
and source file names to the console output window. This is the same as
specifying 
watch with no 
\fIkeyword\fR. 
For heterogeneous compilation, the tool commands for the host and the offload
compilations will be displayed.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
watch cmd
.NL
Linux and OS X: 
\-v
.RE
.TP
.B
\-Wbrief
.RS
.TP
Tells the compiler to display a shorter form of diagnostic output. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler displays its normal diagnostic output.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to display a shorter form of diagnostic output. In this form, the original source line is not displayed and the error message text is not wrapped when too long to fit on a single line.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-Wcheck
.RS
.TP
Tells the compiler to perform compile\-time code checking for certain code. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No compile\-time code checking is performed.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to perform compile\-time code checking for certain code. It specifies to check for code that exhibits non\-portable behavior, represents a possible unintended code sequence, or possibly affects operation of the program because of a quiet change in the ANSI C Standard. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wcomment
.TP
.B
\-Wno\-comment
.RS
.TP
Determines whether a warning is issued when /* appears in the middle of a /* */ comment.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-comment
.NL
No warning is issued when /* appears in the middle of a /* */ comment.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued when /* appears in the middle of a /* */ comment.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wcontext\-limit=n
.RS
.TP
Set the maximum number of template instantiation contexts shown in diagnostic.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Number of template instantiation contexts.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Set maximum number of template instantiation contexts shown in diagnostic.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wdeprecated
.TP
.B
\-Wno\-deprecated
.RS
.TP
Determines whether warnings are issued for deprecated C++ headers.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wdeprecated
.NL
The compiler issues warnings for deprecated C++ headers.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued for deprecated C++ headers. It has no effect in  C compilation
mode.
.NL
.PP
Option \-Wdeprecated enables
these warnings  by defining the __DEPRECATED macro for
preprocessor.
.NL
.PP
To disable warnings for deprecated C++ headers, specify \-Wno\-deprecated.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Weffc++
.RS
.TP
Enables warnings based on certain C++ programming guidelines.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Diagnostics are not enabled.
.TP
\fBDescription:\fR 
.PP
This option enables warnings based on certain programming guidelines developed by Scott Meyers in his books on effective C++ programming. With this option, the compiler emits warnings for these guidelines:
.NL
.IP \(bu 2
Use const and inline rather than #define. Note that you will only get this in user code, not system header code.
.IP \(bu 2
Use <iostream> rather than <stdio.h>.
.IP \(bu 2
Use new and delete rather than malloc and free.
.IP \(bu 2
Use C++ style comments in preference to C style comments. C comments in system headers are not diagnosed.
.IP \(bu 2
Use delete on pointer members in destructors. The compiler diagnoses any pointer that does not have a delete.
.IP \(bu 2
Make sure you have a user copy constructor and assignment operator in classes containing pointers.
.IP \(bu 2
Use initialization rather than assignment to members in constructors.
.IP \(bu 2
Make sure the initialization list ordering matches the declartion list ordering in constructors.
.IP \(bu 2
Make sure base classes have virtual destructors.
.IP \(bu 2
Make sure operator= returns *this.
.IP \(bu 2
Make sure prefix forms of increment and decrement return a const object.
.IP \(bu 2
Never overload operators &&, ||, and ,.
.PP
.B NOTE:
The warnings generated by this compiler option are based on the following books from Scott Meyers:
.IP \(bu 2
Effective C++ Second Edition \- 50 Specific Ways to Improve Your Programs and Designs
.IP \(bu 2
More Effective C++ \- 35 New Ways to Improve Your Programs and Designs
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Werror
.RS
.TP
Changes all warnings to errors.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler returns diagnostics as usual.
.TP
\fBDescription:\fR 
.PP
This option changes all warnings to errors.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-diag\-error warn
.NL
.RE
.TP
.B
\-Wextra\-tokens
.TP
.B
\-Wno\-extra\-tokens
.RS
.TP
Determines whether warnings are issued about extra tokens at the end of preprocessor directives. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-extra\-tokens
.NL
The compiler does not warn about extra tokens at the end of preprocessor directives.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued about extra tokens at the end of preprocessor directives.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wformat
.TP
.B
\-Wno\-format
.RS
.TP
Determines whether argument checking is enabled for calls to printf, scanf, and so forth.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-format
.NL
Argument checking is not enabled for calls to printf, scanf, and so forth.
.TP
\fBDescription:\fR 
.PP
This option determines whether argument checking is enabled for calls to printf, scanf, and so forth.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wformat\-security
.TP
.B
\-Wno\-format\-security
.RS
.TP
Determines whether the compiler issues a warning when the use of format functions may cause security problems. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-format\-security
.NL
No warning is issued when the use of format functions may cause security problems.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler issues a warning when the use of format functions may cause security problems. 
.NL
.PP
When \-Wformat\-security is specified, it warns about uses of format functions where the format string is not a string literal and there are no format arguments.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wic\-pointer
.TP
.B
\-Wno\-ic\-pointer
.RS
.TP
Determines whether warnings are issued for conversions between pointers to distinct scalar types with the same representation.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wic\-pointer
.NL
The compiler issues warnings for conversions between pointers to distinct scalar types with the same representation.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued for
conversions between pointers to distinct scalar types with the same
representation.
.NL
.PP
For example, consider the following:
.NL
.PP
void f(int *p) { long *q = p; }
.PP
.PP
In this case, by default, the compiler issues a
warning because of the conversion from pointer to int to pointer to long.
.NL
.PP
However, if you specify \-Wno\-ic\-pointer, and long and int values have the same representation on the target
platform, the warning will not be issued.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Winline
.RS
.TP
Warns when a function that is declared as inline is not inlined.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No warning is produced when a function that is declared as inline is not inlined.
.TP
\fBDescription:\fR 
.PP
This option warns when a function that is declared as inline is not inlined. 
.NL
.PP
To see diagnostic messages, including a message about why a particular function was not inlined, you should generate an optimization report by specifying option \-qopt\-report=5.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wl,option1[,option2,...]
.RS
.TP
Passes options to the linker for processing.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIoption\fR
.NL
Is a linker option. This option is not processed by the driver and is directly passed to the linker.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed to the linker.
.TP
\fBDescription:\fR 
.PP
This option passes one or more options to the linker for processing. If the linker is not invoked, these options are ignored.
.NL
.PP
This option is equivalent to specifying option \-Qoption,link,\fIoptions\fR.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wmain
.TP
.B
\-Wno\-main
.RS
.TP
Determines whether a warning is issued if the return type of main is not expected.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-main
.NL
No warning is issued if the return type of main is not expected.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued if the return type of main is not expected.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wmissing\-declarations
.TP
.B
\-Wno\-missing\-declarations
.RS
.TP
Determines whether warnings are issued for global functions and variables without prior declaration.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-missing\-declarations
.NL
No warnings are issued for global functions and variables without prior declaration.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued for global functions and variables without prior declaration.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wmissing\-prototypes
.TP
.B
\-Wno\-missing\-prototypes
.RS
.TP
Determines whether warnings are issued for missing prototypes.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-missing\-prototypes
.NL
No warnings are issued for missing prototypes.
.TP
\fBDescription:\fR 
.PP
Determines whether warnings are issued for missing prototypes.
.NL
.PP
If \-Wmissing\-prototypes is specified, it tells the compiler to detect global functions that are defined without a previous prototype declaration.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wnon\-virtual\-dtor
.RS
.TP
Tells the compiler to issue a warning when a class appears to be polymorphic, yet it declares a non\-virtual one. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not issue a warning.
.TP
\fBDescription:\fR 
.PP
Tells the compiler to issue a warning when a class appears to be polymorphic, yet it declares a non\-virtual one. This option is supported in C++ only.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wp,option1[,option2,...]
.RS
.TP
Passes options to the preprocessor.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIoption\fR
.NL
Is a preprocessor option. This option is not processed by the driver and is directly passed to the preprocessor.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed to the preprocessor.
.TP
\fBDescription:\fR 
.PP
This option passes one or more options to the preprocessor. If the preprocessor is not invoked, these options are ignored.
.NL
.PP
This option is equivalent to specifying option \-Qoption,\fIcpp\fR\fI, options\fR.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wp64
.RS
.TP
Tells the compiler to display diagnostics for 64\-bit porting. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not display diagnostics for 64\-bit porting.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to display diagnostics for 64\-bit porting.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wpch\-messages
.TP
.B
\-Wno\-pch\-messages
.RS
.TP
Determines whether the compiler shows
precompiled header (PCH) informational messages.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
Wpch\-messages
.NL
The compiler shows precompiled header (PCH)
informational messages.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler shows precompiled header (PCH)
informational messages. By default, these messages are displayed.
.NL
.PP
To suppress the display of the PCH informational messages, specify 
\-Wno\-pch\-messages (Linux* and OS X*) or 
/Wpch\-messages\- (Windows*).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wpointer\-arith
.TP
.B
\-Wno\-pointer\-arith
.RS
.TP
Determines whether warnings are issued for questionable pointer arithmetic.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-pointer\-arith
.NL
No warnings are issued for questionable pointer arithmetic.
.TP
\fBDescription:\fR 
.PP
Determines whether warnings are issued for questionable pointer arithmetic.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wremarks
.RS
.TP
Tells the compiler to display remarks and comments.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Default warning messages are enabled.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to display remarks and comments.
.NL
.PP
If you want to display warnings and errors, specify the \-Wall, \-w\fIn\fR, or /W\fIn\fR option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wreorder
.RS
.TP
Tells the compiler to issue a warning when the order of member initializers does not match the order in which they must be executed. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not issue a warning.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to issue a warning when the order of member initializers does not match the order in which they must be executed. This option is supported for C++ only.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wreturn\-type
.TP
.B
\-Wno\-return\-type
.RS
.TP
Determines whether warnings are issued when a function is declared without a return type, when the definition of a function returning void contains a return statement with an expression, or when the closing brace of a function returning non\-void is reached.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
ON for one condition
.NL
A warning is issued when the closing brace of a function returning non\-void is reached.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued for the following:
.NL
.IP \(bu 2
When a function is declared without a return type
.IP \(bu 2
When the definition of a function returning void contains a return statement with an expression
.IP \(bu 2
When the closing brace of a function returning non\-void is reached
.PP
Specify \-Wno\-return\-type if you do not want to see warnings about the above diagnostics.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wshadow
.TP
.B
\-Wno\-shadow
.RS
.TP
Determines whether a warning is issued when a variable declaration hides a previous declaration.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-shadow
.NL
No warning is issued when a variable declaration hides a previous declaration.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued when a variable declaration hides a previous declaration. Same as \-ww1599.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wsign\-compare
.TP
.B
\-Wno\-sign\-compare
.RS
.TP
Determines whether warnings are issued when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-sign\-compare
.NL
The compiler does not issue these warnings
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are
issued when a comparison between signed and unsigned values could
produce an incorrect result when the signed value is converted to
unsigned.
.NL
.PP
On Linux* systems, this option is provided for compatibility with
gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wstrict\-aliasing
.TP
.B
\-Wno\-strict\-aliasing
.RS
.TP
Determines whether warnings are issued for code that might violate the optimizer\[aq]s strict aliasing rules.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-strict\-aliasing
.NL
No warnings are issued for code that might violate the optimizer\[aq]s strict aliasing rules.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued for code that might violate the optimizer\[aq]s strict 
aliasing rules. These warnings will only be issued if you also specify option –ansi\-alias or 
option –fstrict\-aliasing.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wstrict\-prototypes
.TP
.B
\-Wno\-strict\-prototypes
.RS
.TP
Determines whether warnings are issued for functions declared or defined without specified argument types.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-strict\-prototypes
.NL
No warnings are issued for functions declared or defined without specified argument types.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued for functions declared or defined without specified argument types.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wtrigraphs
.TP
.B
\-Wno\-trigraphs
.RS
.TP
Determines whether warnings are issued if any trigraphs are encountered that might change the meaning of the program.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-trigraphs
.NL
No warnings are issued if any trigraphs are encountered that might change the meaning of the program.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued if any trigraphs are encountered that might change the meaning of the program.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wuninitialized
.TP
.B
\-Wno\-uninitialized
.RS
.TP
Determines whether a warning is issued if a variable is used before being initialized.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-uninitialized
.NL
No warning is issued if a variable is used before being initialized. 
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued if a variable is used before being initialized. Equivalent to \-ww592 and \-wd592.
.NL
.TP
\fBAlternate Options:\fR 
.PP
\-ww592 and \-wd592
.NL
.RE
.TP
.B
\-Wunknown\-pragmas
.TP
.B
\-Wno\-unknown\-pragmas
.RS
.TP
Determines whether a warning is issued if an unknown #pragma directive is used.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wunknown\-pragmas
.NL
A warning is issued if an unknown #pragma directive is used.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued if an unknown #pragma directive is used.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wunused\-function
.TP
.B
\-Wno\-unused\-function
.RS
.TP
Determines whether a warning is issued if a declared function is not used.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-unused\-function
.NL
No warning is issued if a declared function is not used.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued if a declared function is not used.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wunused\-variable
.TP
.B
\-Wno\-unused\-variable
.RS
.TP
Determines whether a warning is issued if a local or non\-constant static variable is unused after being declared.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-unused\-variable
.NL
No warning is issued if a local or non\-constant static variable is unused after being declared.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued if a local or non\-constant static variable is unused after being declared.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wwrite\-strings
.RS
.TP
Issues a diagnostic message if const char * is converted to (non\-const) char *.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No diagnostic message is issued if const char * is converted to (non\-const) char*.
.TP
\fBDescription:\fR 
.PP
This option issues a diagnostic message if const char* is converted to (non\-const) char *.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-x type
.RS
.TP
All source files found subsequent to \-x type will be recognized as a particular type.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fItype\fR
.NL
is the type of source file. Possible values are:
.RS
.TP 15
c++
C++ source file
.TP 15
c++\-header
C++ header file
.TP 15
c++\-cpp\-output
C++ pre\-processed file
.TP 15
c
C source file
.TP 15
c\-header
C header file
.TP 15
cpp\-output
C pre\-processed file
.TP 15
assembler
Assembly file
.TP 15
assembler\-with\-cpp
Assembly file that needs to be preprocessed
.TP 15
none
Disable recognition, and revert to file extension
.RE
.TP
\fBDefault:\fR 
.TP 18
none
.NL
Disable recognition and revert to file extension.
.TP
\fBDescription:\fR 
.PP
All source files found subsequent to \-x\fItype\fR will be recognized as a particular type.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-xcode
.RS
.TP
Tells the compiler which processor
features it may target, including which instruction sets and optimizations it
may generate. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.TP 18
\fIcode\fR
.NL
Indicates to the compiler a feature set that it
may target, including which instruction sets and optimizations it may generate.
Many of the following descriptions refer to Intel(R) Streaming SIMD Extensions
(Intel(R) SSE) and Supplemental Streaming SIMD Extensions (Intel(R) SSSE). Possible
values are: 
.RS
.TP 15
COMMON\-AVX512
May generate Intel(R) Advanced Vector
Extensions 512 (Intel(R) AVX\-512) Foundation instructions, Intel(R) AVX\-512
Conflict Detection instructions, as well as the instructions enabled with
CORE\-AVX2. Optimizes for Intel(R) processors that support Intel(R) AVX\-512
instructions. 
.TP 15
MIC\-AVX512
May generate Intel(R) Advanced Vector
Extensions 512 (Intel(R) AVX\-512) Foundation instructions, Intel(R) AVX\-512
Conflict Detection instructions, Intel(R) AVX\-512 Exponential and Reciprocal
instructions, Intel(R) AVX\-512 Prefetch instructions for Intel(R) processors, and
the instructions enabled with CORE\-AVX2. Optimizes for Intel(R) processors that
support Intel(R) AVX\-512 instructions. 
.IP
This keyword is only
available on Windows* and Linux* systems. 
.TP 15
CORE\-AVX512
May generate Intel(R) Advanced Vector
Extensions 512 (Intel(R) AVX\-512) Foundation instructions, Intel(R) AVX\-512
Conflict Detection instructions, Intel(R) AVX\-512 Doubleword and Quadword
instructions, Intel(R) AVX\-512 Byte and Word instructions and Intel(R) AVX\-512
Vector Length extensions, as well as the instructions enabled with CORE\-AVX2.
Optimizes for Intel(R) processors that support Intel(R) AVX\-512 instructions. 
.TP 15
CORE\-AVX2
May generate Intel(R) Advanced Vector
Extensions 2 (Intel(R) AVX2), Intel(R) AVX, SSE4.2, SSE4.1, SSE3, SSE2, SSE, and
SSSE3 instructions for Intel(R) processors. Optimizes for Intel(R) processors that
support Intel(R) AVX2 instructions. 
.TP 15
CORE\-AVX\-I
May generate 
Float\-16 conversion
instructions and 
the RDRND instruction, Intel(R) Advanced Vector Extensions
(Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions
for Intel(R) processors. Optimizes for Intel(R) processors that support 
Float\-16 conversion
instructions and 
the RDRND instruction. 
.TP 15
AVX
May generate Intel(R) Advanced Vector
Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3
instructions for Intel(R) processors. Optimizes for Intel processors that support
Intel(R) AVX instructions. 
.TP 15
SSE4.2
May generate Intel(R) SSE4 Efficient
Accelerated String and Text Processing instructions, Intel(R) SSE4 Vectorizing
Compiler and Media Accelerator, and Intel(R) SSE3, SSE2, SSE, and SSSE3
instructions for Intel(R) processors. Optimizes for Intel processors that support
Intel(R) SSE4.2 instructions. 
.TP 15
SSE4.1
May generate Intel(R) SSE4 Vectorizing
Compiler and Media Accelerator instructions for Intel(R) processors. May generate
Intel(R) SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel processors
that support Intel(R) SSE4.1 instructions. 
.TP 15
ATOM_SSE4.2
May generate MOVBE instructions for Intel(R)
processors, depending on the setting of option 
\-minstruction (Linux* and OS X*) or 
/Qinstruction (Windows*). May also generate Intel(R)
SSE4.2, SSE3, SSE2, and SSE instructions for Intel processors. Optimizes for
Intel(R) Atom(TM) processors that support Intel(R) SSE4.2 and MOVBE instructions. 
.IP
This keyword is only
available on Windows* and Linux* systems. 
.TP 15
ATOM_SSSE3
May generate MOVBE instructions for Intel(R)
processors, depending on the setting of option 
\-minstruction (Linux* and OS X*) or 
/Qinstruction (Windows*). May also generate SSSE3,
Intel(R) SSE3, SSE2, and SSE instructions for Intel processors. Optimizes for
Intel(R) Atom(TM) processors that support Intel(R) SSE3 and MOVBE instructions. 
.IP
This keyword is only
available on Windows* and Linux* systems. 
.TP 15
SSE3_ATOM and 
SSSE3_ATOM
These option settings are deprecated. They
have the same effect as specifying 
ATOM_SSSE3. 
.TP 15
SSSE3
May generate SSSE3 and Intel(R) SSE3, SSE2, and
SSE instructions for Intel(R) processors. Optimizes for Intel processors that
support SSSE3 instructions. For OS X* systems, this value is only supported on
Intel(R) 64 architecture. This replaces value T, which is deprecated. 
.TP 15
SSE3
May generate Intel(R) SSE3, SSE2, and SSE
instructions for Intel(R) processors. Optimizes for Intel processors that support
Intel(R) SSE3 instructions. For OS X* systems, this value is only supported on
IA\-32 architecture. 
.TP 15
SSE2
May generate Intel(R) SSE2 and SSE instructions
for Intel(R) processors. Optimizes for Intel processors that support Intel(R) SSE2
instructions. This value is not available on OS X* systems. 
.RE
.IP
You can also specify 
Host. For more information, see option 
[Q]xHost. 
.TP
\fBDefault:\fR 
.TP 18
Windows* systems: None Linux* systems: None OS X* systems using IA\-32
architecture: 
SSE3 OS X* systems using Intel(R) 64
architecture: 
SSSE3
.NL
On Windows systems, if neither 
/Qx nor 
/arch is specified, the default is 
/arch:SSE2. 
.IP
On Linux systems, if neither 
\-x nor 
\-m is specified, the default is 
\-msse2. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler which processor features
it may target, including which instruction sets and optimizations it may
generate. It also enables optimizations in addition to Intel feature\-specific
optimizations. 
.NL
.PP
The specialized code generated by this option may only
run on a subset of Intel(R) processors. 
.NL
.PP
The resulting executables created from these option 
\fIcode\fR values can only
be run on Intel(R) processors that support the indicated instruction set. 
.NL
.PP
The binaries produced by these 
\fIcode\fR values will run
on Intel(R) processors that support the specified features. 
.NL
.PP
Do not use 
\fIcode\fR values to
create binaries that will execute on a processor that is not compatible with
the targeted processor. The resulting program may fail with an illegal
instruction exception or display other unexpected behavior. 
.NL
.PP
Compiling the 
function main() with
any of the 
\fIcode\fR values produces
binaries that display a fatal run\-time error if they are executed on
unsupported processors, including all non\-Intel processors. 
.NL
.PP
Compiler options 
m and 
arch produce binaries
that should run on processors not made by Intel that implement the same
capabilities as the corresponding Intel(R) processors. 
.NL
.PP
The 
\-x and 
/Qx options enable
additional optimizations not enabled with options 
\-m or 
/arch (nor with options 
–ax and 
/Qax). 
.NL
.PP
On Windows systems, options 
/Qx and /arch are
mutually exclusive. If both are specified, the compiler uses the last one
specified and generates a warning. Similarly, on Linux and OS X systems,
options 
\-x and 
\-m are mutually
exclusive. If both are specified, the compiler uses the last one specified and
generates a warning. 
.NL
.PP
.B NOTE:
All settings except SSE2 do a CPU
check. However, if you specify option –O0 (Linux* or OS X*) or option /Od
(Windows*), no CPU check is performed. 
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-X
.RS
.TP
Removes standard directories from the
include file search path.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Standard directories are in the include file search
path.
.TP
\fBDescription:\fR 
.PP
This option removes standard directories from the include
file search path. It prevents the compiler from searching the default path
specified by the 
INCLUDE environment
variable.
.NL
.PP
On Linux* and OS X* systems, specifying 
\-X (or 
\-noinclude) prevents the
compiler from searching in 
/usr/include for files specified in an INCLUDE statement. 
.NL
.PP
You can use this option with the 
I option to prevent the
compiler from searching the default path for include files and direct it to use
an alternate path.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: 
\-nostdinc
.NL
.RE
.TP
.B
\-xHost
.RS
.TP
Tells the compiler to generate
instructions for the highest instruction set available on the compilation host
processor. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting the 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner), on IA\-32 architecture targeting Intel(R)
Graphics Technology, or on Intel(R) 64 architecture targeting Intel(R) Graphics
Technology
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
Windows* systems: None Linux* systems: None OS X* systems using IA\-32
architecture: 
\-xSSE3 OS X* systems using Intel(R) 64
architecture: 
\-xSSSE3
.NL
On Windows systems, if neither 
/Qx nor 
/arch is specified, the default is 
/arch:SSE2. 
.IP
On Linux systems, if neither 
\-x nor 
\-m is specified, the default is 
\-msse2. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate instructions
for the highest instruction set available on the compilation host processor. 
.NL
.PP
The instructions generated by this compiler option differ depending on the
compilation host processor. 
.NL
.PP
The following table describes the effects of specifying the 
[Q]xHost option and it tells whether the resulting executable
will run on processors different from the host processor. 
.NL
.PP
Descriptions in the table refer to Intel(R) Advanced Vector Extensions 2
(Intel(R) AVX2), Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) Streaming
SIMD Extensions (Intel(R) SSE), and Supplemental Streaming SIMD Extensions
(SSSE). 
.NL
.TP 18
\fBInstruction Set of Host Processor 
\fR
.NL
.NL
\fBEffects When the \-xHost or /QxHost Compiler
Option is Specified 
\fR
.NL
.NL
.TP 18
Intel(R) AVX\-512 
.NL
When compiling for 
Intel(R) Xeon Phi(TM) coprocessor (code name
Knights Landing),
corresponds to option 
[Q]xMIC\-AVX512. The generated executable will not
run on non\-Intel processors and it will not run on Intel processors that do not
support all of Intel(R) AVX\-512 foundation, conflict detection, prefetch, and
exponential and reciprocal instructions.
.NL
.TP 18
Intel(R) AVX2 
.NL
When compiling on Intel(R) processors: 
.TP 18
Corresponds to option 
[Q]xCORE\-AVX2. The generated executable will not run
on non\-Intel processors and it will not run on Intel(R) processors that do not
support Intel(R) AVX2 instructions. 
.TP 18
When compiling on non\-Intel processors: 
.TP 18
Corresponds to option 
\-march=core\-avx2 (Linux* and OS X*) or 
/arch:CORE\-AVX2 (Windows*). The generated executable
will run on Intel(R) processors and non\-Intel processors that support at least
Intel(R) AVX2 instructions.. You may see a run\-time error if the run\-time
processor does not support Intel(R) AVX2 instructions. 
.NL
.TP 18
Intel(R) AVX 
.NL
When compiling on Intel(R) processors: 
.TP 18
Corresponds to option 
[Q]xAVX. The generated executable will not run on
non\-Intel processors and it will not run on Intel(R) processors that do not
support Intel(R) AVX instructions. 
.TP 18
When compiling on non\-Intel processors: 
.TP 18
Corresponds to option 
\-mavx (Linux and OS X) or 
/arch:AVX (Windows). The generated executable will
run on Intel(R) processors and non\-Intel processors that support at least Intel(R)
AVX instructions. You may see a run\-time error if the run\-time processor does
not support Intel(R) AVX instructions. 
.NL
.TP 18
Intel(R) SSE4.2 
.NL
When compiling on Intel(R) processors: 
.TP 18
Corresponds to option 
[Q]xSSE4.2. The generated executable will not run on
non\-Intel processors and it will not run on Intel(R) processors that do not
support Intel(R) SSE4.2 instructions. 
.TP 18
When compiling on non\-Intel processors: 
.TP 18
Corresponds to option 
\-msse4.2 (Linux and OS X) or 
/arch:SSE4.2 (Windows). The generated executable
will run on Intel(R) processors and non\-Intel processors that support at least
Intel(R) SSE4.2 instructions. You may see a run\-time error if the run\-time
processor does not support Intel(R) SSE4.2 instructions. 
.NL
.TP 18
Intel(R) SSE4.1 
.NL
When compiling on Intel(R) processors: 
.TP 18
Corresponds to option 
[Q]xSSE4.1. The generated executable will not run on
non\-Intel processors and it will not run on Intel(R) processors that do not
support Intel(R) SSE4.1 instructions. 
.TP 18
When compiling on non\-Intel processors: 
.TP 18
Corresponds to option 
\-msse4.1 (Linux and OS X) or 
/arch:SSE4.1 (Windows). The generated executable
will run on Intel(R) processors and non\-Intel processors that support at least
Intel(R) SSE4.1 instructions. You may see a run\-time error if the run\-time
processor does not support Intel(R) SSE4.1 instructions. 
.NL
.TP 18
SSSE3 
.NL
When compiling on Intel(R) processors: 
.TP 18
Corresponds to option 
[Q]xSSSE3. The generated executable will not run on
non\-Intel processors and it will not run on Intel(R) processors that do not
support SSSE3 instructions. 
.TP 18
When compiling on non\-Intel processors: 
.TP 18
Corresponds to option 
\-mssse3 (Linux and OS X) or 
/arch:SSSE3 (Windows). The generated executable will
run on Intel(R) processors and non\-Intel processors that support at least SSSE3
instructions. You may see a run\-time error if the run\-time processor does not
support SSSE3 instructions. 
.NL
.TP 18
Intel(R) SSE3 
.NL
When compiling on Intel(R) processors: 
.TP 18
Corresponds to option 
[Q]xSSE3. The generated executable will not run on
non\-Intel processors and it will not run on Intel(R) processors that do not
support Intel(R) SSE3 instructions. 
.TP 18
When compiling on non\-Intel processors: 
.TP 18
Corresponds to option 
\-msse3 (Linux and OS X) or 
/arch:SSE3 (Windows). The generated executable will
run on Intel(R) processors and non\-Intel processors that support at least Intel(R)
SSE3 instructions. You may see a warning run\-time error if the run\-time
processor does not support Intel(R) SSE3 instructions. 
.NL
.TP 18
Intel(R) SSE2 
.NL
When compiling on Intel(R) processors or non\-Intel processors: 
.TP 18
Corresponds to option 
\-msse2 (Linux and OS X) or 
/arch:SSE2 (Windows). The generated executable will
run on Intel(R) processors and non\-Intel processors that support at least Intel(R)
SSE2 instructions. You may see a run\-time error if the run\-time processor does
not support Intel(R) SSE2 instructions. 
.NL
.PP
For more information on other settings for option 
[Q]x, see that option description. 
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None 
.NL
.RE
.TP
.B
\-Xlinker option
.RS
.TP
Passes a linker option directly to the linker.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIoption\fR
.NL
Is a linker option.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed directly to the linker.
.TP
\fBDescription:\fR 
.PP
This option passes a linker option directly to the linker.
If \-Xlinker \-shared is specified, only \-shared is passed to the linker and no special work is done to ensure proper linkage for generating a shared object. \-Xlinker just takes whatever arguments are supplied and passes them directly to the linker.
.NL
.PP
If you want to pass compound options to the linker, for example "\-L $HOME/lib", you must use the following method:
.NL
.PP
\-Xlinker \-L \-Xlinker $HOME/lib
.PP
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Zp[n]
.RS
.TP
Specifies alignment for structures on byte boundaries.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the byte size boundary. Possible values are 1, 2, 4, 8, or 16.
.TP
\fBDefault:\fR 
.TP 18
Zp16
.NL
Structures are aligned on either size boundary 16 or the boundary that will naturally align them.
.TP
\fBDescription:\fR 
.PP
This option specifies alignment for structures on byte boundaries. 
.NL
.PP
If you do not specify \fIn\fR, you get Zp16.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.SH PREDEFINED MACROS 
.PP
The Intel(R) C++ Compiler documentation describes the predefined macros in detail. This section provides a brief summary of the supported macros. 
.PP
The ANSI/ISO standard for C language requires that certain predefined macros be supplied with conforming compilers. The GNU* gcc predefined macros are all set depending on what version of gcc is found on the user\[aq]s system. (This is overridden if the 
\-gcc\-version compiler option is passed on the command line.) 
.PP
You can specify the 
\-no\-gcc option if you do not want these macros defined. If you need gcc interoperability (\-cxxlib), do not use the 
\-no\-gcc compiler option. 
.PP
You can use the 
\-U option to suppress an automatic definition of a predefined macro. This option suppresses any macro definition currently in effect for the specified name. This option performs the same function as an 
#undef preprocessor directive. 
.PP
The following table lists the predefined macros on systems based on either the IA\-32 or Intel(R) 64 architecture.
.PP
.TP 18
\fBMacro 
\fR
.NL
.NL
\fBDescription 
\fR
.NL
.NL
.TP 18
__APPLE__ (OS X*) 
.NL
1 
.NL
.TP 18
__APPLE_CC__ (OS X*) 
.NL
gcc* build number 
.NL
.TP 18
__ARRAY_OPERATORS (Linux*) 
.NL
1 
.NL
.TP 18
__AVX__ (Windows*, Linux*) 
.NL
Defined and value to
\[aq]1\[aq] with /arch:AVX (Windows*) or 
–march=corei7\-avx or 
–mavx (Linux*), or 
[Q]xAVX or higher processor targeting options. 
.TP 18
.PP
.B NOTE:
Available only for compilations targeting 
Intel(R) 64 architecture. 
.NL
.TP 18
__AVX2__ (Windows*, Linux*) 
.NL
Defined and value to
\[aq]1\[aq] with arch:CORE\-AVX2
(Windows*) or 
march=core\-avx2 (Linux*), or 
[Q]xCORE\-AVX2 or higher processor targeting
options. 
.TP 18
.PP
.B NOTE:
Available only for compilations targeting 
Intel(R) 64 architecture. 
.NL
.TP 18
__AVX512BW__ (Windows*,
Linux*, OS X*) 
.NL
Defined as \[aq]1\[aq] for processors that support Intel(R) Advanced
Vector Extensions 512 (Intel(R) AVX\-512) Byte and Word instructions. 
.TP 18
It is also defined as \[aq]1\[aq] when option [Q]xCORE\-AVX512 or
higher processor\-targeting options are specified. 
.NL
.TP 18
__AVX512CD__ 
(Windows*, Linux*, OS X*) 
.NL
Defined as \[aq]1\[aq] for processors that support Intel(R) Advanced
Vector Extensions 512 (Intel(R) AVX\-512) Conflict Detection instructions. 
.TP 18
It is also defined as \[aq]1\[aq] when option [Q]xCORE\-AVX512,
[Q]xCOMMON\-AVX512, [Q]xMIC\-AVX512 or higher processor\-targeting options are
specified. 
.NL
.TP 18
__AVX512DQ__ 
(Windows*, Linux*, OS X*) 
.NL
Defined as \[aq]1\[aq] for processors that support Intel(R) Advanced
Vector Extensions 512 (Intel(R) AVX\-512) Doubleword and Quadword instructions. 
.TP 18
It is also defined as \[aq]1\[aq] when option [Q]xCORE\-AVX512 or
higher processor\-targeting options are specified. 
.NL
.TP 18
__AVX512ER__ (Windows*,
Linux*, OS X*) 
.NL
Defined as \[aq]1\[aq] for processors that support Intel(R) Advanced
Vector Extensions 512 (Intel(R) AVX\-512) Exponential and Reciprocal instructions.
.TP 18
It is also defined as \[aq]1\[aq] when option [Q]xMIC\-AVX512 or
higher processor\-targeting options are specified. 
.NL
.TP 18
__AVX512F__ (Windows*,
Linux*, OS X*) 
.NL
Defined as \[aq]1\[aq] for processors that support Intel(R) Advanced
Vector Extensions 512 (Intel(R) AVX\-512) Foundation instructions. 
.TP 18
It is also defined as \[aq]1\[aq] when option [Q]xCORE\-AVX512,
[Q]xCOMMON\-AVX512, [Q]xMIC\-AVX512 or higher processor\-targeting options are
specified. 
.NL
.TP 18
__AVX512PF__ 
(Windows*, Linux*, OS X*) 
.NL
Defined as \[aq]1\[aq] for processors that support Intel(R) Advanced
Vector Extensions 512 (Intel(R) AVX\-512) Prefetch instructions. 
.TP 18
It is also defined as when option [Q]xMIC\-AVX512 or higher
processor\-targeting options are specified. 
.NL
.TP 18
__AVX512VL__ (Windows*,
Linux*, OS X*) 
.NL
Defined as \[aq]1\[aq] for processors that support Intel(R) Advanced
Vector Extensions 512 (Intel(R) AVX\-512) Vector Length extensions. 
.TP 18
It is also defined as \[aq]1\[aq] when option [Q]xCORE\-AVX512 or
higher processor\-targeting options are specified. 
.NL
.TP 18
__BASE_FILE__ (Linux*) 
.NL
Name of source file 
.NL
.TP 18
__cilk (Windows*, Linux*) 
.NL
200; however, if you specify 
[Q]cilk\-serialize or the negative form of 
[Q]intel\-extensions, the value is undefined. 
.NL
.TP 18
__cplusplus (Linux*) 
.NL
1 (with C++ compiler) 
.NL
.TP 18
__DEPRECATED (Linux*) 
.NL
1 
.NL
.TP 18
__DYNAMIC__ (OS X*) 
.NL
1 
.NL
.TP 18
__EDG__ (Windows*, Linux*, OS X*) 
.NL
1 
.NL
.TP 18
__EDG_VERSION__ (Windows*, Linux*, OS X*) 
.NL
EDG version 
.NL
.TP 18
__ELF__ (Linux*) 
.NL
1 
.NL
.TP 18
__EXCEPTIONS (Linux*) 
.NL
Defined as \[aq]1\[aq]
when option 
fno\-exceptions is not used. 
.NL
.TP 18
__extension__ (Linux*) 
.NL
  
.NL
.TP 18
__gnu_linux__ (Linux*) 
.NL
1 
.NL
.TP 18
__GFX__ (Windows*, Linux*) 
.NL
You can use this macro to protect code that should only be
compiled for and executed on Intel(R) Graphics Technology. 
.TP 18
Defined by default. Builds code that runs on the CPU and the
target, but this macro is only defined during the target compilation. Undefined
when you use the negative form of the 
[Q]offload
option. 
.NL
.TP 18
__GNUC__ (Linux*) 
.NL
The major version number of gcc* installed
on the system. 
.NL
.TP 18
__GNUC_MINOR__ (Linux*) 
.NL
The minor version number of gcc* or g++*
installed on the system. 
.NL
.TP 18
__GNUC_PATCHLEVEL__ (Linux*) 
.NL
The patch level version number of gcc* or
g++* installed on the system. 
.NL
.TP 18
__GNUG__ (Linux*) 
.NL
The major version number of g++* installed
on the system. 
.NL
.TP 18
__GXX_ABI_VERSION (Linux*) 
.NL
102 (Linux*) 
.NL
.TP 18
__HONOR_STD (Linux*, OS X*) 
.NL
1 
.NL
.TP 18
__i386 (Linux*, OS X*) 
.TP 18
__i386__ (Linux*, OS X*) 
.TP 18
i386 (Linux*, OS X*) 
.NL
1 
.TP 18
.PP
.B NOTE:
Available only for compilations targeting IA\-32
architecture. 
.NL
.TP 18
__INTEL_COMPILER (Linux*, OS X*) 
.TP 18
__ICC (Linux*, OS X*) 
.NL
Intel(R)
C++ Compiler version. This is display as 1600 for version 16.0, 1700 for
version 17.0, and so on. 
.TP 18
.PP
.B NOTE:
This macro
may be affected by command line compiler options, such as 
/Qicl\- or 
\-no\-icc
.NL
.TP 18
__INTEL_CLANG_COMPILER (OS X*) 
.NL
Guards code to be compiled exclusively with
clang\-compatibleIntel(R)
C++ Compiler. 
.NL
.TP 18
__INTEL_COMPILER_BUILD_DATE (Windows*,
Linux*, OS X*) 
.NL
YYYYMMDD 
.NL
.TP 18
__INTEL_CXX11_MODE__ (Windows*, Linux*) 
.NL
Enables C++11 experimental support for C++ programs. 
.TP 18
Defined as \[aq]1\[aq]
when 
[Q]std=c++11 is specified. 
.NL
.TP 18
__INTEL_COMPILER_UPDATE
.NL
Returns the current minor update number of the 
Intel(R) C++ 
Compiler, starting at 0. (Windows*, Linux*, OS X*) 
.TP 18
You can use this 
macro to differentiate between compiler updates when you have multiple updates of the 
Intel(R) C++ 
Compiler installed concurrently. 
.TP 18
\fB Example: 
\fRIntel(R) C++ Compiler 
version 
\fIXX.0.2\fR, the macro would preprocess to “2”. 
.NL
.TP 18
__INTEL_OFFLOAD
.NL
Defined by the compiler when building code to run on the CPU and on the coprocessor. (Windows*, Linux*) 
.TP 18
You can use this 
macro in conjunction with the negative form of the 
[Q]offload compiler option, or the 
Qmic (Windows*) or 
mmic (Linux*) compiler option to protect code on the host that should only be executed for an offload build, such as calls to the 
omp_set_num_threads_target family of APIs in 
offload.h. 
.TP 18
Defined by default. Builds code that runs on the CPU and the coprocessor. Undefined when you use the negative form of the 
[Q]offload compiler option, or the 
Qmic (Windows*) or 
mmic (Linux*) compiler option. 
.NL
.TP 18
__INTEL_RTTI__ (Linux*, OS X*) 
.NL
Defined as \[aq]1\[aq]
when option 
fno\-rtti is not specified. 
.NL
.TP 18
__INTEL_STRICT_ANSI__ (Linux*, OS X*) 
.NL
Defined as \[aq]1\[aq]
when option 
strict\-ansi is specified. 
.NL
.TP 18
__KNC__
.NL
This 
macro is similar to 
__MIC__, but it is defined by the compiler while building code to run on the variant of the 
Intel(R) MIC Architecture known as the 
Intel(R) Xeon Phi(TM) coprocessor. (Windows*, Linux*) 
.NL
.TP 18
__linux (Linux*) 
.TP 18
__linux__ (Linux*) 
.TP 18
linux (Linux*) 
.NL
1 
.NL
.TP 18
__LITTLE_ENDIAN__ (OS X*) 
.NL
1 
.NL
.TP 18
__LONG_DOUBLE_SIZE__ (Windows*, Linux*, OS
X*) 
.NL
80 (Linux*, OS X*) 
.TP 18
64, 80 with option 
[Q]long\-double (Windows*) 
.NL
.TP 18
__LONG_DOUBLE_64__ (Linux*) 
.NL
When this macro is defined, the long double type is 64\-bits. 
.TP 18
Defined when you use option 
mlong\-double with 64 as an argument. 
.NL
.TP 18
__LONG_MAX__ (Linux*) 
.NL
9223372036854775807L 
.TP 18
.PP
.B NOTE:
Available only for compilations targeting Intel(R) 64
architecture. 
.NL
.TP 18
__LP64__ (Linux*) 
.NL
1 
.TP 18
.PP
.B NOTE:
Available only for compilations targeting Intel(R) 64
architecture. 
.NL
.TP 18
__MACH__ (OS X*) 
.NL
1 
.NL
.TP 18
__MIC__
.NL
Defined by the compiler while building code to run on the coprocessor. (Windows*, Linux*) 
.TP 18
You can use this 
macro to protect code that should only be compiled for and executed on the coprocessor, such as intrinsic functions that only run on 
Intel(R) MIC Architecture, or the corresponding header files, such as 
zmmintrin.h. 
.TP 18
Defined by default. Builds code that runs on the CPU and the coprocessor, but this 
macro is only defined during the coprocessor compilation. Undefined when you use the negative form of the 
[Q]offload option. 
.TP 18
To build code that runs only on the coprocessor, use the 
Qmic (Windows*) or 
mmic (Linux*) compiler option. 
.TP 18
This 
macro is defined when you use 
Qmic (Windows*) or 
mmic (Linux*). 
.NL
.TP 18
__MMX__ (Linux*, OS X*) 
.NL
1 
.NL
.TP 18
__NO_INLINE__ (Linux*, OS X*) 
.TP 18
__NO_MATH_INLINES (Linux*, OS X*) 
.TP 18
__NO_STRING_INLINES (Linux*, OS X*) 
.NL
1 
.NL
.TP 18
OFFLOAD_STATUS_INIT(\fIstatusvarname\fR ) 
.NL
Initializes the variable for the 
status clause in an 
offload pragma to a known value before offloading code. (Windows*, Linux*) 
.TP 18
After the offload, you can examine 
\fIstatusvarname\fR to check if the pragma was executed at all, whether the offload succeeded or failed, and, if relevant, why it failed. 
.TP 18
See 
offload. 
.NL
.TP 18
__OPTIMIZE__ (Linux*, OS X*) 
.NL
1 
.NL
.TP 18
__pentium4 (Linux*, OS X*) 
.TP 18
__pentium4__ (Linux*, OS X*) 
.NL
1 
.NL
.TP 18
__PIC__ (Linux*, OS X*) 
.TP 18
__pic__ (Linux*) 
.NL
1 (OS X*) 
.TP 18
Defined as
\[aq]1\[aq] when option 
fPIC is specified. (Linux*) 
.NL
.TP 18
__PTRDIFF_TYPE__ (Linux*, OS X*) 
.NL
int on IA\-32 architecture; long on Intel(R)
64 architecture (Linux*) 
.TP 18
int / long (OS X*) 
.NL
.TP 18
__QMSPP_ (Windows*, OS X*) 
.NL
1 
.NL
.TP 18
__REGISTER_PREFIX__ (Linux*, OS X*) 
.NL
  
.NL
.TP 18
__SIGNED_CHARS__ (Windows*, Linux*, OS X*) 
.NL
1 
.NL
.TP 18
__SIZE_TYPE__ (Linux*, OS X*) 
.NL
unsigned on IA\-32 architecture; unsigned
long on Intel(R) 64 architecture (Linux*) 
.TP 18
unsigned long (OS X*) 
.NL
.TP 18
__SSE__ (Windows*, Linux*, OS X*) 
.NL
Defined as \[aq]1\[aq]
for processors that support SSE instructions. (Linux* and OS X*) 
.TP 18
Defined and value to
\[aq]1\[aq], only undefined when /arch:IA32 (Windows*) 
.NL
.TP 18
__SSE2__ (Windows*, Linux*, OS X*) 
.NL
Defined as \[aq]1\[aq]
for processors that support Intel(R) SSE2 instructions. (Linux* and OS X*) 
.TP 18
Defined and value to
\[aq]1\[aq] by default or with 
arch:SSE2, 
QxSSE2, 
QaxSSE2 or higher processor targeting options
(Windows*) 
.NL
.TP 18
__SSE3__ (Windows*, Linux*, OS X*) 
.NL
Defined as \[aq]1\[aq]
for processors that support Intel(R) SSE3 instructions. (Linux* and OS X*) 
.TP 18
Defined and value to
\[aq]1\[aq] with 
arch:SSE3, 
QxSSE3 or higher processor targeting options.
(Windows*) 
.NL
.TP 18
__SSE4_1__ (Windows*, Linux*) 
.NL
Defined as \[aq]1\[aq]
for processors that support Intel(R) SSE4 instructions. (Linux*) 
.TP 18
Defined and value to
\[aq]1\[aq] with /arch:SSE4.1, /QxSSE4.1 or higher
processor targeting options (Windows*) 
.NL
.TP 18
__SSE4_2__ (Windows*, Linux*) 
.NL
Defined as \[aq]1\[aq]
for processors that support SSSE4 instructions. (Linux*) 
.TP 18
Defined and value to
\[aq]1\[aq] with 
arch:SSE4.2, 
QxSSE4.2 or higher processor targeting options
(Windows*) 
.NL
.TP 18
__SSSE3__ (Windows*, Linux*, OS X*) 
.NL
Defined as \[aq]1\[aq]
for processors that support SSSE3 instructions. (Linux* and OS X*) 
.TP 18
Defined and value to
\[aq]1\[aq] with 
arch:SSSE3, 
QxSSSE3 or higher processor targeting options
(Windows*) 
.NL
.TP 18
__STDC__ (OS X*) 
.NL
1 
.NL
.TP 18
__STDC_HOSTED__ (OS X*) 
.NL
1 
.NL
.TP 18
__TARGET_ARCH_MIC (Windows*, Linux*) 
.NL
Defined as \[aq]1\[aq]
while building code to run on the 
Intel(R) Xeon Phi(TM) coprocessor (code name
Knights Landing)
during offload compilation. 
.TP 18
It is defined by default when you specify 
\-qoffload\-arch=mic\-avx512 (Linux*) or 
/Qoffload\-arch=mic\-avx512 (Windows*). 
.TP 18
You can specify this symbol to protect code
that should only be compiled for and executed on the Intel(R) Xeon Phi(TM) (code
name Knights Landing) during offloading.   
.NL
.TP 18
__USER_LABEL_PREFIX__ (Linux*, OS X*) 
.NL
  
.NL
.TP 18
__VERSION__ (Linux*, OS X*) 
.NL
Intel(R) C++ Compiler version string 
.NL
.TP 18
__WCHAR_MAX__ (OS X*) 
.NL
2147483647 
.NL
.TP 18
__WCHAR_T (Linux*) 
.NL
1 
.NL
.TP 18
__WCHAR_TYPE__ (Linux*, OS X*) 
.NL
long int on IA\-32 architecture; int on
Intel(R) 64 architecture (Linux*) 
.TP 18
long int (OS X*) 
.NL
.TP 18
__WINT_TYPE__ (Linux*, OS X*) 
.NL
unsigned int 
.NL
.TP 18
__x86_64 (Linux*, OS X*) 
.TP 18
__x86_64__ (Linux*, OS X*) 
.NL
1 
.TP 18
.PP
.B NOTE:
Available only for compilations targeting Intel(R) 64
architecture. 
.NL
.TP 18
_BOOL (Linux*) 
.NL
1 
.NL
.TP 18
_LP64 (Linux*) 
.NL
1 
.TP 18
.PP
.B NOTE:
Available only for compilations targeting Intel(R) 64
architecture. 
.NL
.TP 18
_MT (Windows*, Linux*) 
.NL
1 when multithreaded DLL or library is used
(MD[d] or 
MT[d] specified) (Windows*) 
.TP 18
1 (Linux*) 
.TP 18
.PP
.B NOTE:
On Linux*, available only for compilations targeting
Intel(R) 64 architecture. 
.NL
.TP 18
_OPENMP (Windows*, Linux*, OS X*) 
.NL
201307 when you specify option 
[Q]openmp. 
.NL
.TP 18
_PGO_INSTRUMENT (Windows*, Linux*) 
.NL
\[aq]1\[aq] when
options 
[Q]cov\-gen or 
[Q]prof\-gen are specified. 
.NL
.TP 18
_PLACEMENT_DELETE (Linux*) 
.NL
1 
.NL
.TP 18
unix (Linux*) 
.TP 18
__unix (Linux*) 
.TP 18
__unix__ (Linux*) 
.NL
1 
.NL
.SH Supported Environment Variables
.PP
You can customize your system environment by
specifying paths where the compiler searches for certain files such as
libraries, include files, configuration files, and certain settings. 
.SS Compiler Compile\-Time Environment
Variables
.PP
The following table shows the compile\-time
environment variables that affect the compiler: 
.NL
.TP 18
\fBCompile\-Time Environment Variable 
\fR
.NL
.NL
\fBDescription 
\fR
.NL
.NL
.TP 18
CILK_NWORKERS (Windows*, Linux*) 
.NL
Specifies the number of worker threads to
use in an Intel(R) Cilk(TM) Plus program. 
.NL
.TP 18
IA32ROOT (IA\-32 architecture and Intel(R) 64
architecture) 
.NL
Points to the directories containing the
include and library files for a non\-standard installation structure. 
.NL
.TP 18
ICCCFG
.NL
Specifies the configuration file for
customizing compilations when invoking the compiler using 
.B icc
. 
.NL
.TP 18
ICPCCFG
.NL
Specifies the configuration file for
customizing compilations when invoking the compiler using 
.B icpc
. 
.NL
.TP 18
ICLCFG (OS X*) 
.NL
Specifies the configuration file for customizing
compilations when invoking the compiler using 
.B icl
. Valid for OS X* v10.9 or later only. 
.NL
.TP 18
ICLXXCFG (OS X*) 
.NL
Specifies the configuration file for customizing
compilations when invoking the compiler using 
.B icl++
. Valid for OS X* v10.9 or later
only. 
.NL
.TP 18
ICLCFG (Windows) 
.NL
Specifies a configuration file, which the
compiler should use instead of the default configuration file. 
.NL
.TP 18
INTEL_LICENSE_FILE
.NL
Specifies the location for the Intel
license file. 
.NL
.TP 18
__INTEL_PRE_CFLAGS
.TP 18
__INTEL_POST_CFLAGS
.NL
Specifies a set of compiler options to
add to the compile line. 
.TP 18
This is an extension to the facility already provided in the
compiler configuration file 
icl.cfg. 
.TP 18
.PP
.B NOTE:
By default, a configuration file named 
icl.cfg (Windows*), 
icc.cfg (Linux*, OS X*), or 
icpc.cfg (Linux*, OS X*) 
is used.
This file is in the same directory as the compiler executable. To use another
configuration file in another location, you can use the 
ICLCFG
(Windows*), 
ICCCFG
(Linux*, OS X*), or 
ICPCCFG
(Linux*, OS X*) 
environment variable to assign the directory and file name for the
configuration file. 
.TP 18
You can insert command line options in the prefix position
using 
__INTEL_PRE_CFLAGS
or in the suffix position using 
__INTEL_POST_CFLAGS.
The command line is built as follows: 
.TP 18
\fB Syntax:\fR(On Windows, use 
. On
Linux or OS X use 
icc)icc\fI<PRE flags> 
\fR\fI<flags from configuration file> 
\fR\fI<flags from the compiler
invocation> 
\fR\fI<POST flags> 
\fR
.PP
.B NOTE:
The driver issues a warning that the
compiler is overriding an option because of an environment variable, but only
when you include the option 
/W5 (Windows*) or 
\-w3 (Linux* and OS X*). 
.NL
.TP 18
PATH
.NL
Specifies the directories the system
searches for binary executable files. 
.PP
.B NOTE:
On
Windows* this also affects the search for Dynamic Link Libraries (DLLs). 
.NL
.TP 18
TMP
.TP 18
TMPDIR
.TP 18
TEMP
.NL
Specifies the location for temporary
files. If none of these are specified, or writeable, or found, the compiler
stores temporary files in 
/tmp
(Linux, OS X) or the current directory (Windows). 
.TP 18
The compiler searches for these variables
in the following order: 
TMP, 
TMPDIR, and 
TEMP. 
.NL
.TP 18
LD_LIBRARY_PATH (Linux*) 
.NL
Specifies the location for shared objects
(.so files). 
.NL
.TP 18
DYLD_LIBRARY_PATH (OS X*) 
.NL
Specifies the path for dynamic libraries.
.NL
.TP 18
LIB (Windows*) 
.NL
Specifies the directories for all
libraries used by the compiler and linker. 
.NL
.TP 18
\fB Intel(R) MIC Architecture Environment Variables\fR
.NL
.TP 18
MIC_LIBRARY_PATH
.NL
Specifies the location on the host for target\-specific
static libraries for 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner).
Use 
LIBRARY_PATH for the
location of host\-specific static libraries on a host system, including those
for the 
Intel(R) Xeon Phi(TM) coprocessor (code name
Knights Landing).
.NL
.TP 18
\fB GNU Environment Variables
and Extensions\fR
.NL
.TP 18
CPATH (Linux* and OS X*) 
.NL
Specifies the path to include directory for C/C++ compilations. 
.NL
.TP 18
C_INCLUDE_PATH (Linux* and OS X*) 
.NL
Specifies path to include directory for C
compilations. 
.NL
.TP 18
CPLUS_INCLUDE_PATH (Linux* and OS X*) 
.NL
Specifies path to include directory for
C++ compilations. 
.NL
.TP 18
DEPENDENCIES_OUTPUT (Linux* and OS X*) 
.NL
Specifies how to output dependencies for
make based on the non\-system header files processed by the compiler. System
header files are ignored in the dependency output. 
.NL
.TP 18
GCC_EXEC_PREFIX (Linux*) 
.NL
Specifies alternative names for the
linker (.B ld
) and assembler (.B as
). 
.NL
.TP 18
GCCROOT (Linux*) 
.NL
Specifies the location of the gcc*
binaries. 
.TP 18
Set this variable only when the compiler
cannot locate the gcc binaries when using the 
\-gcc\-name option. 
.NL
.TP 18
GXX_INCLUDE (Linux*) 
.NL
Specifies the location of the gcc
headers. Set this variable to specify the locations of the gcc installed files
when the compiler does not find the needed values as specified by the use of 
\-gcc\-name=\fIdirectory\-name\fR/gcc or 
\-gxx\-name=\fIdirectory\-name\fR/g++. 
.NL
.TP 18
GXX_ROOT (Linux*) 
.NL
Specifies the location of the gcc
binaries. Set this variable to specify the locations of the gcc installed files
when the compiler does not find the needed values as specified by the use of 
\-gcc\-name=\fIdirectory\-name\fR/gcc or 
\-gxx\-name=\fIdirectory\-name\fR/g++. 
.NL
.TP 18
LIBRARY_PATH (Linux* and OS X*) 
.NL
Specifies the path for libraries to be used during the link
phase. 
.NL
.TP 18
SUNPRO_DEPENDENCIES (Linux*)
.NL
This variable is the same as 
DEPENDENCIES_OUTPUT, except that system
header files are not ignored. 
.NL
.SS Compiler Run\-Time Environment
Variables
.PP
The following table summarizes compiler environment
variables that are recognized at run time. 
.NL
.TP 18
\fBRun\-Time Environment Variable 
\fR
.NL
.NL
\fBDescription 
\fR
.NL
.NL
.TP 18
INTEL_CHKP_REPORT_MODE (Linux*) 
.NL
Changes the pointer checker reporting mode at runtime. 
.TP 18
See Finding and Reporting
Out\-of\-Bounds Errors. 
.NL
.TP 18
\fB GNU extensions (recognized
by the Intel(R) OpenMP compatibility library)\fR
.NL
.TP 18
GOMP_CPU_AFFINITY (Linux*) 
.NL
GNU extension recognized by the Intel(R) OpenMP compatibility
library. Specifies a list of OS processor IDs. 
.TP 18
You must set this environment variable before the first
parallel region or before certain API calls including 
omp_get_max_threads(), 
omp_get_num_procs() and any affinity API
calls. For detailed information on this environment variable, see 
\fIThread Affinity Interface\fR. 
.TP 18
\fB Default:\fR Affinity is disabled 
.NL
.TP 18
GOMP_STACKSIZE (Linux*) 
.NL
GNU extension recognized by the Intel(R)
OpenMP compatibility library. Same as 
OMP_STACKSIZE.KMP_STACKSIZE overrides 
GOMP_STACKSIZE, which overrides 
OMP_STACKSIZE.
.TP 18
\fB Default:\fR See the description for 
OMP_STACKSIZE. 
.NL
.TP 18
\fB OpenMP* Environment Variables (OMP_) and Extensions
(KMP_) 
\fR
.NL
.TP 18
OMP_CANCELLATION
.NL
Activates cancellation of the innermost enclosing region of
the type specified. If set to true, the effects of the cancel construct and of
cancellation points are enabled and cancellation is activated. If set to false,
cancellation is disabled and the cancel construct and cancellation points are
effectively ignored. 
.TP 18
.PP
.B NOTE:
Internal barrier code will work
differently depending on whether the cancellation is enabled. Barrier code
should repeatedly check the global flag to figure out if the cancellation had
been triggered. If a thread observes the cancellation it should leave the
barrier prematurely with the return value 1 (may wake up other threads).
Otherwise, it should leave the barrier with the return value 0. 
.TP 18
Enables (true) or disables (false) cancellation of the innermost
enclosing region of the type specified. 
.TP 18
\fB Default:\fR FALSE 
.TP 18
\fB Example: 
\fROMP_CANCELLATION=true
.NL
.TP 18
OMP_DISPLAY_ENV
.NL
Enables (TRUE) or disables (FALSE) the printing to stderr of the OpenMP
version number and the values associated with the OpenMP environment variable. 
.TP 18
Possible values are: TRUE, FALSE, or
VERBOSE. 
.TP 18
\fB Default:\fR FALSE 
.TP 18
\fB Example:\fROMP_DISPLAY_ENV=true
.NL
.TP 18
OMP_DEFAULT_DEVICE
.NL
Sets the device that will be used in a target region. The
OpenMP routine 
omp_set_default_device or a 
device clause in a 
parallelpragma can override this variable. 
.TP 18
If no device with the specified device number exists, the
code is executed on the host. If this environment variable is not set, device
number 0 is used. 
.NL
.TP 18
OMP_DYNAMIC
.NL
Enables (true) or disables (false) the dynamic adjustment of the number
of threads. 
.TP 18
\fB Default:\fR FALSE 
.TP 18
\fB Example:\fROMP_DYNAMIC=true
.NL
.TP 18
OMP_MAX_ACTIVE_LEVELS
.NL
The maximum number of levels of parallel
nesting for the program. 
.TP 18
\fB Default:\fR 1 
.TP 18
\fB Syntax:\fROMP_MAX_ACTIVE_LEVELS=true
.NL
.TP 18
OMP_NESTED
.NL
Enables (true) or disables (false) nested parallelism. 
.TP 18
\fB Default:\fR FALSE 
.TP 18
\fB Example:\fROMP_NESTED=true
.NL
.TP 18
OMP_NUM_THREADS
.NL
Sets the maximum number of threads to use
for OpenMP* parallel regions if no other value is specified in the application.
.TP 18
The value can be a single integer, in
which case it specifies the number of threads for all parallel regions. The
value can also be a comma\-separated list of integers, in which case each
integer specifies the number of threads for a parallel region at a nesting
level. 
.TP 18
The first position in the list represents
the outer\-most parallel nesting level, the second position represents the
next\-inner parallel nesting level, and so on. At any level, the integer can be
left out of the list. If the first integer in a list is left out, it implies
the normal default value for threads is used at the outer\-most level. If the
integer is left out of any other level, the number of threads for that level is
inherited from the previous level. 
.TP 18
This environment variable applies to the
options 
Qopenmp (Windows)
or 
qopenmp (Linux and OS X), or 
Qparallel (Windows) or 
qparallel (Linux and OS X.. 
.TP 18
\fB Default:\fR The number of processors
visible to the operating system 
on which the program is
executed.
.TP 18
\fB Syntax:\fROMP_NUM_THREADS=value[,value]*
.NL
.TP 18
OMP_PLACES
.NL
Specifies an explicit ordered list of places, either as an
abstract name describing a set of places or as an explicit list of places
described by nonnegative numbers. An exclusion operator “!” can also be used to
exclude the number or place immediately following the operator. 
.TP 18
For 
\fB explicit lists\fR, the meaning of the numbers and how the
numbering is done for a list of nonnegative numbers are implementation defined.
Generally, the numbers represent the smallest unit of execution exposed by the
execution environment, typically a hardware thread. 
.TP 18
Intervals can be specified using the 
<lower\-bound> : 
<length> : 
<stride> notation to represent the
following list of numbers: 
.PP
"<lower\-bound>, <lower\-bound> + <stride>, ..., 
<lower\-bound> +(<length>\-1)*<stride>."
.PP
When 
<stride> is omitted, a unit stride is
assumed. Intervals can specify numbers within a place as well as sequences of
places. 
.PP
# EXPLICIT LIST EXAMPLE
setenv OMP_PLACES "{0,1,2,3},{4,5,6,7},{8,9,10,11},{12,13,14,15}"
setenv OMP_PLACES "{0:4},{4:4},{8:4},{12:4}"
setenv OMP_PLACES "{0:4}:4:4"
.PP
.TP 18
The 
\fB abstract names\fR listed below should be understood by
the execution and runtime environment: 
.TP 18
.IP \(bu 2
threads: Each place
corresponds to a single hardware thread on the target machine. 
.IP \(bu 2
cores: Each place
corresponds to a single core (having one or more hardware threads) on the
target machine. 
.IP \(bu 2
sockets: Each place
corresponds to a single socket (consisting of one or more cores) on the target
machine. 
.TP 18
When requesting fewer places or more resources than
available on the system, the determination of which resources of type 
abstract_name are to be included in the
place list is implementation\-defined. The precise definitions of the abstract
names are implementation defined. An implementation may also add abstract names
as appropriate for the target platform. The abstract name may be appended by a
positive number in parentheses to denote the length of the place list to be
created, that is 
abstract_name(\fInum\-places\fR).
.PP
# ABSTRACT NAMES EXAMPLE
setenv OMP_PLACES threads
setenv OMP_PLACES threads(4)
.PP
.PP
.B NOTE:
If any numerical values cannot be mapped to a processor on
the target platform the behavior is implementation\-defined. The behavior is
also implementation\-defined when the 
OMP_PLACES environment variable is
defined using an abstract name. 
.NL
.TP 18
OMP_PROC_BIND (Windows, Linux) 
.NL
Sets the thread affinity policy to be used for parallel
regions at the corresponding nested level. Enables (true) or
disables (false) the binding of threads to processor
contexts. If enabled, this is the same as specifying 
KMP_AFFINITY=scatter. If disabled, this is
the same as specifying 
KMP_AFFINITY=none. 
.TP 18
\fB Acceptable values:\fRTrue, 
false, or a comma separated list, each
element of which is one of the following values: 
master, 
close, 
spread. 
.TP 18
\fB Default: 
\fRFalse
.TP 18
If set to false, the execution environment may move OpenMP*
threads between OpenMP* places, thread affinity is disabled, and proc_bind
clauses on parallel constructs are ignored. Otherwise, the execution
environment should not move OpenMP* threads between OpenMP* places, thread
affinity is enabled, and the initial thread is bound to the first place in the
OpenMP* place list. 
.TP 18
If set to 
master, all threads are bound to the same
place as the master thread. If set to 
close, threads are bound to successive
places, close to where the master thread is bound. If set to 
spread, the master thread\[aq]s partition is
subdivided and threads are bound to single place successive sub\-partitions. 
.PP
.B NOTE:
KMP_AFFINITY takes precedence over 
GOMP_CPU_AFFINITY and 
OMP_PROC_BIND. 
GOMP_CPU_AFFINITY takes precedence over 
OMP_PROC_BIND. 
.NL
.TP 18
OMP_SCHEDULE
.NL
Sets the run\-time schedule type and an
optional chunk size. 
.TP 18
\fB Default:\fRSTATIC, no chunk
size specified 
.TP 18
\fB Example syntax:\fROMP_SCHEDULE="kind[,chunk_size]"
.TP 18
= = = = = = = = =
=
.PP
.B NOTE:
Some environment variables are available for
both Intel(R) microprocessors and non\-Intel microprocessors, but may perform
additional optimizations for Intel(R) microprocessors than for non\-Intel
microprocessors.
= = = = = = = = =
=
.NL
.TP 18
OMP_STACKSIZE
.NL
Sets the number of bytes to allocate for
each OpenMP* thread to use as the private stack for the thread. Recommended
size is 16M. 
.TP 18
Use the optional suffixes to specify byte
units: 
B (bytes), 
K (Kilobytes), 
M (Megabytes), 
G (Gigabytes), or 
T (Terabytes) to specify the units. If you
specify a value without a suffix, the byte unit is assumed to be 
K (Kilobytes). 
.TP 18
This variable does not affect the native
operating system threads created by the user program, or the thread executing
the sequential part of an OpenMP* program or parallel programs created using
the option 
Qparallel (Windows) or 
qparallel (Linux and OS X). 
.TP 18
The 
kmp_{set,get}_stacksize_s() routines
set/retrieve the value. The 
kmp_set_stacksize_s() routine must be called
from sequential part, before first parallel region is created. Otherwise,
calling 
kmp_set_stacksize_s() has no effect. 
.TP 18
\fB Default (IA\-32 architecture):\fR 2M 
.TP 18
\fB Default (Intel(R) 64 architecture):\fR
4M 
.TP 18
\fB Default (Intel(R) MIC
architecture):\fR4M (on supported OSes) 
.TP 18
\fB Related environment variables:\fRKMP_STACKSIZE
(overrides 
OMP_STACKSIZE). 
.TP 18
\fB Syntax:\fROMP_STACKSIZE=value
.NL
.TP 18
OMP_THREAD_LIMIT
.NL
Limits the number of
simultaneously\-executing threads in an OpenMP* program. 
.TP 18
If this limit is reached and another
native operating system thread encounters OpenMP* API calls or constructs, the
program can abort with an error message. If this limit is reached when an
OpenMP* parallel region begins, a one\-time warning message might be generated
indicating that the number of threads in the team was reduced, but the program
will continue. 
.TP 18
This environment variable is only used
for programs compiled with the following options: 
Qopenmp (Windows)
or 
qopenmp (Linux and OS X), or 
Qparallel (Windows) or 
qparallel (Linux and OS X). 
.TP 18
The 
omp_get_thread_limit() routine returns
the value of the limit. 
.TP 18
\fB Default:\fR No enforced limit 
.TP 18
\fB Related environment variable:\fRKMP_ALL_THREADS (overrides 
OMP_THREAD_LIMIT). 
.TP 18
\fB Example syntax:\fROMP_THREAD_LIMIT=value
.NL
.TP 18
OMP_WAIT_POLICY
.NL
Decides whether threads spin (active) or
yield (passive) while they are waiting. 
.TP 18
OMP_WAIT_POLICY=ACTIVE
is an alias for 
KMP_LIBRARY=turnaround,
and 
OMP_WAIT_POLICY=PASSIVE
is an alias for 
KMP_LIBRARY=throughput. 
.TP 18
\fB Default: 
\fRPassive 
.TP 18
\fB Syntax:\fROMP_WAIT_POLICY=value
.NL
.TP 18
KMP_AFFINITY (Windows, Linux) 
.NL
Enables run\-time library to bind threads
to physical processing units. 
.TP 18
You must set this environment variable before the first
parallel region, or certain API calls including 
omp_get_max_threads(), 
omp_get_num_procs() and any affinity API
calls. For detailed information on this environment variable, see 
\fIThread Affinity Interface\fR. 
.TP 18
\fB Default:\fR
noverbose,warnings,respect,granularity=core,duplicates,none 
.TP 18
\fB Default (Intel(R) MIC
architecture):\fR
noverbose,warnings,respect,granularity=fine,duplicates,scatter,0,0 
.TP 18
= = = = = = = = =
=
.PP
.B NOTE:
Some environment variables are available for
both Intel(R) microprocessors and non\-Intel microprocessors, but may perform
additional optimizations for Intel(R) microprocessors than for non\-Intel
microprocessors.
= = = = = = = = =
=
.NL
.TP 18
KMP_ALL_THREADS
.NL
Limits the number of
simultaneously\-executing threads in an OpenMP* program. If this limit is
reached and another native operating system thread encounters OpenMP* API calls
or constructs, then the program may abort with an error message. If this limit
is reached at the time an OpenMP* parallel region begins, a one\-time warning
message may be generated indicating that the number of threads in the team was
reduced, but the program will continue execution. 
.TP 18
This environment variable is only used
for programs compiled with the 
qopenmp 
option. 
.TP 18
\fB Default:\fR No enforced limit. 
.NL
.TP 18
KMP_BLOCKTIME
.NL
Sets the time, in milliseconds, that a
thread should wait, after completing the execution of a parallel region, before
sleeping. 
.TP 18
Use the optional character suffixes: 
s (seconds), 
m (minutes), 
h (hours), or 
d (days) to specify the units. 
.TP 18
Specify 
infinite for an unlimited wait time. 
.TP 18
\fB Default:\fR 200 milliseconds 
.TP 18
\fB Related Environment Variable:\fRKMP_LIBRARY
environment variable. 
.NL
.TP 18
KMP_CPUINFO_FILE
.NL
Specifies an alternate file name for a
file containing the machine topology description. The file must be in the same
format as 
/proc/cpuinfo. 
.TP 18
\fB Default:\fR None 
.TP 18
= = = = = = = = =
=
.PP
.B NOTE:
Some environment variables are available for
both Intel(R) microprocessors and non\-Intel microprocessors, but may perform
additional optimizations for Intel(R) microprocessors than for non\-Intel
microprocessors.
= = = = = = = = =
=
.NL
.TP 18
KMP_DETERMINISTIC_REDUCTION
.NL
Enables (true)
or disables (false) the use of a
specific ordering of the reduction operations for implementing the reduction
clause for an OpenMP* parallel region. This has the effect that, for a given
number of threads, in a given parallel region, for a given data set and
reduction operation, a floating point reduction done for an OpenMP* reduction
clause has a consistent floating point result from run to run, since round\-off
errors are identical. 
.TP 18
\fB Default:\fRfalse
.NL
.TP 18
KMP_DYNAMIC_MODE
.NL
Selects the method used to determine the number of threads
to use for a parallel region when 
OMP_DYNAMIC=true.
Possible values: (asat | 
load_balance | 
thread_limit), where, 
.IP \(bu 2
asat: estimates
number of threads based on parallel start time; 
.PP
.B NOTE:
Support for 
asat 
(automatic self\-allocating threads) is now
deprecated and will be removed in a future release. 
.IP \(bu 2
load_balance:
tries to avoid using more threads than available execution units on the
machine; 
.IP \(bu 2
thread_limit: tries to avoid using
more threads than total execution units on the machine. 
.TP 18
\fB Default (IA\-32 architecture):\fRload_balance (on all supported OSes) 
.TP 18
\fB Default (Intel(R) 64 architecture):\fRload_balance (on all supported OSes) 
.TP 18
\fB Default (Intel(R) MIC
architecture):\fR thread_limit 
(on supported OSes) 
.NL
.TP 18
KMP_HOT_TEAMS_MAX_LEVEL
.NL
Sets the maximum nested level to which teams of threads
will be hot. 
.PP
.B NOTE:
A 
\fIhot\fR team is a team of threads optimized for faster
reuse by subsequent parallel regions. In a hot team, threads are kept ready for
execution of the next parallel region, in contrast to the cold team, which is
freed after each parallel region, with its threads going into a common pool of
threads. 
.TP 18
For values of 2 and above, nested parallelism should be
enabled. 
.TP 18
\fB Default:\fR 1 
.NL
.TP 18
KMP_HOT_TEAMS_MODE
.NL
Specifies the run\-time behavior when the number of threads
in a hot team is reduced. 
.TP 18
Possible values: 
.RS
.IP \(bu 2
0: Extra threads are freed and put into a common pool of
threads. 
.IP \(bu 2
1: Extra threads are kept in the team in reserve, for
faster reuse in subsequent parallel regions. 
.RE
.TP 18
\fB Default:\fR 0 
.NL
.TP 18
KMP_HW_SUBSET
.NL
Specifies the number of sockets, cores per socket, and the
number of threads per core, to use with an OpenMP* application, as an
alternative to writing explicit affinity settings or a process affinity mask.
You can also specify an offset value to set which sockets and cores to use. 
.TP 18
\fB Syntax:\fR\fIsockets\fRS[@\fIoffset\fR],\fIcores\fRC[@\fIoffset\fR],\fIthreads\fRT
.TP 18
S, C and T are not case\-sensitive. 
.PP
.TP 18
sockets
.NL
The number of sockets to use. 
.TP 18
cores
.NL
The number of cores to use per socket. 
.TP 18
threads
.NL
The number of threads to use per core. 
.TP 18
offset
.NL
(Optional) The number of sockets or cores to skip. 
.PP
.B NOTE:
If you don\[aq]t specify one or more types of resource,
sockets, cores or threads, all available resources of that type are used. 
.PP
.B NOTE:
This variable does not work if the OpenMP* affinity is
set to 
none, the default on Intel(R) Xeon(R)
processors, or 
disabled. Set the affinity type by setting
the environment variable 
OMP_PROC_BIND to a value other than 
false, or by setting the environment
variable 
KMP_AFFINITY to a value other than 
none or 
disabled. 
.PP
On Intel(R) Xeon(R) Phi(TM) coprocessors, the default affinity
type is 
scatter, so 
KMP_HW_SUBSET works by default on this
platform. 
.TP 18
\fB Default:\fR If omitted, the default value is the
available number of sockets, cores, or threads. 
.TP 18
\fB  Examples:\fR
.RS
.IP \(bu 2
2s,4c,2t: Use the first 2 sockets (s0
and s1), the first 4 cores on each socket (c0 \- c3), and 2 threads per core. 
.IP \(bu 2
2s@2,4c@8,2t: Skip the first 2 sockets
(s0 and s1) and use 2 sockets (s2\-s3), skip the first 8 cores (c0\-c7) and use 4
cores on each socket (c8\-c11), and use 2 threads per core. 
.IP \(bu 2
5C@1,3T: Use all available sockets,
skip the first core and use 5 cores, and use 3 threads per core. 
.IP \(bu 2
2T: Use all cores on all sockets, 2
threads per core. 
.IP \(bu 2
4C@12: Use 4 cores with offset 12, all
available threads per core. 
.RE
.NL
.TP 18
KMP_INHERIT_FP_CONTROL
.NL
Enables (true) or disables (false) the copying of the floating\-point
control settings of the master thread to the floating\-point control settings of
the OpenMP* worker threads at the start of each parallel region. 
.TP 18
\fB Default:\fRtrue
.NL
.TP 18
KMP_LIBRARY
.NL
Selects the OpenMP* run\-time library
execution mode. The values for this variable are 
serial, 
turnaround, or 
throughput. 
.TP 18
\fB Default:\fRthroughput
.NL
.TP 18
KMP_MONITOR_STACKSIZE
.NL
Sets the number of bytes to allocate for
the monitor thread, which is used for book\-keeping during program execution. 
.TP 18
Use the optional suffixes to specify byte
units: 
B (bytes), 
K (Kilobytes), 
M (Megabytes), 
G (Gigabytes), or 
T (Terabytes) to specify the units. If you
specify a value without a suffix, the byte unit is assumed to be 
K (Kilobytes). 
.TP 18
\fB Default:\fR max (32k, system minimum
thread stack size) 
.NL
.TP 18
KMP_PLACE_THREADS
.NL
Deprecated; use
KMP_HW_SUBSET instead. 
.NL
.TP 18
KMP_SETTINGS
.NL
Enables (true) or disables (false) the printing of OpenMP* run\-time
library environment variables during program execution. Two lists of variables
are printed: user\-defined environment variables settings and effective values
of variables used by OpenMP* run\-time library. 
.TP 18
\fB Default:\fRfalse
.NL
.TP 18
KMP_STACKSIZE
.NL
Sets the number of bytes to allocate for
each OpenMP* thread to use as its private stack. 
.TP 18
Recommended size is 16m. 
.TP 18
Use the optional suffixes to specify byte
units: 
B (bytes), 
K (Kilobytes), 
M (Megabytes), 
G (Gigabytes), or 
T (Terabytes) to specify the units. If you
specify a value without a suffix, the byte unit is assumed to be 
K (Kilobytes). 
.TP 18
This variable does not affect the native
operating system threads created by the user program nor the thread executing
the sequential part of an OpenMP* program or parallel programs created using
the option 
Qparallel (Windows) or 
qparallel (Linux and OS X). 
.TP 18
KMP_STACKSIZE overrides 
GOMP_STACKSIZE, which overrides 
OMP_STACKSIZE.
.TP 18
\fB Default (IA\-32 architecture):\fR 2m 
.TP 18
\fB Default (Intel(R) 64 architecture):\fR
4m 
.TP 18
\fB Default (Intel(R) MIC
architecture):\fR4M (on supported OSes) 
.NL
.TP 18
KMP_VERSION
.NL
Enables (true) or disables (false) the printing of OpenMP* run\-time
library version information during program execution. 
.TP 18
\fB Default:\fRfalse
.NL
.TP 18
KMP_WARNINGS
.NL
Enables (true) or
disables (false) displaying warnings from the OpenMP*
run\-time library during program execution. 
.TP 18
\fB Default:\fRtrue
.NL
.TP 18
\fB Intel(R) Graphics Technology Environment Variables
(GFX_) 
\fR
.NL
.TP 18
GFX_CPU_BACKUP
.NL
Controls whether heterogeneous code is
executed on the host when the target is not available. 
.TP 18
If the 
if clause of the offload pragma evaluates to
false then the code is executed on the host
regardless of the target\[aq]s availability. 
.TP 18
If the 
if clause of the offload pragma is not
provided or evaluates to 
true and the target and the Intel(R) Graphics
Technology driver supporting offload are available and correctly initialized,
then the code is executed on the target. Otherwise, back\-up execution on the
host depends on the value of 
GFX_CPU_BACKUP. 
.TP 18
To prevent execution from occurring on the host, which
causes the application to fail when the target is not available, set 
GFX_CPU_BACKUP to
0. 
.TP 18
To execute on the host when the target is not available, set
GFX_CPU_BACKUP to
1. By default, this variable is set to 1, so
the code is executed on the host. 
.TP 18
\fB Default:\fR 1 
.NL
.TP 18
GFX_MAX_THREAD_COUNT
.NL
Controls the maximum number of target threads to
parallelize loop nests offloaded to the graphics cores. Use this variable to
override the default maximum value. 
.TP 18
Two values have special meaning: 
.RS
.IP \(bu 2
\- 1 (the default): The runtime creates one thread for
each parallel loop nest iteration. Loops can be vectorized, and one iteration
executed by a thread may include several original loop iterations. 
.IP \(bu 2
0: The threadcount is 
\fIN\fR*\fIhardware_thread_count\fR,
where 
\fIN\fR is: 
.RS
.IP \(bu 2
\fB 4\fR for one\-dimensional loop nests. 
.IP \(bu 2
\fB 8\fR for loop nests of two or more dimensions. 
.RE
Try using this value when tuning your program for
performance. 
.RE
.TP 18
Scheduling many threads (e.g. 512) helps
hide the latency of some operations, but a large number of threads can increase
the cost of offload or negatively affect performance. By default, the runtime
automatically determines the maximum thread count. 
.TP 18
The real thread count for a particular offload execution
can be lower than the maximum, and is determined by the offload runtime,
depending on the real iteration space for that execution. 
.TP 18
\fB Default:\fR \-1 
.TP 18
\fB  Example:\fRGFX_MAX_THREAD_COUNT=32
.NL
.TP 18
GFX_OFFLOAD_TIMEOUT 
.NL
By default, the system will not allow for
an offload task to execute longer than system recovery timeout period (usually
two seconds). The task appears to hang and abnormally terminate after another
timeout, defined by this variable. To enable longer execution of your offload
tasks, disable recovery on timeout in the system registry (refer to Microsoft*
documentation for instructions) and set 
GFX_OFFLOAD_TIMEOUT to a higher value, if 60
seconds are insufficient. 
.TP 18
\fB Default: 
\fR60 seconds. 
.NL
.TP 18
GFX_LOG_OFFLOAD
.NL
Enables or disables logging of the offload process by
setting this to the desirable logging level, from 
1 to 
3, where 3 has the greatest amount of
detail. 
.TP 18
To see the number of available hardware threads, set this
environment variable to 
1. 
.TP 18
To monitor the real thread count, set this environment
variable to 
2. 
.TP 18
To monitor the real thread count as well as distribution of
the parallel loop nest’s iteration space, set this environment variable to 
3. 
.TP 18
To disable logging, set this environment variable to either
an empty string or 
0. 
.PP
.B NOTE:
Enabling logging significantly increases the overhead of
offload, so it is recommended only for debugging. 
.NL
.TP 18
GFX_SHOW_TIME
.NL
Enables or disables printing timing information at the end
of execution. 
.TP 18
To disable timer printing, set 
GFX_SHOW_TIME to either an empty string or
0. 
.TP 18
. 
.NL
.TP 18
GFX_THREAD_GROUP_WIDTH
.NL
Sets the width of a thread group. 
.NL
.TP 18
GFX_THREAD_GROUP_HEIGHT
.NL
Sets the height of a thread group. 
.PP
.B NOTE:
This environment variable overrides the environment
variable 
GFX_MAX_THREAD_COUNT. 
.NL
.TP 18
GFX_THREAD_SPACE_WIDTH
.NL
Sets the width of the thread space, in threads. 
.TP 18
When this variable is set to 
0, or not set, an appropriate value is
calculated automatically. 
.TP 18
This variable overrides the function 
_GFX_set_thread_space_config. 
.NL
.TP 18
GFX_THREAD_SPACE_HEIGHT
.NL
Sets the height of the thread space, in threads. 
.TP 18
When this variable is set to 
0, or not set, an appropriate value is
calculated automatically. 
.TP 18
This variable overrides the function 
_GFX_set_thread_space_config. 
.NL
.TP 18
\fB Intel(R) Many Integrated Core
(Intel(R) MIC) Environment Variables 
\fR
.NL
.TP 18
MIC_ENV_PREFIX
.NL
Controls environment variables passed to the target. 
.TP 18
By default, all environment variables set on the host are
passed to the target. Setting 
MIC_ENV_PREFIX passes
only environment variables that have a prefix of the value of this variable.
For example, setting 
MIC_ENV_PREFIX=ABC passes only environment
variables that have a prefix of 
ABC. 
.PP
.B NOTE:
Because the 
MIC_LD_LIBRARY_PATH variable is not
stripped and passed to the target, you cannot use 
MIC_ENV_PREFIX=\fB MIC\fR to change the 
LD_LIBRARY_PATH on the target. 
.PP
To change 
LD_LIBRARY_PATH on the target: 
.IP 1) 4n 
.IP
Set 
MIC_ENV_PREFIX to any prefix other
than 
\fB MIC\fR. 
.IP 2) 4n 
.IP
Create an additional pre\-fixed environment variable
on the host set to the desired value for 
LD_LIBRARY_PATH for the target. 
.PP
For example, setting these two environment variables on
the host sets 
LD_LIBRARY_PATH on the target to 
/tmp/mylibs. 
.PP
MIC_ENV_PREFIX=ABC
ABC_LD_LIBRARY_PATH=/tmp/mylibs
.PP
.NL
.TP 18
MIC_LD_LIBRARY_PATH
.NL
Specifies the location on the host for target\-specific
shared objects that may be loaded to the target for 
Intel(R) Xeon Phi(TM) coprocessor x100 product
family (formerly code name Knights Corner).
The value is not passed to the target. See 
MIC_ENV_PREFIX for special handling of the
value on the target. 
.TP 18
Use 
LD_LIBRARY_PATH for the
location of host\-specific shared objects on a host system, including those for
the 
Intel(R) Xeon Phi(TM) coprocessor (code name
Knights Landing).
.NL
.TP 18
MIC_PROXY_IO
.NL
Enables (1) or
disables (0) the proxy of stderr and stdout, and specifies
whether the process wants I/O proxy support between the host and target. 
.TP 18
\fB Default:\fR1
.TP 18
\fB  Example:\fRMIC_PROXY_IO=0
.NL
.TP 18
MIC_SEP_MONITOR
.NL
Enables (1) or
disables (0) SEP at offload regions. 
.TP 18
\fB Default:\fR0
.TP 18
\fB  Example:\fRMIC_SEP_MONITOR=1
.NL
.TP 18
MIC_STACKSIZE
.NL
Specifies the stack size of the main
thread for the offload. This value is typically much larger than the stack size
for individual threads. It corresponds to what you would set with 
.B ulimit
\-s (BASH shell) or 
.B limit stacksize
(C shell) if you were
running natively on either the target or the host. 
.TP 18
Set this variable to 
\fIinteger\fRB|K|M|G|T, where: 
.RS
.IP \(bu 2
\fIB\fR = bytes 
.IP \(bu 2
\fIK\fR = kilobytes 
.IP \(bu 2
\fIM\fR = megabytes 
.IP \(bu 2
\fIG\fR = gigabytes 
.IP \(bu 2
\fIT\fR = terabytes 
.RE
.TP 18
\fB Default: 
\fR12M
.TP 18
\fB  Example:\fRMIC_STACKSIZE=16M
.NL
.TP 18
MIC_USE_2MB_BUFFERS
.NL
Use 2M pages for (size > 
MIC_USE_2MB_BUFFERS). 
Pointer\-based variables 
whose runtime length exceeds the value of this
environment variable are allocated in large pages. 
.TP 18
Set this variable to 
\fIinteger\fRB|K|M|G|T, where: 
.RS
.IP \(bu 2
\fIB\fR = Bytes 
.IP \(bu 2
\fIK\fR = Kilobytes 
.IP \(bu 2
\fIM\fR = Megabytes 
.IP \(bu 2
\fIG\fR = Gigabytes 
.IP \(bu 2
\fIT\fR = Terabytes 
.RE
.TP 18
\fB  Example:\fRMIC_USE_2MB_BUFFERS=64K
.NL
.TP 18
OFFLOAD_DEVICES
.NL
Restricts the offload process to use only
the coprocessors specified as the value of the variable. 
.TP 18
Set this variable to a comma\-separated list of target device
numbers in the range 0 to (\fInumber_of_devices_in_the_system\fR
\-1), where 0 is the first coprocessor in the system, and
(\fInumber_of_devices_in_the_system\fR \-1) is the last coprocessor
in the system. 
.TP 18
Coprocessors available for offloading are numbered
logically. The function 
_Offload_number_of_devices() 
returns the
number of available coprocessors. Coprocessor indices that you use in the 
target specifier of the offload 
pragmas 
are mapped
to coprocessors specified in 
OFFLOAD_DEVICES. 
.TP 18
\fB Default:\fR The offload process uses
all devices. 
.TP 18
\fB  Example:\fROFFLOAD_DEVICES = 1,2
.TP 18
On a system with more than two coprocessors installed, this
setting enables the application to use only coprocessors 1 and 2. Offloads to
coprocessors 0 or 1 are performed on the second and third physical
coprocessors. Offloads to target numbers higher than 1 wrap around, and all
offloads remain within coprocessors 0 and 1. The function 
_Offload_number_of_devices() 
executed on
a coprocessor, returns 0 or 1 when the offload is running on coprocessor 1 or 2
as specified in 
OFFLOAD_DEVICES. 
.TP 18
Setting this variable to an empty value on Linux
(export OFFLOAD_DEVICES= 
) or the value 
none on Windows (set
OFFLOAD_DEVICES=none) impacts the execution of offloaded code within
your program as follows: 
.RS
.IP \(bu 2
When you use optional offloading, the code executes on
the host CPU. 
.IP \(bu 2
When you use mandatory offloading, the program
terminates with an offload error, reporting that a device is not available,
when it reaches a point in the execution where the coprocessor requires
initialization for offloading. 
.RE
.TP 18
You can specify optional and mandatory offloading using the 
optional and 
mandatory clauses in either of the
following: 
.RS
.IP \(bu 2
The compiler option 
qoffload (Linux) or 
Qoffload (Windows) 
.IP \(bu 2
The 
offload pragma
.RE
.NL
.TP 18
OFFLOAD_NODES
.NL
Defines a subset of a cluster (group of servers or nodes)
that is available for offloading from the host system. When offloading within a
cluster, this environment variable must be set to specify the available
offload\-able nodes. 
.TP 18
The value of the environment variable is a comma\-separated
list of machine specifiers. A machine specifier is either a machine name or an
IP address. The machine specifier may be optionally followed by a specification
of the node type and fabric type in square brackets. The default node type is
currently x200 and the default fabric type is OFI. More node and fabric types
may be supported in the future. 
.TP 18
The offloadable machines in OFFLOAD_NODES are assigned
device numbers 0, 1, 2 and so on, in the order specified. These device numbers
are available for offloading through 
#pragma offload target(mic:<number>) 
. The 
OFFLOAD_DEVICES environment variable may
be used to restrict offloading to a subset of the available cluster machines. 
.TP 18
\fB Default:\fR There is no default. The
environment variable must be set if doing offload within a cluster. 
.TP 18
\fB  Example:\fR export
OFFLOAD_NODES="machine1,machine2,10.2.100.50"
.TP 18
\fB  Example:\fR export OFFLOAD_NODES="machine3[x200,OFI]"
.TP 18
\fB  Example:\fR In the following,
machine2 and 10.2.100.50 will be used as processor 0 and 1 in target specified
in the offload pragma. 
.PP
export OFFLOAD_NODES="machine1,machine2,10.2.100.50"
export OFFLOAD_DEVICES=1,2 
.PP
.NL
.TP 18
OFFLOAD_INIT
.NL
Specifies a hint to the offload runtime
indicating when to initialize targets. 
.TP 18
Possible values: 
.IP \(bu 2
on_start: All available coprocessors
are initialized before entering 
main. 
.IP \(bu 2
on_offload: The target is initialized
immediately before the first offload to it. Initialization is done only on the
target that handles the offload. 
.IP \(bu 2
on_offload_all: All available targets
are initialized immediately before the first offload in an application. 
.TP 18
\fB Default:\fRon_offload_all
.TP 18
\fB  Example:\fROFFLOAD_INIT=on_start
.NL
.TP 18
OFFLOAD_REPORT
.NL
Controls printing offload execution
time, in seconds, and the amount of data transferred, in bytes. This
environment variable is equivalent to using the 
__Offload_report API. 
.TP 18
Possible values: 
.IP \(bu 2
1: Prints the offload computation time,
in seconds. 
.IP \(bu 2
2: In addition to the information
produced at value 1, adds the amount of data transferred between the CPU and
the target, in bytes. 
.IP \(bu 2
3: In addition to the information
produced at value 2, gives additional details on offload activity, including
device initialization, and individual variable transfers. 
.TP 18
\fB Default:\fR None 
.TP 18
\fB  Example:\fROFFLOAD_REPORT=1
.TP 18
See also 
_Offload_report. 
.NL
.TP 18
\fB Profile Guided Optimization
(PGO_) Environment Variables 
\fR
.NL
.TP 18
INTEL_PROF_DUMP_CUMULATIVE
.NL
When using interval profile dumping
(initiated by 
INTEL_PROF_DUMP_INTERVAL or the function 
_PGOPTI_Set_Interval_Prof_Dump) during the
execution of an instrumented user application, allows creation of a single 
.dyn file to contain profiling
information instead of multiple 
.dyn files. If not set, executing an
instrumented user application creates a new 
.dyn file for each interval. 
.TP 18
Setting this environment variable is
useful for applications that do not terminate or those that terminate
abnormally (bypass the normal exit code). 
.NL
.TP 18
INTEL_PROF_DUMP_INTERVAL
.NL
Initiates interval profile dumping in an
instrumented user application. This environment variable may be used to
initiate Interval Profile Dumping in an instrumented application. 
.NL
.TP 18
INTEL_PROF_DYN_PREFIX
.NL
Specifies the prefix to be used for the 
.dyn filename to distinguish it from the
other 
.dyn 
files dumped by other PGO runs. Executing the
instrumented application generates a .dyn filename as follows: 
<prefix>_<timestamp>_<pid>.dyn,
where 
<prefix> is the identifier that you
have specified. 
.PP
.B NOTE:
The value specified in this environment variable must not
contain < > : " / \ | ? * characters. The default naming scheme is used
if an invalid prefix is specified. 
.NL
.TP 18
PROF_DIR
.NL
Specifies the directory where profiling files (files with
extensions 
.dyn, 
.dpi, 
.spi and so on) are stored. The default
is to store the 
.dyn files in the source directory of
the file containing the first executed instrumented routine in the binary
compiled with 
[Q]prof\-gen option. 
.TP 18
This variable applies to all three phases of the profiling
process: 
.RS
.IP \(bu 2
Instrumentation compilation and linking 
.IP \(bu 2
Instrumented execution 
.IP \(bu 2
Feedback compilation 
.RE
.NL
.TP 18
PROF_DPI
.NL
Name for the 
.dpi file. 
.TP 18
\fB Default: 
\fRpgopti.dpi
.NL
.TP 18
PROF_DUMP_INTERVAL
.NL
Deprecated; use 
INTEL_PROF_DUMP_INTERVAL instead. 
.NL
.TP 18
PROF_NO_CLOBBER
.NL
Alters the feedback compilation phase
slightly. By default, during the feedback compilation phase, the compiler
merges data from all dynamic information files and creates a new 
pgopti.dpi file if the 
.dyn files are newer than an existing 
pgopti.dpi file. 
.TP 18
When this variable is set, the compiler
does not overwrite the existing 
pgopti.dpi file. Instead, the
compiler issues a warning. You must remove the 
pgopti.dpi file if you want to use
additional dynamic information files. 
.NL
.PP
.SH  Compiler Options for Intel(R) C++ Compiler
Standard Edition for Embedded Systems with Bi\-Endian Technology
.PP
The Intel(R) C++ Compiler Standard Edition for
Embedded Systems with Bi\-Endian Technology is based on the standard Intel(R)
C++ Compiler 16.0 for Linux* systems. In general, the functionality offered by
this compiler matches that of the standard Intel(R) C++ Compiler for Linux
systems. However some features of the standard compiler are not supported. For
a list of the unsupported features, see the Intel(R) C++ Compiler Standard
Edition for Embedded Systems with Bi\-Endian Technology user documentation. 
.SS New Options
.PP
The following new options are available for embedded systems with
bi\-endian technology. 
.NL
.TP 18
\fBOption 
\fR
.NL
.NL
\fBDescription 
\fR
.NL
.NL
.TP 18
\-mx32
.NL
Tells the compiler to set 
int, 
long and 
pointer type data to 32 bits while
generating code for x86\-64/32\-bit architecture. Default is OFF. 
.NL
.TP 18
\-qenable\-biendian\-extended\-cxx
.NL
Enables extended C++ support mode for template
initialization in the bi\-endian compiler. Default is OFF. 
.NL
.SS Deprecated Options
.PP
The following options are deprecated for embedded systems with
bi\-endian technology. 
.NL
.TP 18
\fBOption 
\fR
.NL
.NL
\fBDescription 
\fR
.NL
.NL
.TP 18
\-[no]\-normal\-pe\-files
.NL
Enables/disables the "normal" prolog/epilog processing that
looks into the include file directories for 
__intel_prolog.h and 
__intel_epilog.h files. There is no
replacement option. 
.NL
.TP 18
\-pe\-dir\-rule
.NL
Allows prolog and epilog files to be selected based on a
directory search. Consider using the 
\-pe\-(i|u)dir\-rule options instead. 
.NL
.TP 18
\-Qoption,cpp, \-\-separate_biendian_types
.NL
Enables extended bi\-endian C++ support mode. Use the 
\-qenable\-biendian\-extended\-cxx option
instead. 
.NL
.SH Alphabetical List of Compiler Options for
Intel(R) C++ Compiler Standard Edition for Embedded Systems with Bi\-Endian
Technology
.TP
.B
\-[no\-]add\-response\-file\-dependencies
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Includes
response files in dependency generation output. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.PP
OFF
.NL
.TP
\fBDescription:\fR 
.PP
This option specifies that response files and
configuration files containing command line options are included in dependency
output when dependencies are requested. By default, these files are not
included in dependency output. 
.NL
.PP
This option is effective only when: 
.IP \(bu 2
dependency information is being generated 
.IP \(bu 2
little\-endian or 
big\-endian options are specified. 
.NL
.RE
.TP
.B
\-big\-endian
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Enables bi\-endian compilation mode and specifies that the compilation should
assume big\-endian byte order as the default. 
.NL
.TP
\fBDescription:\fR 
.PP
This option enables bi\-endian compilation mode and
specifies that the compilation should assume big\-endian byte order as the
default. Bi\-endian compilation mode 
also means that the 
byte_order pragma and the endian type attributes are
enabled. 
However, if you have used the 
byte_order pragma and/or type byte order attributes in
your code, it overrides the byte order specified in the command line. 
.NL
.PP
For example, 
consider a C program file, test.c,
where you have not used 
byte_order pragma or the type byte order attributes in
your code. To compile, enter the following at the command prompt: 
.PP
icc \-c \-big\-endian test.c
.PP
.NL
.PP
The above command line entry causes 
test.c to be compiled in bi\-endian mode with big\-endian byte
order. 
.NL
.RE
.TP
.B
\-debug[keyword]
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Enables or disables generation of debugging information. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is a value denoting enhanced debugging. Possible value:
.RS
.TP 15
biendian
Produces enhanced debug information for big endian data. 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No additional debugging information is generated
for big\-endian data.
.TP
\fBDescription:\fR 
.PP
This option enables or disables generation of debugging
information. 
You can use the 
\-debug option along with the 
\fIbi\-endian\fR argument to generate debug information for
bi\-endian data. 
.NL
.PP
You must also specify the 
\-g option when you use this option. 
.NL
.RE
.TP
.B
\-diag\-enable biendian\-verbose
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Enables a biendian\-specific message group. 
.NL
.TP
\fBDescription:\fR 
.PP
This option enables the whole group of bi\-endian\-specific
diagnostics \- 1697, 2324, 2325, 2334, 2710, 2951 \- that are disabled by
default. See 
\fIWarning Reference\fR for more details. 
.NL
.RE
.TP
.B
\-dynamic\-loader\-data\-init
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Specifies the dynamic loader initialization mode for big\-endian data 
when directly using 
bepostld, the bi\-endian post lnk tool. 
.NL
.TP
\fBDescription:\fR 
.PP
This option is supported by the
Bi\-endian Post Link Tool, 
bepostld, when it is invoked directly on the command
line. This option specifies the dynamic loader initialization mode for
big\-endian data. 
.NL
.PP
This option is disabled and ignored at compile time by
the compiler. No warning or error is generated. 
.NL
.RE
.TP
.B
\-dynamic\-runtime\-data\-init
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Specifies the dynamic runtime initialization mode for big\-endian data 
when directly using 
bepostld, the bi\-endian post link tool. 
.NL
.TP
\fBDescription:\fR 
.PP
This option is supported by the
Bi\-endian Post Link Tool, 
bepostld, when it is invoked directly on the command
line. This option specifies the dynamic runtime initialization mode for
big\-endian data. 
.NL
.PP
This option is disabled and ignored at compile time by
the compiler. No warning or error is generated. 
.NL
.RE
.TP
.B
\-extern\-prefix=string
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Specifies a string to be prepended to external C symbols. 
.NL
.TP
\fBArguments:\fR 
.PP
.TP 18
string
.NL
Is a character string delimited by double quotes. 
.TP
\fBDefault:\fR 
.TP 18
""
.NL
An empty string is the default. 
.TP
\fBDescription:\fR 
.PP
This option specifies a string to be prepended to
external C symbols (similar to 
#pragma extern_prefix). The default is the empty string
(""). This option applies to C compilations only. 
.NL
.RE
.TP
.B
\-fdefer\-pop
.TP
.B
\-fno\-defer\-pop
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Prohibits or allows deferred clearance of the stack arguments. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fdefer\-pop
.NL
Deferred clearance of stack arguments is allowed,
by default.
.PP
.NL
.TP
\fBDescription:\fR 
.PP
This option prohibits or allows deferred clearance of the
stack arguments. 
.NL
.PP
Specify 
fno\-defer\-pop to prohibit deferred clearance of the stack
arguments. 
.NL
.RE
.TP
.B
\-little\-endian
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Enables bi\-endian compilation mode and specifies that the compilation should
assume little\-endian byte order as the default. 
.NL
.TP
\fBDescription:\fR 
.PP
This option enables bi\-endian compilation mode and
specifies that the compilation should assume little\-endian byte order as the
default. Bi\-endian compilation mode also means that the 
byte_order pragma and the endian type attributes are
enabled. 
However, if you have used the 
byte_order pragma and/or type byte order attributes in
your code, it overrides the byte order specified in the command line. 
.NL
.PP
For example, 
consider a C program file, test.c,
where you have not used 
byte_order pragma or the type byte order attributes in
your code. To compile, enter the following at the command prompt: 
.PP
icc \-c \-little\-endian test.c
.PP
.NL
.PP
The above line causes 
test.c to be compiled in bi\-endian mode with little\-endian
byte order. 
.NL
.RE
.TP
.B
\-[no\-]little\-endian\-defaultlibs
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Instructs the compiler to treat default libraries as little\-endian during type
checking. 
.NL
.TP
\fBDescription:\fR 
.PP
When an application is compiled with the type checking
mechanism enabled (using 
\-symcheck option), the compiler checks global variables and
routines for consistency. 
.NL
.PP
In order to perform type checking 
for global variables imported from a library, the
library should be compiled with the 
\-symcheck option as well. 
However, this is not possible for all libraries. 
For example, the 
\-symcheck option is unlikely to
recompile system libraries. 
.NL
.PP
In such cases, the 
\-little\-endian\-defaultlibs option instructs the compiler to
treat all libraries implicitly linked to the application as little\-endian
during type checking. 
.PP
.B NOTE:
Libraries explicitly provided by you will not be
recognized as little\-endian. If incompatibilities are found, they are reported
in the usual way by the Bi\-Endian Post Link Tool. 
.NL
.RE
.TP
.B
\-little\-endian\-libs=<libname1>[,<libname2>...]
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Specifies a list of little\-endian libraries for type checking.
.NL
.TP
\fBArguments:\fR 
.PP
.TP 18
libname
.NL
Is the name of a little\-endian library to be used for type\-checking.
It can be a regular expression or start with 
\-l prefix. For more details, see the Description
section below.
.TP
\fBDescription:\fR 
.PP
This option has the same effect as 
little\-endian\-defaultlibs but the list of libraries is
explicitly provided by the option. 
.NL
.PP
The library name can be either a regular expression or
start with 
\-l prefix. In the first case when the library name is given
by a regular expression, it should match the full library name including the
directory path where the library is located. The syntax used in the regular
expression should follow the POSIX standard. In the second case, the name
should be given in a short form without the "lib" prefix and the ".so\.a"
suffix. For example, 
\-little\-endian\-libs=\-lmy tells compiler to interpret 
libmy.a/libmy.so as little\-endian during type checking.
Libraries specified by this option are searched using the same rules as other
regular libraries.
.NL
.RE
.TP
.B
\-multiline\-strings
.TP
.B
\-no\-multiline\-strings
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Enables or disables 
new line 
characters in multi\-line string literals. 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-multiline\-strings
.NL
You cannot compile code with new\-line characters
within string literals. 
.TP
\fBDescription:\fR 
.PP
The \-multiline\-strings option allows you 
to compile code without new\-line characters within
string literals. For example, consider the file 
foo.c containing the following code: 
.PP
char *bar = "This is a test of a
multiline string to a var.";
.PP
If you compile this file with the \-multiline\-strings option, the
file is compiled with no complaints. If you do not use the option you will get
errors and the compilation is aborted: 
.PP
icc foo.c \-c 
foo.c(1): error: missing closing quote
char *bar = "This is a test of a
^
foo.c(2): error: expected a ";"
multiline string to a var.";
^
foo.c(2): error: missing closing quote
multiline string to a var.";
^
compilation aborted for foo.c (code 2)
.PP
.PP
.B NOTE:
When you use the \-multiline\-strings option and
some of your strings contain new\-line characters, you will get warning number
1345. You can disable this warning with 
\-wd1345. You can also use this warning to locate
new\-line characters and remove them, if required. 
.NL
.RE
.TP
.B
\-mx32
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Tells the compiler to set int, long and pointer type data to 32 bits while
generating code for x86\-64 architecture. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R)
MIC Architecture 
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
x32 psABI code is not generated 
.TP
\fBDescription:\fR 
.PP
This option enables x32 psABI code generation. It sets integer, long and
pointer type data to 32 bits, turning on x32 [ILP32] programming mode on x86\-64
architectures. This option sets the 
_ILP32 and 
__ILP32__ predefined macros. 
.NL
.PP
This option is compatible with GCC\[aq]s 
\-mx32 option. 
.NL
.RE
.TP
.B
\-normal\-pe\-files
.TP
.B
\-[no\-]normal\-pe\-files
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Enables or disables the "normal" prolog/epilog processing. This option is
deprecated. 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-normal\-pe\-files
.NL
Normal processing of prolog/epilog files is
disabled.
.PP
This option enables or disables the "normal"
prolog/epilog processing, which looks into the 
include file directories for 
__intel_prolog.h and 
__intel_epilog.h files. 
.NL
.PP
By default, the "normal" prolog/epilog processing is
disabled and the location of the prolog/epilog files is determined solely by
the 
\-pe\-dir\-rule, 
\-pe\-udir\-rule, and 
\-pe\-idir\-rule options. 
.NL
.RE
.TP
.B
\-param\-byte\-order=<val>
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Specifies the parameter passing mode. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIval\fR
.NL
Specifies the order of passing parameters, it can take one of the
following values: 
.RS
.TP 15
legacy
Parameters are passed in the declared byte order (compatibility
mode). 
.TP 15
little\-endian
Parameters are passed in the little\-endian
form (recommended). 
.RE
.TP
\fBDefault:\fR 
.PP
The default value is 
legacy.
.NL
.TP
\fBDescription:\fR 
.PP
This option specifies the parameter passing mode. The
new, 
little\-endian mode is recommended for porting new
applications. The 
legacy mode, however, maintains compatibility with
big\-endian libraries compiled by older versions of the compiler. 
.NL
.PP
If you wish to adapt previously ported applications to
the little\-endian mode, you need to make sure that all library methods using
big\-endian parameters are recompiled in the little\-endian mode also. 
.NL
.RE
.TP
.B
\-pe\-dir\-rule="<regular
expression> <prolog file> <epilog file> "
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Allows prolog and epilog files to be selected based on a directory search. This
is a deprecated option; consider using the 
\-pe\-(i|u)dir\-rule instead. 
.NL
.TP
\fBArguments:\fR 
.TP 18
regular expression 
.NL
Is a regular expression using POSIX Extended Regular Expression
syntax. A specified prolog and epilog file will be applied to both header and
source files in the directory matching the regular expression. 
.TP 18
prolog
file
.NL
Is the name of a prolog file. 
.TP 18
epilog
file
.NL
Is the name of an epilog file. 
.TP
\fBDescription:\fR 
.PP
This option allows prolog and epilog files to be selected
based on a directory search. More than one 
\-pe\-dir\-rule option can be specified on the command line. If
multiple 
\-pe\-dir\-rule options are specified, they are processed in
the order received until the first match. 
.NL
.PP
This is a deprecated option; consider using the 
\-pe\-(i|u)dir\-rule instead. 
.NL
.RE
.TP
.B
\-pe\-file\-prefix=<prefix>
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Adds a prefix to prolog/epilog file names specified by 
\-pe\-(i|u)dir\-rule option. 
.NL
.TP
\fBArguments:\fR 
.TP 18
<prefix>
.NL
User\-specified prefix added to the names of prolog and epilog files
specified by the 
pe\-(i|u)dir\-rule option. 
.TP
\fBDescription:\fR 
.PP
When you use the 
\-pe\-file\-prefix=<prefix> option to specify a prefix,
the compiler prepends the prefix to the path names of the prolog/epilog files
specified by the 
\-pe\-(i|u)dir\-rule option. 
.NL
.PP
For example, instead of specifying the
following at the command line: 
.PP
$ icc \-pe\-idir\-rule="/usr/include /tmp/prolog.h /tmp/epilog.h"
.PP
you can specify 
\fI/tmp\fR in the 
\-pe\-file\-prefix option to do the same: 
.PP
$ icc \-pe\-file\-prefix=/tmp \-pe\-idir\-rule="/usr/include prolog.h epilog.h
.PP
.NL
.RE
.TP
.B
\-[no\-]pe\-file\-primary
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Enables/disables the prolog\-epilog mechanism for bracketing source files. 
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The 
\-no\-pe\-file\-primary option is the default. 
.TP
\fBDescription:\fR 
.PP
This option enables or disables the prolog\-epilog
mechanism for bracketing source files. 
.NL
.PP
By default the bi\-endian compiler brackets system header files
(like#include <sys_h.h>) using prolog and epilog files.
You can use the 
\-pe\-file\-primary option to bracket source files
(*.c / 
*.cpp). 
.NL
.PP
However, the source files are handled in a way similar to user headers
files; for example:#include “my_h.h”. Therefore, to bracket
the source files, you must use the 
\-pe\-file\-primary option along with the 
\-pe\-udir\-rule= option at the command line. 
.NL
.RE
.TP
.B
\-pe\-idir\-rule=<regular
expression> <prolog file> <epilog file>
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Specifies a set of system and user directories to be associated with a prolog
and epilog file. 
.NL
.TP
\fBArguments:\fR 
.TP 18
regular expression
.NL
Is a regular expression using POSIX Extended Regular Expression
syntax. The specified prolog and epilog files will be applied to any header
file in the directory matching the regular expression. 
.TP 18
prolog
file
.NL
Is the name of a prolog file. 
.TP 18
epilog
file
.NL
Is the name of an epilog file. 
.TP
\fBDescription:\fR 
.PP
This option allows prolog and epilog files to be
selected based on a directory search. 
.NL
.PP
More than one 
\-pe\-idir\-rule option can be specified on the command line.
If multiple 
\-pe\-idir\-rule options are specified, they are processed in
the order received until the first match. 
.NL
.PP
The 
\-pe\-idir\-rule option is processed for headers available
through system include paths. If none of the regular expressions defined by 
\-pe\-idir\-rule matches a directory where a header file is
located, the 
__intel_prolog.h and 
__intel_epilog.hlocated in the compiler\[aq]s include directory are
used. 
.NL
.PP
You can also set an environment
variable in a configuration file, assigned with a value specifying the
directory where the prolog/epilog files are located. For example, consider the
environment variable 
MY_PATH with values specifying the path to the prolog
and epilog files. You can use the environment variable, 
MY_PATH as follows:
.PP
\-pe\-idir\-rule="%$(MY_PATH)/ %$(MY_PATH)/prolog.h %$(MY_PATH)/epilog.h"
.PP
.NL
.PP
.B NOTE:
The 
makefiles based on the deprecated 
\-pe\-dir\-rule option or the 
\-[no\-]normal\-pe\-files option may remain unchanged. 
.RE
.TP
.B
\-pe\-udir\-rule=<regular
expression> <prolog file> <epilog file>
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Specifies a set of user directories to be associated with a prolog and epilog
file. 
.NL
.TP
\fBArguments:\fR 
.TP 18
regular expression
.NL
Is a regular expression using POSIX Extended Regular Expression
syntax. The specified prolog and epilog files will be applied to any header
file in the directory matching the regular expression. 
.TP 18
prolog
file
.NL
Is the name of a prolog file. 
.TP 18
epilog
file
.NL
Is the name of an epilog file. 
.TP
\fBDescription:\fR 
.PP
This option allows prolog and epilog files to be selected based on a
directory search. 
.NL
.PP
More than one 
\-pe\-udir\-rule option can be specified on the command line.
If multiple 
\-pe\-udir\-rule options are specified, they are processed in
the order received until the first match. 
.NL
.PP
The 
\-pe\-udir\-rule option is processed for headers available
through user include paths. If none of the regular expressions defined by 
\-pe\-udir\-rule matches a directory where a header file is
located, then the 
pe\-idir\-rule option is processed. 
.NL
.PP
You can also set an environment
variable in a configuration file, assigned with a value specifying the
directory where the prolog/epilog files are located. For example, consider the
environment variable 
MY_PATH with values specifying the path to the prolog
and epilog files. You can use the environment variable, 
MY_PATH as follows:
.PP
\-pe\-udir\-rule="%$(MY_PATH)/ %$(MY_PATH)/prolog.h %$(MY_PATH)/epilog.h"
.PP
.NL
.RE
.TP
.B
\-platform=default|<target
platform>|<embedded target platform>
.RS
.TP
This
option applies only for cross\-compiling compilers like bi\-endian C++ compiler
and Intel(R) System Studio C++ compiler.Specifies the target platform for
cross compilation. 
.NL
.TP
\fBArguments:\fR 
.TP 18
default
.NL
Disables previously defined 
\-platform, 
\-\-sysroot, and 
\-gnu\-prefix values and forces compiler to generate code
for the default target, which could be, for example, Linux*. 
.TP 18
target platform
.NL
Can be any one of the following, if supported: 
.RS
.TP 15
qnx640
Specifies the QNX* Neutrino* RTOS target. 
.TP 15
mvl50
Specifies the MontaVista* Linux* OS target. 
.TP 15
netbsd51
Specifies the NetBSD* OS target. 
.TP 15
wrl30
Specifies the Wind River* Linux* OS target. 
.RE
.TP 18
embedded target
platform
.NL
Can be any one of the following, if supported: 
.RS
.TP 15
android
Specifies the Android* target. 
.TP 15
celpr28
Specifies the CE Linux* OS target. 
.TP 15
wrl43
Specifies the Wind River* Linux* OS v4.3 target. 
.TP 15
wrl50
Specifies the Wind River* Linux* OS v5.0 target. 
.TP 15
yl12
Specifies the Yocto* Project OS v1.2 target. 
.TP 15
yl13
Specifies the Yocto* Project OS v1.3 target. 
.RE
.TP
\fBDescription:\fR 
.PP
This option specifies the target platform for cross compilation. If you do
not specify the 
\-platform option, the compiler will build a Linux* operating
system native application. If you do not specify an argument, you will receive
an error message. Using the 
\fIdefault\fR value for the option disables previously defined
values for \-platform option as well as for 
\-gnu\-prefix, and 
\-\-sysroot options, and forces the compiler to generate code
for the default target platform. 
.NL
.RE
.TP
.B
\-promote\-varargs\-to\-64bit
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Promotes big\-endian arguments passed to 
varargs functions to 64\-bit. This option is only valid for
64\-bit architecture. 
.NL
.TP
\fBDescription:\fR 
.PP
This option promotes big\-endian arguments passed to 
varargs functions to 64\-bit. 
It forces the compiler to promote non\-64\-bit big\-endian
arguments passed to vararg/variadic functions to 64\-bit. For example, you can
use this option to promote 32\-bit big\-endian arguments passed to 
void my_printf(const char*, ...) function, to 64\-bit.
.NL
.RE
.TP
.B
\-qenable\-biendian\-extended\-cxx
.TP
.B
\-qno\-enable\-biendian\-extended\-cxx
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Enables extended C++ support mode for template initialization in the bi\-endian
compiler. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-enable\-biendian\-extended\-cxx
.NL
Extended C++ mode support is disabled 
.TP
\fBDescription:\fR 
.PP
By default, the bi\-endian compiler uses the simple C++ support mode for
template initialization, which works well for C programs with limited use of
C++ features. In the simple C++ support mode, byte order is not part of a type
but is an attribute of an entity. Using the 
\-qenable\-biendian\-extended\-cxx option enables the extended C++
support mode, which works better for full\-scale C++ programs. In the extended
C++ support mode, byte order is part of a type \- so big\-endian and
little\-endian are two distinct types. 
.NL
.PP
This option can be used to effect byte\-order swaps for
template types in applications developed to run on MontaVista* Linux* and QNX*
target systems. 
.NL
.PP
To disable the extended C++ mode support, use the 
\-qno\-enable\-biendian\-extended\-cxx option. 
.NL
.PP
The 
\-Qoption,cpp,\-\-separate_biendian_types option that was used
previously to enable extended C++ mode, is deprecated. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
\-Qoption,cpp,\-\-separate_biendian_types
is deprecated 
.NL
.RE
.TP
.B
\-[no\-]resolve\-byte\-order\-mismatch
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Enables automatic adjustment of the pointed\-to type byte order. 
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.PP
OFF
.NL
.TP
\fBDescription:\fR 
.PP
This option enables automatic adjustment of the
pointed\-to type byte order in the following cases: 
.IP \(bu 2
The pointed\-to value is a local
variable of an integer or pointer data type. 
.IP \(bu 2
The byte
order of the variable or its type is not set explicitly with the byte order
attribute (__attribute__((bigendian)) or 
__attribute__((littleendian))). 
.IP \(bu 2
Changing
byte order of the variable in its definition will not cause byte order
mismatches with pointed\-to type in any place where the variable is used. 
.PP
.B NOTE:
If a variable is used as a parameter in a method call, its byte order
is counted according to the method declaration. 
.NL
.RE
.TP
.B
\-Qoption,cpp,\-\-separate_biendian_types
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Enables extended bi\-endian C++ support mode. 
This option is deprecated. Use 
\-qenable\-extended\-mode\-cxx option instead.
.NL
.TP
\fBArguments:\fR 
.PP
None 
.NL
.TP
\fBDefault:\fR 
.PP
OFF
.NL
.TP
\fBDescription:\fR 
.PP
This option enables bi\-endian extended C++ mode. This
option is deprecated. Use 
\-qenable\-extended\-mode\-cxx option instead. 
.NL
.RE
.TP
.B
\-size\-llp64
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Enables LLP64 compilation mode. 
.NL
.TP
\fBDescription:\fR 
.PP
This option enables the 
LLP64 compilation mode. In this mode the compiler uses
64\-bit pointers, but long data types remain 32\-bit. The 
long long, size_t, and 
ptrdiff_tdata types are 64\-bit. 
.NL
.PP
The 
\-size\-llp64 sets the following predefined macros: 
.PP
__LONG_MAX__=2147483647L
__LLP64__
_LLP64
__PTRDIFF_TYPE__="long long"
__SIZE_TYPE__="unsigned long long"
.PP
.PP
.B NOTE:
Objects compiled with this option are not compatible with objects
compiled without this option. 
.NL
.RE
.TP
.B
\-static\-data\-init
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Specifies static initialization mode for big\-endian data. By default, this
option is disabled and silently ignored at compile time. 
.NL
.TP
\fBDefault:\fR 
.PP
OFF
.NL
.TP
\fBDescription:\fR 
.PP
The \-static\-data\-init option is
supported by the Post Link Tool. You use this option to specify static
initialization mode for big\-endian data. By default, this option is disabled
and silently ignored at compile time. 
.NL
.RE
.TP
.B
\-swap\-pointers
.TP
.B
\-no\-swap\-pointers
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Specifies whether objects of pointer and reference type are byte swapped. 
.NL
.TP
\fBDefault:\fR 
.TP 18
\-swap\-pointers
.NL
Objects of pointer and reference type are byte
swapped by default. 
.TP
\fBDescription:\fR 
.PP
This option specifies whether objects of pointer and
reference type are byte swapped. This option is particularly important when
mixing code (for example, big\-endian code calling a little\-endian library). The
default setting is that objects of pointer and reference type are byte swapped.
.NL
.PP
You can improve application performance by specifying the
\-no\-swap\-pointers option. If a pointer is declared as
big\-endian, it is assumed to be big\-endian. For example, in the following
statements, 
x and 
y are big\-endian but 
x1 and 
y1 are little\-endian. 
.PP
#pragma byte_order big\-endian
int x;
int * y;
#pragma byte_order little\-endian
int x1;
int * y1;
.PP
.NL
.PP
If you specify 
\-no\-swap\-pointerswhile compiling, the pointers are processed
differently. Both 
y and 
y1are assumed to be little\-endian, even though 
y is declared in the big\-endian context.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.RE
.TP
.B
\-symcheck
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Enables checking of global symbol types. 
.NL
.TP
\fBDefault:\fR 
.PP
OFF
.NL
.TP
\fBDescription:\fR 
.PP
This option activates type checking of global variables
and routines. When you specify this option for the compile step, the compiler
generates type information for every public data object and routine defined or
referenced in the compilation units. 
.NL
.PP
If you specify this option for the link step, the
compiler invokes the bi\-endian post link tool for checking the type consistency
of public objects and routines in the output file. The post link tool outputs
descriptive messages for any incompatibilities it detects. 
.NL
.RE
.TP
.B
\-use\-decl\-byte\-order
.RS
.TP
This option applies only to the bi\-endian C++
compiler. 
Sets default behavior of the compiler to compile function
definitions with byte order specified in the function declaration.
.NL
.TP
\fBDefault:\fR 
.PP
OFF 
.NL
.TP
\fBDescription:\fR 
.PP
This option sets the default behavior
of the compiler to compile function definitions with the byte order specified
in the function declaration. 
.NL
.PP
You can specify the behavior at the
function level with the 
use_decl_byte_order attribute. This overrides the default
specified on the command line.
.NL
.PP
If you do not use this option, the compiler follows its
normal behavior and byte order for a function definition is based on the state
specified either with command line options ( 
\-big\-endian , 
\-little\-endian) or 
#pragma byte_orderor the endian attributes for types. 
.NL
.RE
.SH TECHNICAL SUPPORT
.PP
You can find product documentation for many released products at
http://software.intel.com/en\-us/intel\-software\-technical\-documentation/. 
.SS Product Website and Support 
.PP
To find technical support information, to register
your product, or to contact Intel, please visit:
https://software.intel.com/en\-us/support/. 
.NL
.PP
At this site, you will find comprehensive product
information, including: 
.NL
.IP \(bu 2
Links to each product, where you will find
technical information such as white papers, support, articles, and user forums 
.IP \(bu 2
Links to news and events 
.SS Release Notes
.PP
For detailed information on system requirements, late changes to the
products, supported architectures, operating systems, and Integrated
Development Environments (IDE) see the Release Notes for this product. 
.NL
.SS Forums
.PP
You can find helpful information in the Intel Software user forums.
You can also submit questions to the forums. To see the list of the available
forums, go to https://software.intel.com/en\-us/forum/. 
.NL
.SH SEE ALSO
.PP
icc(1), ld(1) 
.PP
Your compiler documentation has additional reference material on features of
your compiler.
.SH Legal Information
.PP
No license (express or implied, by estoppel or otherwise) to any
intellectual property rights is granted by this document. 
.NL
.PP
Intel disclaims all express and implied warranties, including without
limitation, the implied warranties of merchantability, fitness for a particular
purpose, and non\-infringement, as well as any warranty arising from course of
performance, course of dealing, or usage in trade. 
.NL
.PP
This document contains information on products, services and/or
processes in development. All information provided here is subject to change
without notice. Contact your Intel representative to obtain the latest
forecast, schedule, specifications and roadmaps. 
.NL
.PP
The products and services described may contain defects or errors
which may cause deviations from published specifications. Current characterized
errata are available on request. 
.NL
.PP
Copies of documents which have an order number and are referenced in this
document, or other Intel literature, may be obtained by calling 1\-800\-548\-4725,
or go to: http://www.intel.com/design/literature.htm 
.PP
Intel\[aq]s compilers may or may not optimize to the same degree for
non\-Intel microprocessors for optimizations that are not unique to Intel
microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction
sets and other optimizations. Intel does not guarantee the availability,
functionality, or effectiveness of any optimization on microprocessors not
manufactured by Intel. Microprocessor\-dependent optimizations in this product
are intended for use with Intel microprocessors. Certain optimizations not
specific to Intel microarchitecture are reserved for Intel microprocessors.
Please refer to the applicable product User and Reference Guides for more
information regarding the specific instruction sets covered by this notice.
Notice revision #20110804 
.PP
Intel, the Intel logo, Intel Atom, Intel Core, Intel Cilk, Intel VTune,
MMX, Pentium, Xeon, and Intel Xeon Phi are trademarks of Intel Corporation in
the U.S. and/or other countries. 
.PP
* Other names and brands may be claimed as the
property of others. 
.PP
(C) 2016, Intel Corporation. 
.PP
Portions Copyright (C) 2001, Hewlett\-Packard Development Company, L.P. 
