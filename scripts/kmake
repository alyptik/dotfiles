#!/bin/bash

# setup variables
save_dir="$PWD"
proj_dir=/store/code/projects
base=kernel
kern_src=linux
broot_src=buildroot
kern_build=obj/linux-x86
broot_build=obj/buildroot-x86
root="$proj_dir/$base/overlay"
kmod_dir="$root/lib/modules"
bmod_dir="$proj_dir/$base/$broot_build/target/usr/lib/modules"
build_type=''
append_args=()
mod_args=()
make_cmd=(make)
sparse_flag=''

# needed for buildroot
unset PERL_MM_OPT

# cleanup traps
function cleanup() {
	local build_lines error_lines
	build_lines="$(wc -l ../build.log.tmp 2>/dev/null | cut -f-1 -d' ')"
	error_lines="$(wc -l ../error.log.tmp 2>/dev/null | cut -f-1 -d' ')"
	[[ -z "$build_lines" ]] && build_lines=0
	[[ -z "$error_lines" ]] && error_lines=0
	if ((build_lines > 5)); then
		printf 'lines written to ../build.log: [%s]\n' "$build_lines"
		cat ../build.log.tmp >>../build.log
	fi
	if ((error_lines > 5)); then
		printf 'lines written to ../error.log: [%s]\n' "$error_lines"
		cat ../error.log.tmp >>../error.log
	fi
	rm -f ../build.log.tmp ../error.log.tmp
	cd "$save_dir" || exit 1
	trap - INT ERR EXIT
}
trap 'cleanup; kill -INT $$;' INT
trap 'cleanup' ERR EXIT

while getopts :bchkmns opt; do
	case "$opt" in
	b)
		[[ -n "$build_type" ]] && continue
		build_type=b
		;;
	c)
		[[ "${append_args[*]}" == *nconfig* ]] && continue
		append_args+=(nconfig)
		;;
	k)
		[[ -n "$build_type" ]] && continue
		build_type=k
		;;
	m)
		[[ "${mod_args[*]}" == *modules_install* ]] && continue
		mod_args+=("INSTALL_MOD_PATH=$root" modules_install)
		;;
	n)
		make_cmd=(echo make)
		;;
	s)
		sparse_flag=1
		;;
	h)
		printf 'usage: %s -(b|k) [-cdhmns] [<make args>]\n' "${0##*/}" >&2
		exit
		;;
	:|?)
		printf 'illegal option letter: %s\n' "'$OPTARG'" >&2
		printf 'usage: %s -(b|k) [-cdhmns] [<make args>]\n' "${0##*/}" >&2
		exit 1
		;;
	esac
done
shift "$((OPTIND - 1))"

# build command-line
append_args=("$@")
case "$build_type" in
b)

	src_dir="$proj_dir/$base/$broot_src"
	out_dir="../$broot_build"
	;;
k)
	src_dir="$proj_dir/$base/$kern_src"
	out_dir="$proj_dir/$base/$kern_build"
	[[ -n "$sparse_flag" ]] && append_args+=('C=1')
	;;
*)
	printf 'usage: %s: -bk [-cdhmns] [<make args>]\n' "${0##*/}"
	exit
	;;
esac

# change directories and print final command
cd "$src_dir" || exit 1
printf 'executing: [%s %s %s]\n' \
	"$(tput sgr0)$(tput setaf 11)${make_cmd[*]}$(tput sgr0)" \
	"$(tput sgr0)$(tput setaf 9)O=$out_dir$(tput sgr0)" \
	"$(tput sgr0)$(tput setaf 10)${append_args[*]}$(tput sgr0)"
printf 'build directory: [%s]\n' \
	"$(tput sgr0)$(tput setaf 13)$src_dir$(tput sgr0)"
printf 'output directory: [%s]\n' \
	"$(tput sgr0)$(tput setaf 13)$(realpath -e "$out_dir" 2>/dev/null || echo '(error)')$(tput sgr0)"
printf 'kernel module directory: [%s]\n' \
	"$(tput sgr0)$(tput setaf 13)$kmod_dir$(tput sgr0)"
printf 'buildroot module directory: [%s]\n' \
	"$(tput sgr0)$(tput setaf 13)$bmod_dir$(tput sgr0)"

# record date
perl -e \
	'print "\n", "—"x72, "\nCompilation started at: ". `date`, "—"x72, "\n\n"' \
	| tee -a ../build.log.tmp

# start build
if [[ -z "$sparse_flag" ]]; then
	"${make_cmd[@]}" O="$out_dir" "${append_args[@]}"
else
	perl -e \
		'print "\n", "—"x72, "\nCompilation started at: ". `date`, "—"x72, "\n\n"' \
		>> ../error.log.tmp
	"${make_cmd[@]}" O="$out_dir" "${append_args[@]}" \
		2> >(tee -a ../error.log.tmp >&2) \
		> >(tee -a ../build.log.tmp)
fi

# install modules
if [[ -n "${mod_args[*]}" ]]; then
	rm -rf "${kmod_dir:?}"/* "${bmod_dir:?}"/*
	"${make_cmd[@]}" O="$out_dir" "${mod_args[@]}" \
		2> >(tee -a ../error.log.tmp >&2) \
		> >(tee -a ../build.log.tmp)
fi
